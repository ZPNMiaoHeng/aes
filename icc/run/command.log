#@ # 
#@ # Running icc_shell Version L-2016.03-SP1 for linux64 -- Apr 11, 2016
#@ # Date:   Wed May 25 02:53:57 2022
#@ # Run by: qst@cad09
#@ 

#@ # -- Starting source .synopsys_dc.setup

#@ # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#@ #  History
#@ # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#@ 
#@ history keep 200
#@ 
#@ 
#@ # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#@ #  Aliases
#@ # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#@ 
#@ alias h history
#@ alias rc "report_constraint -all_violators"
#@ alias rt report_timing
#@ alias ra report_area
#@ alias rq report_qor
#@ alias page_on {set sh_enable_page_mode true}
#@ alias page_off {set sh_enable_page_mode false}
#@ alias fr "remove_design -designs"
#@ 
#@ # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#@ #  Other lab specific settings
#@ # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#@ 
#@ set_app_var alib_library_analysis_path .. ; # Common ALIB library location
#@ #define_design_lib WORK -path ./	  ; # Location of "analyze"d files
#@ suppress_message "LINT-99 CMD-041 TFCHK-049 TFCHK-050 TFCHK-055 TFCHK-084 MWLIBP-300 MWLIBP-301 MWLIBP-324"  ; # Messages irrelevant to lab
#@ 
#@ # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#@ #  Additional Setup Files
#@ # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#@ source ../../dc/scr/hu40_lib.tcl
#@ # -- Starting source ../../dc/scr/hu40_lib.tcl

#@ #hu40_lib_list.tcl
#@ #----------------------------------------------------------
#@ #hu40 standard cell library list
#@ #----------------------------------------------------------
#@ #######################################
#@ set hu40 "../../../../hu40nmlib/1.02a"
#@ set libName	 "hu40npksdst"
#@ 
#@ #- - -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#@ #  hu 40 sdcell db file path
#@ # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#@ set hu40_dbpath "$hu40/liberty/logic_synth"
#@ 
#@ set hu40_db_ss_0v99_40c "$hu40_dbpath/${libName}_ss0p99vn40c.db"
#@ set hu40_db_ss_0v99_0c "$hu40_dbpath/${libName}_ss0p99v0c.db"
#@ set hu40_db_ss_0v99_125c "$hu40_dbpath/${libName}_ss0p99v125c.db"
#@ set hu40_db_ss_0v9_0c "$hu40_dbpath/${libName}_ss0p9v0c.db"
#@ set hu40_db_ss_0v9_125c "$hu40_dbpath/${libName}_ss0p9v125c.db"
#@ set hu40_db_ss_0v9_n40c "$hu40_dbpath/${libName}_ss0p9vn40c.db"
#@ set hu40_db_tt_1v0_25c "$hu40_dbpath/${libName}_tt1p0v25c.db"
#@ set hu40_db_tt_1v1_25c "$hu40_dbpath/${libName}_tt1p1v25c.db"
#@ set hu40_db_tt_1v2_25c "$hu40_dbpath/${libName}_tt1p2v25c.db"
#@ set hu40_db_ff_1v1_0c "$hu40_dbpath/${libName}_ff1p1v0c.db"
#@ set hu40_db_ff_1v1_40c "$hu40_dbpath/${libName}_ff1p1vn40c.db"
#@ set hu40_db_ff_1v1_125c "$hu40_dbpath/${libName}_ff1p1v125c.db"
#@ set hu40_db_ff_1v21_0c "$hu40_dbpath/${libName}_ff1p21v0c.db"
#@ set hu40_db_ff_1v21_40c "$hu40_dbpath/${libName}_ff1p21vn40c.db"
#@ set hu40_db_ff_1v21_125c "$hu40_dbpath/${libName}_ff1p21v125c.db"
#@ set hu40_db_ff_1v26_0c "$hu40_dbpath/${libName}_ff1p26v0c.db"
#@ set hu40_db_ff_1v26_40c "$hu40_dbpath/${libName}_ff1p26vn40c.db"
#@ set hu40_db_ff_1v26_125c "$hu40_dbpath/${libName}_ff1p26v125c.db"
#@ 
#@ 
#@ 
#@ 
#@ #- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#@ #  hu 40 sdcell mw reference file
#@ # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#@ set mstack		 "m07f0f1f0_RDL"
#@ set tf			 "m07f0f1f0_RDL"
#@ set hu40_mw		 "$hu40/milkyway"
#@ 
#@ #- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#@ #  hu 40 sdcell symbol file path
#@ # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#@ set hu40_sdbpath "$hu40/liberty/symbol"
#@ set hu40_sdb "$hu40_sdbpath/${libName}.sdb"
#@ #- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#@ #  hu 40 sdcell tf file path
#@ # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#@ set hu40_tfpath "$hu40_mw/tf"
#@ set hu40_tf7m "$hu40_tfpath/${libName}_${tf}.tf"
#@ #- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#@ #  hu 40 sdcell tluplus file
#@ # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#@ set hu40_tlupluspath "$hu40_mw/tlup"
#@ set hu40_TLU_CMAX "$hu40_tlupluspath/${mstack}/${libName}_${mstack}_w.tlup"
#@ set hu40_TLU_CMIN "$hu40_tlupluspath/${mstack}/${libName}_${mstack}_b.tlup"
#@ set hu40_TLU_TYP "$hu40_tlupluspath/${mstack}/${libName}_${mstack}_t.tlup"
#@ #set hu40_map "$hu40_tlupluspath/HLMC_cl040lp_rf_1p7m_601_cal.map"
#@ set hu40_map "$hu40_tlupluspath/extr_layers.map"
#@ #set hu40_map "$hu40_tlupluspath/layers.map"
#@ 
#@ 
#@ # -- End source ../../dc/scr/hu40_lib.tcl

#@ 
#@ 
#@ #set_min_library  ${MPW180_v1p8_io_max} -min_version  ${MPW180_v1p8_io_min}
#@ # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#@ #  Verify Settings
#@ # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#@ 
#@ echo "\nI am ready...\n"
#@ # -- End source .synopsys_dc.setup

save_mw_cel -as  afterpns
open_mw_cel afterpns
read_mw_cel afterpns
open_mw_cel afterpns
source ../scr/design_run.tcl
#@ # -- Starting source ../scr/design_run.tcl

#@ #design_run.tcl
#@ source ../rm_setup/lcrm_setup.tcl
#@ # -- Starting source ../rm_setup/lcrm_setup.tcl

#@ #########################################################################################
#@ # Lynx Compatible Reference Methodology (LCRM) Setup File
#@ # Script: lcrm_setup.tcl
#@ # Version: J-2014.09-SP2 (January 12, 2015)
#@ # Copyright (C) 2007-2015 Synopsys, Inc. All rights reserved.
#@ #########################################################################################
#@ ## DESCRIPTION:
#@ ## * This script provides LCRM scripts access to a subset of Lynx functions.
#@ ## * It manages variables and metric procedures used by the LCRM scripts when
#@ ## * running standalone or within the Lynx Design System.
#@ ## * 
#@ ## * Automation Variables:
#@ ## * The LCRM scripts utilize some variables for managing directory structures used
#@ ## * for log files, reports, and output data. These variables are hardcoded for correct
#@ ## * operation when running LCRM scripts standalone. When running the LCRM scripts within
#@ ## * the Lynx Design System, these variables are under control of the flow automation.
#@ ## * 
#@ ## * Metrics:
#@ ## * The lcrm_setup.tcl contains procedures to support extraction of metric information
#@ ## * about the design and system. These appear as METRIC strings in the log file. When
#@ ## * running within the Lynx Design System, these METRIC messages are extracted and 
#@ ## * transfered to a database server. The Lynx Manager Cockpit application can be used
#@ ## * to analyze and generate reports from the collected data.
#@ ## * 
#@ ## * Users of LCRM scripts need not modify any of the contents of this script or
#@ ## * related references contained in each task script. These Lynx Compatabile functions
#@ ## * work when in Lynx and when running standalone and do not add any appreciable runtime
#@ ## * overhead.
#@ ## -----------------------------------------------------------------------------
#@ 
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## Lynx System Variable. 
#@ ## When running in Lynx, these SEV* variables are configured in the GUI and saved
#@ ## in the system.tcl file. When running outside of Lynx, a number of SEV(*) variables 
#@ ## need to be set to values to avoid errors in some of the metric procedures.
#@ ## The environment variable LYNX_RTL_PRESENT is set automatically when Lynx is run and
#@ ## is used here to setup variables according to the runtime environment
#@ ## -----------------------------------------------------------------------------
#@ 
#@ 
#@ ## enable consistent script error handling across tools
#@ set sh_continue_on_error true
#@ 
#@ ## not all tool tcl shells handle the source options. StarRCXT is one example needing special handling
#@ if {[info exists synopsys_program_name]} {
#@   if { $synopsys_program_name=="tcl" } {
#@     set source_options ""
#@   } else {
#@     set source_options "-e -v"
#@   }
#@ } else {
#@   # tcl program does not support -e -v options
#@   set source_options ""
#@ }
#@ 
#@ ## Support of DC Explorer uses same program name as dc_shell. This is done in the LCRM
#@ ## to provide compatability with procedures in this file that only rely on dc_shell.
#@ if { [info exists synopsys_program_name] && $synopsys_program_name == "dc_shell" } {
#@   set_app_var de_rename_shell_name_to_dc_shell true
#@   set_app_var synopsys_program_name dc_shell
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## SVARs needing to be initialized for proper metric function
#@ ## -----------------------------------------------------------------------------
#@ set SVAR(metrics,path_group_ignore_list_setup) ""
#@ set SVAR(metrics,path_group_ignore_list_hold) ""
#@ set SVAR(metrics,max_path_group_count) 5
#@ 
#@ if { [info exists env(LYNX_RTM_PRESENT)] } {
#@ 
#@   puts "RM-Info: Lynx is setting SEV variables."
#@   set LYNX(rtm_present) 1
#@ 
#@   eval source $source_options ../../scripts_global/conf/system.tcl
#@ 
#@   ## -----------------------------------------------------------------------------
#@   ## Allow Lynx to define and overide dynamic System Environment Variabls
#@   ## -----------------------------------------------------------------------------
#@ 
#@   eval source $source_options $env(LYNX_VARFILE_SEV)
#@ 
#@ } else {
#@ 
#@   set LYNX(rtm_present) 0
#@   puts "RM-Info: Setting default SEV variables for running outside of Lynx."
#@   set SEV(project_dir)    my_project_dir
#@   set SEV(project_name)   lcrm
#@   set SEV(release_dir)    my_release_dir
#@   set SEV(techlib_dir)    my_techlib_dir
#@   set SEV(metrics_enable_generation) 1
#@   set SEV(metrics_enable_transfer) 1
#@   set SEV(log_file)       my_log_file
#@   set SEV(ver_star)       NaM
#@   set SEV(task)           [file root [file tail $SEV(script_file)]]
#@   set SEV(aro_enable)     0
#@ 
#@ }
#@ 
#@ 
#@ ## Remaining SEVs are calculated the same whether running standalone or in Lynx
#@ 
#@ if { ![info exist SEV(dont_run)] }      { set SEV(dont_run) 0 }
#@ if { ![info exist SEV(dont_exit)] }     { set SEV(dont_exit) 0 }
#@ if { ![info exist SEV(analysis_task)] } { set SEV(analysis_task) 0 }
#@ 
#@ set SEV(tmp_dir) [pwd]
#@ 
#@ set SEV(workarea_dir)   [file dirname [file dirname [file dirname [file dirname [file dirname $SEV(tmp_dir)]]]]]
#@ set SEV(techlib_name)   [file tail  [file dirname [file dirname [file dirname $SEV(tmp_dir)]]]]
#@ 
#@ set SEV(block_dir)      [file dirname [file dirname $SEV(tmp_dir)]]
#@ set SEV(block_name)     [file tail $SEV(block_dir)]
#@ set SEV(step_dir)       [file dirname $SEV(tmp_dir)]
#@ set SEV(step)           [file tail $SEV(step_dir)]
#@ set SEV(gscript_dir)    [file normalize $SEV(tmp_dir)/../../scripts_global]
#@ set SEV(tscript_dir)    [file normalize $SEV(tmp_dir)/../../scripts_global/$SEV(techlib_name)]
#@ set SEV(bscript_dir)    [file normalize $SEV(tmp_dir)/../../scripts_block]
#@ set SEV(work_dir)       [file normalize $SEV(tmp_dir)/../work]
#@ set SEV(src_dir)        [file normalize $SEV(tmp_dir)/../work/$SEV(src)]
#@ set SEV(dst_dir)        [file normalize $SEV(tmp_dir)/../work/$SEV(dst)]
#@ set SEV(log_dir)        [file normalize $SEV(tmp_dir)/../logs/$SEV(dst)]
#@ set SEV(rpt_dir)        [file normalize $SEV(tmp_dir)/../rpts/$SEV(dst)]
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## The SVAR(design_name) must be undefined at this point in the script
#@ ## -----------------------------------------------------------------------------
#@ 
#@ set SVAR(design_name)  undefined
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## These SVAR(tag_##) variables are a mechanism for grouping metrics. They are
#@ ## not used by default but can be overridden in block.tcl as shown below
#@ ## -----------------------------------------------------------------------------
#@ 
#@ set SVAR(tag_01) [list value]
#@ set SVAR(tag_02) [list value]
#@ set SVAR(tag_03) [list value]
#@ set SVAR(tag_04) [list value]
#@ set SVAR(tag_05) [list value]
#@ set SVAR(tag_06) [list value]
#@ set SVAR(tag_07) [list value]
#@ set SVAR(tag_08) [list value]
#@ set SVAR(tag_09) [list value]
#@ set SVAR(tag_10) [list value]
#@ set SVAR(tag_11) [list value]
#@ set SVAR(tag_12) [list value]
#@ set SVAR(tag_13) [list value]
#@ set SVAR(tag_14) [list value]
#@ set SVAR(tag_15) [list value]
#@ set SVAR(tag_16) [list value]
#@ set SVAR(tag_17) [list value]
#@ set SVAR(tag_18) [list value]
#@ set SVAR(tag_19) [list value]
#@ set SVAR(tag_20) [list value]
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## The block.tcl file is normally empty but sourced here 
#@ ## The most common use would be for overriding metric tags SVAR(tag_##) listed above
#@ ## as a method of labeling groups of experiments for easier metric filtering.
#@ ## -----------------------------------------------------------------------------
#@ 
#@ if {[file exists ../rm_setup/block.tcl]} {
#@   puts "RM-Info: sourcing ../rm_setup/block.tcl"
#@   eval source $source_options ../rm_setup/block.tcl
#@ }
#@ # -- Starting source ../rm_setup/block.tcl

#@ ##########################################################################################
#@ # Lynx Compatible Reference Methodology (LCRM) Setup File
#@ # Script: block.tcl
#@ # Version: J-2014.09-SP2 (January 12, 2015)
#@ # Copyright (C) 2007-2015 Synopsys, Inc. All rights reserved.
#@ ##########################################################################################
#@ 
#@ ## DESCRIPTION:
#@ ## * This script is required to be present when running in Lynx. It is sourced 
#@ ## * by lcrm_setup.tcl and can be optionally used to customize variables like 
#@ ## * SVAR(tag#) as a mechanism to group metrics. Configuration is best done
#@ ## * using the Lynx Runtime Manager block variable editor
#@ ## -----------------------------------------------------------------------------
#@ 
#@ # -- End source ../rm_setup/block.tcl

#@ 
#@ if { [info exists env(LYNX_RTM_PRESENT)] } {
#@ 
#@   if { ![info exists SVAR(misc,early_complete_enable)] } { set SVAR(misc,early_complete_enable) 0 }
#@ 
#@   ## -----------------------------------------------------------------------------
#@   ## Allow Lynx to overide Task Environment Variabls
#@   ## -----------------------------------------------------------------------------
#@ 
#@   puts "RM-Info: Lynx is setting any TEV overrides from the RTM environment"
#@   eval source $source_options $env(LYNX_VARFILE_TEV)
#@ 
#@ } else {
#@   ## disable early_complete feature for all standalone execution
#@   set SVAR(misc,early_complete_enable) 0
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## These Task variables that need to be assigned for proper standalone behavior but
#@ ## that are controlled in the Lynx environment by the content of LYNX_VARFILE_TEV file
#@ ## sourced below
#@ ## -----------------------------------------------------------------------------
#@ 
#@ set TEV(vx_enable) 0
#@ set TEV(scenario) DEFAULT_SCENARIO
#@ set TEV(report_level) NORMAL
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## These procedures/variables are not uniformly available
#@ ## for all tools used in the flow. This section of code creates
#@ ## the procedures/variables if they are not available.
#@ ## -----------------------------------------------------------------------------
#@ 
#@ if { ![info exists synopsys_root] } {
#@ set synopsys_root "synopsys_root"
#@ }
#@ 
#@ if { ![info exists synopsys_program_name] } {
#@ set synopsys_program_name "tcl"
#@ }
#@ 
#@ if { $synopsys_program_name == "tcl" } {
#@ set sh_product_version [info patchlevel]
#@ }
#@ 
#@ if { [info command parse_proc_arguments] != "parse_proc_arguments" } {
#@ proc parse_proc_arguments { cmdSwitch procArgs optsRef } {
#@ upvar $optsRef opts
#@ if { $cmdSwitch == "-args" } {
#@ foreach arg $procArgs {
#@ if { [string index $arg 0] == "-" } {
#@   set curArg $arg
#@   set opts($curArg) 1
#@ } else {
#@   if { [info exists curArg] } {
#@     set opts($curArg) $arg
#@     unset curArg
#@   } else {
#@     puts "SNPS_ERROR: Found invalid argument: '$arg', with no preceding switch."
#@     puts "SNPS_ERROR: Called from procedure: [lindex [info level -1] 0]"
#@   }
#@ }
#@ }
#@ }
#@ }
#@ }
#@ 
#@ if { [info command define_proc_attributes] != "define_proc_attributes" } {
#@ proc define_proc_attributes args {}
#@ }
#@ 
#@ if { [info command date] != "date" } {
#@ proc date {} {
#@ return [clock format [clock seconds] -format {%a %b %e %H:%M:%S %Y}]
#@ }
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_script_stop: LCRM customized version
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_script_stop { args } {
#@ 
#@   global LYNX
#@   global env SEV SVAR TEV
#@   global sh_product_version
#@   global synopsys_program_name
#@ 
#@   set options(-exit) 0
#@   parse_proc_arguments -args $args options
#@ 
#@   if {[info exists ::DESIGN_NAME]} {
#@     ## LCRM generates the corrected SYS.BLOCK metric reflecting DESIGN_NAME
#@     sproc_msg -info "METRIC | STRING SYS.BLOCK          | $::DESIGN_NAME"
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Generate metrics for each of the TEV variables.
#@   ## -------------------------------------
#@ 
#@   set generate_metrics_for_tev 0
#@ 
#@   if { $generate_metrics_for_tev } {
#@ 
#@     set name_list [lsort [array names TEV]]
#@     foreach name $name_list {
#@       set length [llength $TEV($name)]
#@       if { $length == 0 } {
#@         sproc_msg -info "METRIC | STRING TEV.$name | NULL_VALUE"
#@       } else {
#@         sproc_msg -info "METRIC | STRING TEV.$name | $TEV($name)"
#@       }
#@     }
#@ 
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Generate end-of-script metrics.
#@   ## -------------------------------------
#@ 
#@   sproc_metric_time -stop
#@   sproc_metric_system -end_of_script
#@ 
#@   ## -------------------------------------
#@   ## Exit processing.
#@   ## -------------------------------------
#@ 
#@   if { $LYNX(rtm_present) } {
#@     if { $SEV(dont_exit) } {
#@       ## User is requesting that no exit be performed.
#@     } else {
#@       ## Check to see if explicit exit is being requested.
#@       if { $options(-exit) } {
#@         if { $synopsys_program_name == "cdesigner" } {
#@           exit -force 1
#@         } else {
#@           exit
#@         }
#@       }
#@     }
#@   } else {
#@     if { $synopsys_program_name == "cdesigner" } {
#@       exit -force 1
#@     } else {
#@       exit
#@     }
#@   }
#@ 
#@ }
#@ 
#@ define_proc_attributes sproc_script_stop   -info "Standard procedure for ending a script."   -define_args {
#@   {-exit  "Perform an exit." "" boolean optional}
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_generate_metrics:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_generate_metrics {} {
#@ 
#@ sproc_pinfo -mode start
#@ 
#@ global env SEV SVAR TEV
#@   global synopsys_program_name
#@   global power_enable_analysis
#@   global case_analysis_sequential_propagation
#@   global DESIGN_NAME DCRM_MCMM_SCENARIOS_SETUP_FILE
#@   global REPORTS_DIR
#@ 
#@   file mkdir $SEV(rpt_dir)
#@ 
#@   switch $synopsys_program_name {
#@     dc_shell {
#@       source ../rm_setup/metric_reports_dc.tcl
#@       sproc_metric_main -metrics_design -metrics_power -metrics_sta
#@     }
#@     icc_shell {
#@       set my_all_active_scenarios [all_active_scenarios]
#@       source ../rm_setup/metric_reports_icc.tcl
#@       if { [regexp {clock_opt_} $SEV(script_file) ] && [llength $my_all_active_scenarios] > 0 } {
#@         sproc_metric_main -metrics_design -metrics_power -metrics_sta -metrics_cts
#@       } else {
#@         sproc_metric_main -metrics_design -metrics_power -metrics_sta
#@       }
#@     }
#@     pt_shell {
#@       set RPT(basename) $SEV(rpt_dir)/pt.$TEV(scenario)
#@       source ../rm_setup/metric_reports_pt.tcl
#@       if { $power_enable_analysis } {
#@         sproc_metric_main -metrics_sta -scenario_name $TEV(scenario) -metrics_power
#@       } else {
#@         sproc_metric_main -metrics_sta -scenario_name $TEV(scenario)
#@       }
#@     }
#@     tmax_tcl {
#@       redirect ${REPORTS_DIR}/tmax_rm.report_summaries {
#@         report_summaries 
#@       }
#@       sproc_metric_atpg
#@     }
#@   }
#@ 
#@   sproc_pinfo -mode stop
#@ 
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_script_start:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_script_start {} {
#@ 
#@   global LYNX
#@   global env SEV SVAR TEV
#@   global sh_product_version
#@   global synopsys_program_name
#@ 
#@   sproc_metric_time -start
#@   sproc_metric_system -start_of_script
#@ 
#@ }
#@ 
#@ define_proc_attributes sproc_script_start   -info "Standard procedure for starting a script."   -define_args {
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_script_start:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_script_start {} {
#@ 
#@   global LYNX
#@   global env SEV SVAR TEV
#@   global sh_product_version
#@   global synopsys_program_name
#@ 
#@   sproc_metric_time -start
#@   sproc_metric_system -start_of_script
#@ 
#@ }
#@ 
#@ define_proc_attributes sproc_script_start   -info "Standard procedure for starting a script."   -define_args {
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_msg:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_msg { args } {
#@ 
#@   ## Assigning default value of "bell" since that is never used.
#@ 
#@   set options(-info)    "\b"
#@   set options(-warning) "\b"
#@   set options(-error)   "\b"
#@   set options(-setup)   "\b"
#@   set options(-issue)   "\b"
#@   set options(-note)    "\b"
#@   set options(-header)  0
#@   parse_proc_arguments -args $args options
#@ 
#@   global _sproc_msg_count
#@   if { ![info exists _sproc_msg_count(warning)] } { set _sproc_msg_count(warning) 0 }
#@   if { ![info exists _sproc_msg_count(issue)]   } { set _sproc_msg_count(issue)   0 }
#@   if { ![info exists _sproc_msg_count(note)]    } { set _sproc_msg_count(note)    0 }
#@ 
#@   if       { $options(-info)   != "\b" } {
#@     puts "SNPS_INFO   : $options(-info)"
#@   } elseif { $options(-warning) != "\b" } {
#@     puts "SNPS_WARNING: $options(-warning)"
#@     incr _sproc_msg_count(warning)
#@   } elseif { $options(-error)  != "\b" } {
#@     puts "SNPS_ERROR  : $options(-error)"
#@   } elseif { $options(-setup)  != "\b" } {
#@     puts "SNPS_SETUP  : $options(-setup)"
#@   } elseif { $options(-issue)  != "\b" } {
#@     puts "SNPS_ISSUE  : $options(-issue)"
#@     incr _sproc_msg_count(issue)
#@   } elseif { $options(-note)  != "\b" } {
#@     puts "SNPS_NOTE  : $options(-note)"
#@     incr _sproc_msg_count(note)
#@   } elseif { $options(-header) } {
#@     puts "SNPS_HEADER : ## ------------------------------------- "
#@   } else {
#@     puts "SNPS_ERROR  : Unrecognized arguments for sproc_msg : $args"
#@   }
#@ }
#@ 
#@ define_proc_attributes sproc_msg   -info "Standard message printing procedure."   -define_args {
#@   {-info    "Info message"    AString string optional}
#@   {-warning "Warning message" AString string optional}
#@   {-error   "Error message"   AString string optional}
#@   {-setup   "Setup message"   AString string optional}
#@   {-issue   "Issue message"   AString string optional}
#@   {-note    "Note  message"   AString string optional}
#@   {-header  "Header flag"     ""      boolean optional}
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_msg:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_msg { args } {
#@ 
#@   ## Assigning default value of "bell" since that is never used.
#@ 
#@   set options(-info)    "\b"
#@   set options(-warning) "\b"
#@   set options(-error)   "\b"
#@   set options(-setup)   "\b"
#@   set options(-issue)   "\b"
#@   set options(-note)    "\b"
#@   set options(-header)  0
#@   parse_proc_arguments -args $args options
#@ 
#@   global _sproc_msg_count
#@   if { ![info exists _sproc_msg_count(warning)] } { set _sproc_msg_count(warning) 0 }
#@   if { ![info exists _sproc_msg_count(issue)]   } { set _sproc_msg_count(issue)   0 }
#@   if { ![info exists _sproc_msg_count(note)]    } { set _sproc_msg_count(note)    0 }
#@ 
#@   if       { $options(-info)   != "\b" } {
#@     puts "SNPS_INFO   : $options(-info)"
#@   } elseif { $options(-warning) != "\b" } {
#@     puts "SNPS_WARNING: $options(-warning)"
#@     incr _sproc_msg_count(warning)
#@   } elseif { $options(-error)  != "\b" } {
#@     puts "SNPS_ERROR  : $options(-error)"
#@   } elseif { $options(-setup)  != "\b" } {
#@     puts "SNPS_SETUP  : $options(-setup)"
#@   } elseif { $options(-issue)  != "\b" } {
#@     puts "SNPS_ISSUE  : $options(-issue)"
#@     incr _sproc_msg_count(issue)
#@   } elseif { $options(-note)  != "\b" } {
#@     puts "SNPS_NOTE  : $options(-note)"
#@     incr _sproc_msg_count(note)
#@   } elseif { $options(-header) } {
#@     puts "SNPS_HEADER : ## ------------------------------------- "
#@   } else {
#@     puts "SNPS_ERROR  : Unrecognized arguments for sproc_msg : $args"
#@   }
#@ }
#@ 
#@ define_proc_attributes sproc_msg   -info "Standard message printing procedure."   -define_args {
#@   {-info    "Info message"    AString string optional}
#@   {-warning "Warning message" AString string optional}
#@   {-error   "Error message"   AString string optional}
#@   {-setup   "Setup message"   AString string optional}
#@   {-issue   "Issue message"   AString string optional}
#@   {-note    "Note  message"   AString string optional}
#@   {-header  "Header flag"     ""      boolean optional}
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_source:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_source { args } {
#@ 
#@   global synopsys_program_name SEV
#@ 
#@   if { ![info exists SEV(log_level)] } {
#@     set SEV(log_level) 1
#@   }
#@ 
#@   set options(-file) ""
#@   set options(-quiet) 0
#@   set options(-optional) 0
#@   parse_proc_arguments -args $args options
#@ 
#@   if { [llength $options(-file)] > 0 } {
#@     ## The file specification is not empty.
#@     if { [file exists $options(-file)] } {
#@       sproc_msg -info "SCRIPT_START : [file normalize $options(-file)] : [date]"
#@       if { $synopsys_program_name == "tcl" } {
#@         uplevel 1 source $options(-file)
#@       } elseif { $synopsys_program_name == "cdesigner" } {
#@         uplevel 1 source $options(-file)
#@       } elseif { $synopsys_program_name == "mvrc" } {
#@         uplevel 1 source $options(-file)
#@       } else {
#@ 
#@         ## -------------------------------------
#@         ## Determine the verbosity level.
#@         ## -------------------------------------
#@ 
#@         set filename [file tail $options(-file)]
#@ 
#@         switch -glob $filename {
#@           procs.tcl -
#@           procs_metrics.tcl -
#@           procs_flow.tcl -
#@           procs_user.tcl -
#@           procs_qor.tcl -
#@           system.tcl -
#@           *.sev.varfile -
#@           system_setup.tcl -
#@           common.tcl -
#@           block.tcl -
#@           *.tev.varfile -
#@           block_setup.tcl {
#@             set is_standard_file 1
#@           }
#@           default {
#@             set is_standard_file 0
#@           }
#@         }
#@ 
#@         switch $SEV(log_level) {
#@           0 {
#@             ## Normal Mode
#@             set quite_mode $options(-quiet)
#@           }
#@           1 {
#@             ## Suppress-standard-files Mode
#@             if { $is_standard_file } {
#@               set quite_mode 1
#@             } else {
#@               set quite_mode $options(-quiet)
#@             }
#@           }
#@           2 {
#@             ## Suppress-all-files Mode
#@             set quite_mode 1
#@           }
#@           default {
#@             ## Default to Normal Mode if variable value is incorrect.
#@             set quite_mode $options(-quiet)
#@             sproc_msg -error "Value for SEV(log_level) not recognized."
#@           }
#@         }
#@ 
#@         if { $quite_mode } {
#@           uplevel 1 source $options(-file)
#@         } else {
#@           uplevel 1 source -e -v $options(-file)
#@         }
#@ 
#@       }
#@ 
#@       sproc_msg -info "SCRIPT_STOP  : [file normalize $options(-file)] : [date]"
#@ 
#@     } else {
#@ 
#@       sproc_msg -error "sproc_source: The specified file does not exist; '$options(-file)'"
#@ 
#@     }
#@ 
#@   } else {
#@ 
#@     ## The file specification is empty.
#@     if { $options(-optional) } {
#@       sproc_msg -warning "sproc_source: An empty file specification was provided; file is optional."
#@     } else {
#@       sproc_msg -error   "sproc_source: An empty file specification was provided; file is not optional."
#@     }
#@ 
#@   }
#@ 
#@ }
#@ 
#@ define_proc_attributes sproc_source   -info "Provides a standard way to source files."   -define_args {
#@   {-file "This option is used to specify the file to source. An argument value of <non-empty-string> requires that the specified file exists. An argument value of <empty-string> will cause an error unless the -optional argument is also supplied." AString string required}
#@   {-optional "This option prevents an <empty-string> -file argument from causing an error." "" boolean optional}
#@   {-quiet "Echo minimal file content." "" boolean optional}
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_source:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_source { args } {
#@ 
#@   global synopsys_program_name SEV
#@ 
#@   if { ![info exists SEV(log_level)] } {
#@     set SEV(log_level) 1
#@   }
#@ 
#@   set options(-file) ""
#@   set options(-quiet) 0
#@   set options(-optional) 0
#@   parse_proc_arguments -args $args options
#@ 
#@   if { [llength $options(-file)] > 0 } {
#@     ## The file specification is not empty.
#@     if { [file exists $options(-file)] } {
#@       sproc_msg -info "SCRIPT_START : [file normalize $options(-file)] : [date]"
#@       if { $synopsys_program_name == "tcl" } {
#@         uplevel 1 source $options(-file)
#@       } elseif { $synopsys_program_name == "cdesigner" } {
#@         uplevel 1 source $options(-file)
#@       } elseif { $synopsys_program_name == "mvrc" } {
#@         uplevel 1 source $options(-file)
#@       } else {
#@ 
#@         ## -------------------------------------
#@         ## Determine the verbosity level.
#@         ## -------------------------------------
#@ 
#@         set filename [file tail $options(-file)]
#@ 
#@         switch -glob $filename {
#@           procs.tcl -
#@           procs_metrics.tcl -
#@           procs_flow.tcl -
#@           procs_user.tcl -
#@           procs_qor.tcl -
#@           system.tcl -
#@           *.sev.varfile -
#@           system_setup.tcl -
#@           common.tcl -
#@           block.tcl -
#@           *.tev.varfile -
#@           block_setup.tcl {
#@             set is_standard_file 1
#@           }
#@           default {
#@             set is_standard_file 0
#@           }
#@         }
#@ 
#@         switch $SEV(log_level) {
#@           0 {
#@             ## Normal Mode
#@             set quite_mode $options(-quiet)
#@           }
#@           1 {
#@             ## Suppress-standard-files Mode
#@             if { $is_standard_file } {
#@               set quite_mode 1
#@             } else {
#@               set quite_mode $options(-quiet)
#@             }
#@           }
#@           2 {
#@             ## Suppress-all-files Mode
#@             set quite_mode 1
#@           }
#@           default {
#@             ## Default to Normal Mode if variable value is incorrect.
#@             set quite_mode $options(-quiet)
#@             sproc_msg -error "Value for SEV(log_level) not recognized."
#@           }
#@         }
#@ 
#@         if { $quite_mode } {
#@           uplevel 1 source $options(-file)
#@         } else {
#@           uplevel 1 source -e -v $options(-file)
#@         }
#@ 
#@       }
#@ 
#@       sproc_msg -info "SCRIPT_STOP  : [file normalize $options(-file)] : [date]"
#@ 
#@     } else {
#@ 
#@       sproc_msg -error "sproc_source: The specified file does not exist; '$options(-file)'"
#@ 
#@     }
#@ 
#@   } else {
#@ 
#@     ## The file specification is empty.
#@     if { $options(-optional) } {
#@       sproc_msg -warning "sproc_source: An empty file specification was provided; file is optional."
#@     } else {
#@       sproc_msg -error   "sproc_source: An empty file specification was provided; file is not optional."
#@     }
#@ 
#@   }
#@ 
#@ }
#@ 
#@ define_proc_attributes sproc_source   -info "Provides a standard way to source files."   -define_args {
#@   {-file "This option is used to specify the file to source. An argument value of <non-empty-string> requires that the specified file exists. An argument value of <empty-string> will cause an error unless the -optional argument is also supplied." AString string required}
#@   {-optional "This option prevents an <empty-string> -file argument from causing an error." "" boolean optional}
#@   {-quiet "Echo minimal file content." "" boolean optional}
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_pinfo:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_pinfo { args } {
#@ 
#@   set options(-mode) ""
#@   parse_proc_arguments -args $args options
#@ 
#@   set parent_level [expr [info level] - 1]
#@   set parent_name [lindex [info level $parent_level] 0]
#@   set parent_name [regsub {^::} $parent_name {}]
#@ 
#@   set no_msg_list [list     sproc_refresh_file_system     sproc_metric_clean_string     sproc_metric_normalize     ]
#@ 
#@   if { [lsearch $no_msg_list $parent_name] >= 0 } {
#@     ## Suppress messages for these procedures.
#@   } else {
#@     switch $options(-mode) {
#@       start   { sproc_msg -info "PROC_START : $parent_name" }
#@       stop    { sproc_msg -info "PROC_STOP  : $parent_name" }
#@       default { sproc_msg -error "Invalid argument to sproc_pinfo" }
#@     }
#@   }
#@ 
#@ }
#@ 
#@ define_proc_attributes sproc_pinfo   -info "Prints standard messages at procedure boundaries."   -define_args {
#@   {-mode "Specifies which message to print" AnOos one_of_string
#@     {required value_help {values {start stop}}}
#@   }
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_pinfo:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_pinfo { args } {
#@ 
#@   set options(-mode) ""
#@   parse_proc_arguments -args $args options
#@ 
#@   set parent_level [expr [info level] - 1]
#@   set parent_name [lindex [info level $parent_level] 0]
#@   set parent_name [regsub {^::} $parent_name {}]
#@ 
#@   set no_msg_list [list     sproc_refresh_file_system     sproc_metric_clean_string     sproc_metric_normalize     ]
#@ 
#@   if { [lsearch $no_msg_list $parent_name] >= 0 } {
#@     ## Suppress messages for these procedures.
#@   } else {
#@     switch $options(-mode) {
#@       start   { sproc_msg -info "PROC_START : $parent_name" }
#@       stop    { sproc_msg -info "PROC_STOP  : $parent_name" }
#@       default { sproc_msg -error "Invalid argument to sproc_pinfo" }
#@     }
#@   }
#@ 
#@ }
#@ 
#@ define_proc_attributes sproc_pinfo   -info "Prints standard messages at procedure boundaries."   -define_args {
#@   {-mode "Specifies which message to print" AnOos one_of_string
#@     {required value_help {values {start stop}}}
#@   }
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_script_version:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_script_version {} {
#@ 
#@   sproc_pinfo -mode start
#@ 
#@   global LYNX
#@   global env SEV SVAR TEV
#@ 
#@   ## Determine version of $SEV(script_file)
#@ 
#@   set version "Nam"
#@ 
#@   if { [file exists $SEV(script_file)] } {
#@ 
#@     set fid [open $SEV(script_file) r]
#@ 
#@     while { [gets $fid line] >= 0 } {
#@ 
#@       ## -------------------------------------
#@       ## Perforce format example:
#@       ## -------------------------------------
#@ 
#@       set re {^## HEADER \$Id: [\w\/\.]+#([\d]+)}
#@ 
#@       if { [regexp $re $line match version] } {
#@         break
#@       }
#@ 
#@       ## -------------------------------------
#@       ## CVS format example:
#@       ## -------------------------------------
#@ 
#@       set re {^## HEADER \$Id: [\w\/\.\,]+\s+([\d\.]+)}
#@ 
#@       if { [regexp $re $line match version] } {
#@         break
#@       }
#@ 
#@     }
#@ 
#@     close $fid
#@   }
#@ 
#@   sproc_pinfo -mode stop
#@   return $version
#@ 
#@ }
#@ 
#@ define_proc_attributes sproc_script_version   -info "Used to determine the version of a script."   -define_args {
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_script_version:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_script_version {} {
#@ 
#@   sproc_pinfo -mode start
#@ 
#@   global LYNX
#@   global env SEV SVAR TEV
#@ 
#@   ## Determine version of $SEV(script_file)
#@ 
#@   set version "Nam"
#@ 
#@   if { [file exists $SEV(script_file)] } {
#@ 
#@     set fid [open $SEV(script_file) r]
#@ 
#@     while { [gets $fid line] >= 0 } {
#@ 
#@       ## -------------------------------------
#@       ## Perforce format example:
#@       ## -------------------------------------
#@ 
#@       set re {^## HEADER \$Id: [\w\/\.]+#([\d]+)}
#@ 
#@       if { [regexp $re $line match version] } {
#@         break
#@       }
#@ 
#@       ## -------------------------------------
#@       ## CVS format example:
#@       ## -------------------------------------
#@ 
#@       set re {^## HEADER \$Id: [\w\/\.\,]+\s+([\d\.]+)}
#@ 
#@       if { [regexp $re $line match version] } {
#@         break
#@       }
#@ 
#@     }
#@ 
#@     close $fid
#@   }
#@ 
#@   sproc_pinfo -mode stop
#@   return $version
#@ 
#@ }
#@ 
#@ define_proc_attributes sproc_script_version   -info "Used to determine the version of a script."   -define_args {
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_metric_system:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_metric_system { args } {
#@ 
#@   sproc_pinfo -mode start
#@ 
#@   global env SEV SVAR TEV DEV
#@   global sh_product_version
#@   global synopsys_program_name
#@   global _sproc_msg_count
#@   global SNPS_time_start SNPS_time_stop
#@ 
#@   set xxx1 [clock seconds]
#@ 
#@   set options(-start_of_script) 0
#@   set options(-end_of_script) 0
#@   set options(-mem_mb) -1
#@   parse_proc_arguments -args $args options
#@ 
#@   if { $options(-start_of_script) } {
#@ 
#@     sproc_msg -info "METRIC | STRING SYS.TASK           | $SEV(task)"
#@     sproc_msg -info "METRIC | STRING SYS.PROJECT_NAME   | $SEV(project_name)"
#@     sproc_msg -info "METRIC | STRING SYS.PROJECT_DIR    | $SEV(project_dir)"
#@     sproc_msg -info "METRIC | STRING SYS.TECHLIB_NAME   | $SEV(techlib_name)"
#@     sproc_msg -info "METRIC | STRING SYS.TECHLIB_DIR    | $SEV(techlib_dir)"
#@     sproc_msg -info "METRIC | STRING SYS.WORKAREA_DIR   | $SEV(workarea_dir)"
#@     sproc_msg -info "METRIC | STRING SYS.BLOCK_DIR      | $SEV(block_dir)"
#@     sproc_msg -info "METRIC | STRING SYS.USER           | [exec whoami]"
#@     sproc_msg -info "METRIC | STRING SYS.BLOCK          | $SVAR(design_name)"
#@     sproc_msg -info "METRIC | STRING SYS.STEP           | $SEV(step)"
#@     sproc_msg -info "METRIC | STRING SYS.SRC            | $SEV(src)"
#@     sproc_msg -info "METRIC | STRING SYS.DST            | $SEV(dst)"
#@     sproc_msg -info "METRIC | STRING SYS.LOG            | [file normalize $SEV(log_file)]"
#@     sproc_msg -info "METRIC | STRING SYS.SCRIPT_NAME    | [file normalize $SEV(script_file)]"
#@     sproc_msg -info "METRIC | STRING SYS.SCRIPT_VERSION | [sproc_script_version]"
#@ 
#@     set script_type unknown
#@     if { [regexp "/scripts_global/" $SEV(script_file)] } {
#@       set script_type global
#@     }
#@     if { [regexp "/scripts_global/$SEV(techlib_name)/" $SEV(script_file)] } {
#@       set script_type techlib
#@     }
#@     if { [regexp "/scripts_block/" $SEV(script_file)] } {
#@       set script_type block
#@     }
#@     sproc_msg -info "METRIC | STRING SYS.SCRIPT_TYPE    | $script_type"
#@ 
#@     sproc_msg -info "METRIC | STRING SYS.MACHINE        | [exec uname -n]"
#@     sproc_msg -info "METRIC | STRING SYS.TOOL_NAME      | $synopsys_program_name"
#@ 
#@     if { ![info exists sh_product_version] || $sh_product_version == "" } {
#@       set sh_product_version NaM
#@     }
#@     sproc_msg -info "METRIC | STRING SYS.TOOL_VERSION   | $sh_product_version"
#@ 
#@     if { $SEV(dont_run) || $SEV(dont_exit) } {
#@       if { $SEV(analysis_task) } {
#@         sproc_msg -info "METRIC | STRING SYS.TASK_TYPE      | ANALYZE_INTERACTIVE"
#@       } else {
#@         sproc_msg -info "METRIC | STRING SYS.TASK_TYPE      | OPTIMIZE_INTERACTIVE"
#@       }
#@     } else {
#@       if { $SEV(analysis_task) } {
#@         sproc_msg -info "METRIC | STRING SYS.TASK_TYPE      | ANALYZE"
#@       } else {
#@         sproc_msg -info "METRIC | STRING SYS.TASK_TYPE      | OPTIMIZE"
#@       }
#@     }
#@ 
#@     sproc_msg -info "METRIC | TAG SYS.TAG_01 | $SVAR(tag_01)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_02 | $SVAR(tag_02)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_03 | $SVAR(tag_03)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_04 | $SVAR(tag_04)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_05 | $SVAR(tag_05)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_06 | $SVAR(tag_06)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_07 | $SVAR(tag_07)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_08 | $SVAR(tag_08)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_09 | $SVAR(tag_09)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_10 | $SVAR(tag_10)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_11 | $SVAR(tag_11)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_12 | $SVAR(tag_12)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_13 | $SVAR(tag_13)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_14 | $SVAR(tag_14)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_15 | $SVAR(tag_15)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_16 | $SVAR(tag_16)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_17 | $SVAR(tag_17)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_18 | $SVAR(tag_18)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_19 | $SVAR(tag_19)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_20 | RTM_PRESENT !! [info exists env(LYNX_RTM_PRESENT)]" 
#@ 
#@     sproc_metric_tags
#@ 
#@     if { [info exists SEV(flow_order)] } {
#@       sproc_msg -info "METRIC | INTEGER SYS.FLOW_ORDER | $SEV(flow_order)"
#@     }
#@ 
#@   }
#@ 
#@   if { $options(-end_of_script) } {
#@ 
#@     if { ![info exists TEV(num_jobs)] }        { set TEV(num_jobs) 1 }
#@     if { ![info exists TEV(num_cores)] }       { set TEV(num_cores) 1 }
#@     if { ![info exists TEV(num_child_jobs)] }  { set TEV(num_child_jobs) 1 }
#@     if { ![info exists TEV(num_child_cores)] } { set TEV(num_child_cores) 1 }
#@ 
#@     sproc_msg -info "METRIC | INTEGER INFO.NUM_JOBS        | $TEV(num_jobs)"
#@     sproc_msg -info "METRIC | INTEGER INFO.NUM_CORES       | $TEV(num_cores)"
#@     sproc_msg -info "METRIC | INTEGER INFO.NUM_CHILD_JOBS  | $TEV(num_child_jobs)"
#@     sproc_msg -info "METRIC | INTEGER INFO.NUM_CHILD_CORES | $TEV(num_child_cores)"
#@ 
#@     sproc_msg -info "METRIC | INTEGER INFO.WARNING | $_sproc_msg_count(warning)"
#@     sproc_msg -info "METRIC | INTEGER INFO.ISSUE   | $_sproc_msg_count(issue)"
#@     sproc_msg -info "METRIC | INTEGER INFO.NOTE    | $_sproc_msg_count(note)"
#@ 
#@     ## -------------------------------------
#@     ## Provide metric for job id
#@     ## -------------------------------------
#@ 
#@     set job_id NaM
#@ 
#@     if { [info exists env(LYNX_JOB)] } {
#@ 
#@       ## -------------------------------------
#@       ## If env(LYNX_JOB) exists (set in the rtm_job_cmd file),
#@       ## then the task being run is a distributed job.
#@       ## -------------------------------------
#@ 
#@       if { $SEV(job_app) == "lsf" } {
#@         if { [info exists env(LSB_JOBID)] } {
#@           set job_id $env(LSB_JOBID)
#@         }
#@       }
#@       if { $SEV(job_app) == "grd" } {
#@         if { [info exists env(JOB_ID)] } {
#@           set job_id $env(JOB_ID)
#@         }
#@       }
#@ 
#@       sproc_msg -info "METRIC | STRING INFO.JOB_ID | $job_id"
#@ 
#@     }
#@ 
#@     ## -------------------------------------
#@     ## Provide metric for memory usage
#@     ## -------------------------------------
#@ 
#@     set memory_used NaM
#@     set cputime_s NaM
#@ 
#@     switch $synopsys_program_name {
#@       pt_shell {
#@         if { [info exists SEV(pt_dmsa_slave)] } {
#@           ## -------------------------------------
#@           ## If running DMSA, report the max memory across the master and slaves.
#@           ## -------------------------------------
#@           remote_execute { set slave_mem_kb [mem] }
#@           get_distributed_variables { slave_mem_kb }
#@           set mem_kb_list [mem]
#@           foreach session [array names slave_mem_kb] {
#@             lappend mem_kb_list $slave_mem_kb($session)
#@           }
#@           set mem_kb [lindex [lsort -integer -decreasing $mem_kb_list] 0]
#@         } else {
#@           set mem_kb [mem]
#@         }
#@         set mem_b [expr $mem_kb * pow(2,10)]
#@         set mem_mb [expr int($mem_b / pow(2,20)) + 1]
#@         set memory_used $mem_mb
#@         set cputime_s [cputime]
#@       }
#@       dc_shell -
#@       icc_shell {
#@         set mem_kb [mem -all]
#@         set mem_b [expr $mem_kb * pow(2,10)]
#@         set mem_mb [expr int($mem_b / pow(2,20)) + 1]
#@         set memory_used $mem_mb
#@         set cputime_s [cputime]
#@       }
#@       icc2_shell -
#@       icc2_lm_shell -
#@       fm_shell {
#@         set mem_kb [mem]
#@         set mem_b [expr $mem_kb * pow(2,10)]
#@         set mem_mb [expr int($mem_b / pow(2,20)) + 1]
#@         set memory_used $mem_mb
#@         set cputime_s [cputime]
#@       }
#@       vcst {
#@         set mem_mb [get_resource_cost -tcl -mem]
#@         set memory_used $mem_mb
#@         set cputime_s [get_resource_cost -tcl -cpu]
#@       }
#@     }
#@ 
#@     if { $options(-mem_mb) >= 0 } {
#@       set memory_used $options(-mem_mb)
#@     }
#@ 
#@     sproc_msg -info "METRIC | INTEGER INFO.MEMORY_USED | $memory_used"
#@ 
#@     if { $SEV(aro_enable) && ($job_id != "NaM") && ($memory_used != "NaM") } {
#@ 
#@       set log_file [file normalize $SEV(log_file)]
#@       set file_part_org [file tail $log_file]
#@       set dir_part_org  [file dirname $log_file]
#@       set file_part_new .[file rootname $file_part_org].metrics.aro_mem
#@       set aro_mem_file $dir_part_org/$file_part_new
#@ 
#@       file delete -force $aro_mem_file
#@       set fid [open $aro_mem_file w]
#@       puts $fid "INFO.MEMORY_USED|INTEGER|$memory_used"
#@       close $fid
#@ 
#@       sproc_send_aro_mem -job_id $job_id -memory_used $memory_used
#@ 
#@     }
#@ 
#@     ## -------------------------------------
#@     ## Provide metric for license usage
#@     ## -------------------------------------
#@ 
#@     set license_list [list]
#@ 
#@     if { [info command list_licenses] == "list_licenses" } {
#@       redirect -var report {
#@         list_licenses
#@       }
#@       set lines [split $report "\n"]
#@       foreach line $lines {
#@         if { [regexp {^\s*$} $line] } {
#@           continue
#@         }
#@         if { [regexp {^\s+[\w\-]+} $line] } {
#@           lappend license_list [lindex $line 0]
#@         }
#@       }
#@     } elseif { $synopsys_program_name == "tmax_tcl" } {
#@       redirect -var report {
#@         report_licenses
#@       }
#@       set lines [split $report "\n"]
#@       foreach line $lines {
#@         if { [regexp {^\s*$} $line] } {
#@           continue
#@         } else {
#@           lappend license_list [lindex $line 0]
#@         }
#@       }
#@     }
#@ 
#@     if { [llength $license_list] == 0 } {
#@       set license_list [list LicenseDataUnavailable]
#@     }
#@ 
#@     sproc_msg -info "METRIC | STRING INFO.LICENSES | $license_list"
#@ 
#@     if { [info exists SEV(metrics_enable_forward)] } {
#@       sproc_msg -info "METRIC | BOOLEAN INFO.METRICS_ENABLE_FORWARD | $SEV(metrics_enable_forward)"
#@     } else {
#@       sproc_msg -info "METRIC | BOOLEAN INFO.METRICS_ENABLE_FORWARD | 0"
#@     }
#@ 
#@     ## -------------------------------------
#@     ## Flow Summary - Resource
#@     ## -------------------------------------
#@ 
#@     ## -------------------------------------
#@     ## Define required attributes
#@     ## -------------------------------------
#@ 
#@     set attributes [list]
#@     lappend attributes [list STEP   $SEV(step)]
#@     lappend attributes [list TASK   $SEV(task)]
#@     lappend attributes [list DST    $SEV(dst)]
#@     lappend attributes [list DESIGN $SVAR(design_name)]
#@     if { [info exists SEV(flow_order)] } {
#@       lappend attributes [list FLOW_ORDER $SEV(flow_order)]
#@     } else {
#@       lappend attributes [list FLOW_ORDER -1]
#@     }
#@     lappend attributes [list TYPE FLOW_SUMMARY]
#@  ## -------------------------------------
#@     ## Start output
#@     ## -------------------------------------
#@ 
#@     set fs_output [list]
#@ 
#@     lappend fs_output "{"
#@ 
#@       ## -------------------------------------
#@       ## Process attributes
#@       ## -------------------------------------
#@ 
#@       foreach attribute $attributes {
#@         set name  [lindex $attribute 0]
#@         set value [lindex $attribute 1]
#@         lappend fs_output "\"$name\": \"$value\""
#@       }
#@       lappend fs_output "\"flow_summary\": \["
#@ 
#@       ## -------------------------------------
#@       ## All content below here is optional
#@       ## -------------------------------------
#@ 
#@       set fs_output [sproc_qv_flow_summary -o $fs_output -name "Host"  -value [exec uname -n]]
#@ 
#@       set fs_output [sproc_qv_flow_summary -o $fs_output -name "Tool"  -value $synopsys_program_name]
#@ 
#@       set fs_output [sproc_qv_flow_summary -o $fs_output -name "Cores" -value $TEV(num_cores)]
#@ 
#@       set wall_time [expr $SNPS_time_stop - $SNPS_time_start]
#@       set fs_output [sproc_qv_flow_summary -o $fs_output -name "Wall Time"  -value $wall_time]
#@ 
#@       if { $cputime_s == "NaM" } {
#@         set cputime_s NA
#@         set cputime_e NA
#@       } else {
#@         set cputime_s [expr int($cputime_s)]
#@         if { ($cputime_s >= 10) && ($wall_time >= 10) } {
#@           set total_wall_time [expr $TEV(num_cores) * $wall_time]
#@           set cputime_e [format "%.2f" [expr double($cputime_s) / double($total_wall_time) * 100.0]]
#@         } else {
#@           set cputime_e NA
#@         }
#@       }
#@       set fs_output [sproc_qv_flow_summary -o $fs_output -name "CPU Time"       -value $cputime_s]
#@       set fs_output [sproc_qv_flow_summary -o $fs_output -name "CPU Efficiency" -value $cputime_e]
#@ 
#@       if { $memory_used == "NaM" } {
#@         set value NA
#@       } else {
#@         set value $memory_used
#@       }
#@       set fs_output [sproc_qv_flow_summary -o $fs_output -name "Mem"   -value $value]
#@ 
#@       ## -------------------------------------
#@       ## Complete output & create file
#@       ## -------------------------------------
#@ 
#@       lappend fs_output "\]"
#@ 
#@     lappend fs_output "}"
#@ 
#@     set fs_output [sproc_qv_add_commas -lines $fs_output]
#@     set fs_output [join $fs_output "\n"]
#@ 
#@     set fid [open $SEV(rpt_dir)/.$SEV(block_name).$SEV(step).$SEV(task).$SEV(dst).resource_summary-flow_summary.qor w]
#@     puts $fid $fs_output
#@     close $fid
#@ 
#@   }
#@ 
#@   set xxx2 [clock seconds]
#@   set xxx [expr $xxx2 - $xxx1]
#@   sproc_msg -info "METRICS sproc_metric_system took $xxx seconds"
#@ 
#@   sproc_pinfo -mode stop
#@ }
#@ 
#@ define_proc_attributes sproc_metric_system   -info "Used to generate metrics related to task execution."   -define_args {
#@   {-start_of_script "Indicates routine is being called at start of script execution." "" boolean optional}
#@   {-end_of_script "Indicates routine is being called at end of script execution." "" boolean optional}
#@   {-mem_mb "The amount of memory used by the task. (Integer number of MBs)" AnInt int optional}
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_metric_system:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_metric_system { args } {
#@ 
#@   sproc_pinfo -mode start
#@ 
#@   global env SEV SVAR TEV DEV
#@   global sh_product_version
#@   global synopsys_program_name
#@   global _sproc_msg_count
#@   global SNPS_time_start SNPS_time_stop
#@ 
#@   set xxx1 [clock seconds]
#@ 
#@   set options(-start_of_script) 0
#@   set options(-end_of_script) 0
#@   set options(-mem_mb) -1
#@   parse_proc_arguments -args $args options
#@ 
#@   if { $options(-start_of_script) } {
#@ 
#@     sproc_msg -info "METRIC | STRING SYS.TASK           | $SEV(task)"
#@     sproc_msg -info "METRIC | STRING SYS.PROJECT_NAME   | $SEV(project_name)"
#@     sproc_msg -info "METRIC | STRING SYS.PROJECT_DIR    | $SEV(project_dir)"
#@     sproc_msg -info "METRIC | STRING SYS.TECHLIB_NAME   | $SEV(techlib_name)"
#@     sproc_msg -info "METRIC | STRING SYS.TECHLIB_DIR    | $SEV(techlib_dir)"
#@     sproc_msg -info "METRIC | STRING SYS.WORKAREA_DIR   | $SEV(workarea_dir)"
#@     sproc_msg -info "METRIC | STRING SYS.BLOCK_DIR      | $SEV(block_dir)"
#@     sproc_msg -info "METRIC | STRING SYS.USER           | [exec whoami]"
#@     sproc_msg -info "METRIC | STRING SYS.BLOCK          | $SVAR(design_name)"
#@     sproc_msg -info "METRIC | STRING SYS.STEP           | $SEV(step)"
#@     sproc_msg -info "METRIC | STRING SYS.SRC            | $SEV(src)"
#@     sproc_msg -info "METRIC | STRING SYS.DST            | $SEV(dst)"
#@     sproc_msg -info "METRIC | STRING SYS.LOG            | [file normalize $SEV(log_file)]"
#@     sproc_msg -info "METRIC | STRING SYS.SCRIPT_NAME    | [file normalize $SEV(script_file)]"
#@     sproc_msg -info "METRIC | STRING SYS.SCRIPT_VERSION | [sproc_script_version]"
#@ 
#@     set script_type unknown
#@     if { [regexp "/scripts_global/" $SEV(script_file)] } {
#@       set script_type global
#@     }
#@     if { [regexp "/scripts_global/$SEV(techlib_name)/" $SEV(script_file)] } {
#@       set script_type techlib
#@     }
#@     if { [regexp "/scripts_block/" $SEV(script_file)] } {
#@       set script_type block
#@     }
#@     sproc_msg -info "METRIC | STRING SYS.SCRIPT_TYPE    | $script_type"
#@ 
#@     sproc_msg -info "METRIC | STRING SYS.MACHINE        | [exec uname -n]"
#@     sproc_msg -info "METRIC | STRING SYS.TOOL_NAME      | $synopsys_program_name"
#@ 
#@     if { ![info exists sh_product_version] || $sh_product_version == "" } {
#@       set sh_product_version NaM
#@     }
#@     sproc_msg -info "METRIC | STRING SYS.TOOL_VERSION   | $sh_product_version"
#@ 
#@     if { $SEV(dont_run) || $SEV(dont_exit) } {
#@       if { $SEV(analysis_task) } {
#@         sproc_msg -info "METRIC | STRING SYS.TASK_TYPE      | ANALYZE_INTERACTIVE"
#@       } else {
#@         sproc_msg -info "METRIC | STRING SYS.TASK_TYPE      | OPTIMIZE_INTERACTIVE"
#@       }
#@     } else {
#@       if { $SEV(analysis_task) } {
#@         sproc_msg -info "METRIC | STRING SYS.TASK_TYPE      | ANALYZE"
#@       } else {
#@         sproc_msg -info "METRIC | STRING SYS.TASK_TYPE      | OPTIMIZE"
#@       }
#@     }
#@ 
#@     sproc_msg -info "METRIC | TAG SYS.TAG_01 | $SVAR(tag_01)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_02 | $SVAR(tag_02)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_03 | $SVAR(tag_03)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_04 | $SVAR(tag_04)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_05 | $SVAR(tag_05)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_06 | $SVAR(tag_06)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_07 | $SVAR(tag_07)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_08 | $SVAR(tag_08)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_09 | $SVAR(tag_09)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_10 | $SVAR(tag_10)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_11 | $SVAR(tag_11)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_12 | $SVAR(tag_12)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_13 | $SVAR(tag_13)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_14 | $SVAR(tag_14)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_15 | $SVAR(tag_15)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_16 | $SVAR(tag_16)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_17 | $SVAR(tag_17)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_18 | $SVAR(tag_18)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_19 | $SVAR(tag_19)"
#@     sproc_msg -info "METRIC | TAG SYS.TAG_20 | RTM_PRESENT !! [info exists env(LYNX_RTM_PRESENT)]" 
#@ 
#@     sproc_metric_tags
#@ 
#@     if { [info exists SEV(flow_order)] } {
#@       sproc_msg -info "METRIC | INTEGER SYS.FLOW_ORDER | $SEV(flow_order)"
#@     }
#@ 
#@   }
#@ 
#@   if { $options(-end_of_script) } {
#@ 
#@     if { ![info exists TEV(num_jobs)] }        { set TEV(num_jobs) 1 }
#@     if { ![info exists TEV(num_cores)] }       { set TEV(num_cores) 1 }
#@     if { ![info exists TEV(num_child_jobs)] }  { set TEV(num_child_jobs) 1 }
#@     if { ![info exists TEV(num_child_cores)] } { set TEV(num_child_cores) 1 }
#@ 
#@     sproc_msg -info "METRIC | INTEGER INFO.NUM_JOBS        | $TEV(num_jobs)"
#@     sproc_msg -info "METRIC | INTEGER INFO.NUM_CORES       | $TEV(num_cores)"
#@     sproc_msg -info "METRIC | INTEGER INFO.NUM_CHILD_JOBS  | $TEV(num_child_jobs)"
#@     sproc_msg -info "METRIC | INTEGER INFO.NUM_CHILD_CORES | $TEV(num_child_cores)"
#@ 
#@     sproc_msg -info "METRIC | INTEGER INFO.WARNING | $_sproc_msg_count(warning)"
#@     sproc_msg -info "METRIC | INTEGER INFO.ISSUE   | $_sproc_msg_count(issue)"
#@     sproc_msg -info "METRIC | INTEGER INFO.NOTE    | $_sproc_msg_count(note)"
#@ 
#@     ## -------------------------------------
#@     ## Provide metric for job id
#@     ## -------------------------------------
#@ 
#@     set job_id NaM
#@ 
#@     if { [info exists env(LYNX_JOB)] } {
#@ 
#@       ## -------------------------------------
#@       ## If env(LYNX_JOB) exists (set in the rtm_job_cmd file),
#@       ## then the task being run is a distributed job.
#@       ## -------------------------------------
#@ 
#@       if { $SEV(job_app) == "lsf" } {
#@         if { [info exists env(LSB_JOBID)] } {
#@           set job_id $env(LSB_JOBID)
#@         }
#@       }
#@       if { $SEV(job_app) == "grd" } {
#@         if { [info exists env(JOB_ID)] } {
#@           set job_id $env(JOB_ID)
#@         }
#@       }
#@ 
#@       sproc_msg -info "METRIC | STRING INFO.JOB_ID | $job_id"
#@ 
#@     }
#@ 
#@     ## -------------------------------------
#@     ## Provide metric for memory usage
#@     ## -------------------------------------
#@ 
#@     set memory_used NaM
#@     set cputime_s NaM
#@ 
#@     switch $synopsys_program_name {
#@       pt_shell {
#@         if { [info exists SEV(pt_dmsa_slave)] } {
#@           ## -------------------------------------
#@           ## If running DMSA, report the max memory across the master and slaves.
#@           ## -------------------------------------
#@           remote_execute { set slave_mem_kb [mem] }
#@           get_distributed_variables { slave_mem_kb }
#@           set mem_kb_list [mem]
#@           foreach session [array names slave_mem_kb] {
#@             lappend mem_kb_list $slave_mem_kb($session)
#@           }
#@           set mem_kb [lindex [lsort -integer -decreasing $mem_kb_list] 0]
#@         } else {
#@           set mem_kb [mem]
#@         }
#@         set mem_b [expr $mem_kb * pow(2,10)]
#@         set mem_mb [expr int($mem_b / pow(2,20)) + 1]
#@         set memory_used $mem_mb
#@         set cputime_s [cputime]
#@       }
#@       dc_shell -
#@       icc_shell {
#@         set mem_kb [mem -all]
#@         set mem_b [expr $mem_kb * pow(2,10)]
#@         set mem_mb [expr int($mem_b / pow(2,20)) + 1]
#@         set memory_used $mem_mb
#@         set cputime_s [cputime]
#@       }
#@       icc2_shell -
#@       icc2_lm_shell -
#@       fm_shell {
#@         set mem_kb [mem]
#@         set mem_b [expr $mem_kb * pow(2,10)]
#@         set mem_mb [expr int($mem_b / pow(2,20)) + 1]
#@         set memory_used $mem_mb
#@         set cputime_s [cputime]
#@       }
#@       vcst {
#@         set mem_mb [get_resource_cost -tcl -mem]
#@         set memory_used $mem_mb
#@         set cputime_s [get_resource_cost -tcl -cpu]
#@       }
#@     }
#@ 
#@     if { $options(-mem_mb) >= 0 } {
#@       set memory_used $options(-mem_mb)
#@     }
#@ 
#@     sproc_msg -info "METRIC | INTEGER INFO.MEMORY_USED | $memory_used"
#@ 
#@     if { $SEV(aro_enable) && ($job_id != "NaM") && ($memory_used != "NaM") } {
#@ 
#@       set log_file [file normalize $SEV(log_file)]
#@       set file_part_org [file tail $log_file]
#@       set dir_part_org  [file dirname $log_file]
#@       set file_part_new .[file rootname $file_part_org].metrics.aro_mem
#@       set aro_mem_file $dir_part_org/$file_part_new
#@ 
#@       file delete -force $aro_mem_file
#@       set fid [open $aro_mem_file w]
#@       puts $fid "INFO.MEMORY_USED|INTEGER|$memory_used"
#@       close $fid
#@ 
#@       sproc_send_aro_mem -job_id $job_id -memory_used $memory_used
#@ 
#@     }
#@ 
#@     ## -------------------------------------
#@     ## Provide metric for license usage
#@     ## -------------------------------------
#@ 
#@     set license_list [list]
#@ 
#@     if { [info command list_licenses] == "list_licenses" } {
#@       redirect -var report {
#@         list_licenses
#@       }
#@       set lines [split $report "\n"]
#@       foreach line $lines {
#@         if { [regexp {^\s*$} $line] } {
#@           continue
#@         }
#@         if { [regexp {^\s+[\w\-]+} $line] } {
#@           lappend license_list [lindex $line 0]
#@         }
#@       }
#@     } elseif { $synopsys_program_name == "tmax_tcl" } {
#@       redirect -var report {
#@         report_licenses
#@       }
#@       set lines [split $report "\n"]
#@       foreach line $lines {
#@         if { [regexp {^\s*$} $line] } {
#@           continue
#@         } else {
#@           lappend license_list [lindex $line 0]
#@         }
#@       }
#@     }
#@ 
#@     if { [llength $license_list] == 0 } {
#@       set license_list [list LicenseDataUnavailable]
#@     }
#@ 
#@     sproc_msg -info "METRIC | STRING INFO.LICENSES | $license_list"
#@ 
#@     if { [info exists SEV(metrics_enable_forward)] } {
#@       sproc_msg -info "METRIC | BOOLEAN INFO.METRICS_ENABLE_FORWARD | $SEV(metrics_enable_forward)"
#@     } else {
#@       sproc_msg -info "METRIC | BOOLEAN INFO.METRICS_ENABLE_FORWARD | 0"
#@     }
#@ 
#@     ## -------------------------------------
#@     ## Flow Summary - Resource
#@     ## -------------------------------------
#@ 
#@     ## -------------------------------------
#@     ## Define required attributes
#@     ## -------------------------------------
#@ 
#@     set attributes [list]
#@     lappend attributes [list STEP   $SEV(step)]
#@     lappend attributes [list TASK   $SEV(task)]
#@     lappend attributes [list DST    $SEV(dst)]
#@     lappend attributes [list DESIGN $SVAR(design_name)]
#@     if { [info exists SEV(flow_order)] } {
#@       lappend attributes [list FLOW_ORDER $SEV(flow_order)]
#@     } else {
#@       lappend attributes [list FLOW_ORDER -1]
#@     }
#@     lappend attributes [list TYPE FLOW_SUMMARY]
#@ 
#@     ## -------------------------------------
#@     ## Start output
#@     ## -------------------------------------
#@ 
#@     set fs_output [list]
#@ 
#@     lappend fs_output "{"
#@ 
#@       ## -------------------------------------
#@       ## Process attributes
#@       ## -------------------------------------
#@ 
#@       foreach attribute $attributes {
#@         set name  [lindex $attribute 0]
#@         set value [lindex $attribute 1]
#@         lappend fs_output "\"$name\": \"$value\""
#@       }
#@       lappend fs_output "\"flow_summary\": \["
#@ 
#@       ## -------------------------------------
#@       ## All content below here is optional
#@       ## -------------------------------------
#@ 
#@       set fs_output [sproc_qv_flow_summary -o $fs_output -name "Host"  -value [exec uname -n]]
#@ 
#@       set fs_output [sproc_qv_flow_summary -o $fs_output -name "Tool"  -value $synopsys_program_name]
#@ 
#@       set fs_output [sproc_qv_flow_summary -o $fs_output -name "Cores" -value $TEV(num_cores)]
#@ 
#@       set wall_time [expr $SNPS_time_stop - $SNPS_time_start]
#@       set fs_output [sproc_qv_flow_summary -o $fs_output -name "Wall Time"  -value $wall_time]
#@ 
#@       if { $cputime_s == "NaM" } {
#@         set cputime_s NA
#@         set cputime_e NA
#@       } else {
#@         set cputime_s [expr int($cputime_s)]
#@         if { ($cputime_s >= 10) && ($wall_time >= 10) } {
#@           set total_wall_time [expr $TEV(num_cores) * $wall_time]
#@           set cputime_e [format "%.2f" [expr double($cputime_s) / double($total_wall_time) * 100.0]]
#@         } else {
#@           set cputime_e NA
#@         }
#@       }
#@       set fs_output [sproc_qv_flow_summary -o $fs_output -name "CPU Time"       -value $cputime_s]
#@       set fs_output [sproc_qv_flow_summary -o $fs_output -name "CPU Efficiency" -value $cputime_e]
#@ 
#@       if { $memory_used == "NaM" } {
#@         set value NA
#@       } else {
#@         set value $memory_used
#@       }
#@       set fs_output [sproc_qv_flow_summary -o $fs_output -name "Mem"   -value $value]
#@ 
#@       ## -------------------------------------
#@       ## Complete output & create file
#@       ## -------------------------------------
#@ 
#@       lappend fs_output "\]"
#@ 
#@     lappend fs_output "}"
#@ 
#@     set fs_output [sproc_qv_add_commas -lines $fs_output]
#@     set fs_output [join $fs_output "\n"]
#@ 
#@     set fid [open $SEV(rpt_dir)/.$SEV(block_name).$SEV(step).$SEV(task).$SEV(dst).resource_summary-flow_summary.qor w]
#@     puts $fid $fs_output
#@     close $fid
#@ 
#@   }
#@ 
#@   set xxx2 [clock seconds]
#@   set xxx [expr $xxx2 - $xxx1]
#@   sproc_msg -info "METRICS sproc_metric_system took $xxx seconds"
#@ 
#@   sproc_pinfo -mode stop
#@ }
#@ 
#@ define_proc_attributes sproc_metric_system   -info "Used to generate metrics related to task execution."   -define_args {
#@   {-start_of_script "Indicates routine is being called at start of script execution." "" boolean optional}
#@   {-end_of_script "Indicates routine is being called at end of script execution." "" boolean optional}
#@   {-mem_mb "The amount of memory used by the task. (Integer number of MBs)" AnInt int optional}
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_metric_time:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_metric_time { args } {
#@ 
#@   sproc_pinfo -mode start
#@ 
#@   global SEV
#@   global SNPS_time_start SNPS_time_stop SNPS_rpt_time_elapsed
#@ 
#@   set options(-start) 0
#@   set options(-stop) 0
#@ 
#@   parse_proc_arguments -args $args options
#@ 
#@   if { $options(-start) } {
#@     ## This code for GMT support is not for this release.
#@     ## set gmt_date [clock format [clock seconds] -format "%a %b %d %H:%M:%S %Y" -gmt 1]
#@     ## set gmt_seconds [clock scan $gmt_date -gmt 1]
#@     ## sproc_msg -info "METRIC | TIMESTAMP SYS.START_TIME  | $gmt_seconds"
#@     sproc_msg -info "METRIC | TIMESTAMP SYS.START_TIME  | [clock seconds]"
#@ 
#@     sproc_msg -info "SYS.START_TIME | [date]"
#@     set SNPS_time_start [clock seconds]
#@   }
#@ 
#@   if { $options(-stop) } {
#@     ## This code for GMT support is not for this release.
#@     ## set gmt_date [clock format [clock seconds] -format "%a %b %d %H:%M:%S %Y" -gmt 1]
#@     ## set gmt_seconds [clock scan $gmt_date -gmt 1]
#@     ## sproc_msg -info "METRIC | TIMESTAMP SYS.STOP_TIME   | $gmt_seconds"
#@     sproc_msg -info "METRIC | TIMESTAMP SYS.STOP_TIME   | [clock seconds]"
#@ 
#@     sproc_msg -info "SYS.STOP_TIME | [date]"
#@     set SNPS_time_stop [clock seconds]
#@     set SNPS_time_total_seconds [expr $SNPS_time_stop - $SNPS_time_start]
#@     set dhms [sproc_metric_time_elapsed -start $SNPS_time_start -stop $SNPS_time_stop]
#@     sproc_msg -info "METRIC | TIME INFO.ELAPSED_TIME.TOTAL | $SNPS_time_total_seconds"
#@     sproc_msg -info "INFO.ELAPSED_TIME.TOTAL | $dhms"
#@ 
#@     if { [info exists SNPS_rpt_time_elapsed] } {
#@       set SNPS_time_stop_minus_reports [expr $SNPS_time_stop - $SNPS_rpt_time_elapsed]
#@       set SNPS_time_total_minus_reports_seconds [ expr $SNPS_time_stop_minus_reports - $SNPS_time_start]
#@       set dhms [sproc_metric_time_elapsed -start $SNPS_time_start -stop $SNPS_time_stop_minus_reports]
#@       sproc_msg -info "METRIC | TIME INFO.ELAPSED_TIME.TOTAL_MINUS_REPORT | $SNPS_time_total_minus_reports_seconds"
#@       sproc_msg -info "INFO.ELAPSED_TIME.TOTAL_MINUS_REPORT | $dhms"
#@     }
#@   }
#@ 
#@   sproc_pinfo -mode stop
#@ }
#@ 
#@ define_proc_attributes sproc_metric_time   -info "Used to generate metrics related to duration of task execution."   -define_args {
#@   {-start "Indicates routine is being called to provide start time info.." "" boolean optional}
#@   {-stop "Indicates routine is being called to provide stop time info." "" boolean optional}
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_metric_time:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_metric_time { args } {
#@ 
#@   sproc_pinfo -mode start
#@ 
#@   global SEV
#@   global SNPS_time_start SNPS_time_stop SNPS_rpt_time_elapsed
#@ 
#@   set options(-start) 0
#@   set options(-stop) 0
#@ 
#@   parse_proc_arguments -args $args options
#@ 
#@   if { $options(-start) } {
#@     ## This code for GMT support is not for this release.
#@     ## set gmt_date [clock format [clock seconds] -format "%a %b %d %H:%M:%S %Y" -gmt 1]
#@     ## set gmt_seconds [clock scan $gmt_date -gmt 1]
#@     ## sproc_msg -info "METRIC | TIMESTAMP SYS.START_TIME  | $gmt_seconds"
#@     sproc_msg -info "METRIC | TIMESTAMP SYS.START_TIME  | [clock seconds]"
#@ 
#@     sproc_msg -info "SYS.START_TIME | [date]"
#@     set SNPS_time_start [clock seconds]
#@   }
#@ 
#@   if { $options(-stop) } {
#@     ## This code for GMT support is not for this release.
#@     ## set gmt_date [clock format [clock seconds] -format "%a %b %d %H:%M:%S %Y" -gmt 1]
#@     ## set gmt_seconds [clock scan $gmt_date -gmt 1]
#@     ## sproc_msg -info "METRIC | TIMESTAMP SYS.STOP_TIME   | $gmt_seconds"
#@     sproc_msg -info "METRIC | TIMESTAMP SYS.STOP_TIME   | [clock seconds]"
#@ 
#@     sproc_msg -info "SYS.STOP_TIME | [date]"
#@     set SNPS_time_stop [clock seconds]
#@     set SNPS_time_total_seconds [expr $SNPS_time_stop - $SNPS_time_start]
#@     set dhms [sproc_metric_time_elapsed -start $SNPS_time_start -stop $SNPS_time_stop]
#@     sproc_msg -info "METRIC | TIME INFO.ELAPSED_TIME.TOTAL | $SNPS_time_total_seconds"
#@     sproc_msg -info "INFO.ELAPSED_TIME.TOTAL | $dhms"
#@ 
#@     if { [info exists SNPS_rpt_time_elapsed] } {
#@       set SNPS_time_stop_minus_reports [expr $SNPS_time_stop - $SNPS_rpt_time_elapsed]
#@       set SNPS_time_total_minus_reports_seconds [ expr $SNPS_time_stop_minus_reports - $SNPS_time_start]
#@       set dhms [sproc_metric_time_elapsed -start $SNPS_time_start -stop $SNPS_time_stop_minus_reports]
#@       sproc_msg -info "METRIC | TIME INFO.ELAPSED_TIME.TOTAL_MINUS_REPORT | $SNPS_time_total_minus_reports_seconds"
#@       sproc_msg -info "INFO.ELAPSED_TIME.TOTAL_MINUS_REPORT | $dhms"
#@     }
#@   }
#@ 
#@   sproc_pinfo -mode stop
#@ }
#@ 
#@ define_proc_attributes sproc_metric_time   -info "Used to generate metrics related to duration of task execution."   -define_args {
#@   {-start "Indicates routine is being called to provide start time info.." "" boolean optional}
#@   {-stop "Indicates routine is being called to provide stop time info." "" boolean optional}
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_metric_normalize:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_metric_normalize { args } {
#@ 
#@   sproc_pinfo -mode start
#@ 
#@   ## table contains the multiplier for converting from supplied unit to normalized default
#@   set default_power_unit mw
#@   set normalize_lut(w)    1e+3
#@   set normalize_lut(mw)   1e+0
#@   set normalize_lut(uw)   1e-3
#@   set normalize_lut(nw)   1e-6
#@   set normalize_lut(pw)   1e-9
#@ 
#@   set default_time_unit ps
#@   set normalize_lut(s)    1e+12
#@   set normalize_lut(ns)   1e+3
#@   set normalize_lut(ps)   1e+0
#@ 
#@   set default_area_unit um
#@   set normalize_lut(nm)   1e-3
#@   set normalize_lut(um)   1e+0
#@   set normalize_lut(m)    1e+6
#@ 
#@   set options(-value) ""
#@   set options(-current_unit) ""
#@ 
#@   parse_proc_arguments -args $args options
#@ 
#@   set val $options(-value)
#@ 
#@   if { $val=="NaM" } {
#@     sproc_msg -info "Passing through special case value $val"
#@     sproc_pinfo -mode stop
#@     return $val
#@   }
#@ 
#@   if { ![scan $val "%f" match] } {
#@     sproc_msg -error "sproc_metric_normalize cannot process value $val"
#@     sproc_pinfo -mode stop
#@     return "NaM"
#@   }
#@ 
#@   if { $options(-current_unit) != "" } {
#@     set cur_unit [string tolower $options(-current_unit)]
#@     if { [array names normalize_lut -exact $cur_unit] != "" } {
#@       set norm_scalar $normalize_lut($cur_unit)
#@     } else {
#@       sproc_msg -error "sproc_metric_normalize not configured to convert $cur_unit"
#@       sproc_pinfo -mode stop
#@       return "NaM"
#@     }
#@   }
#@ 
#@   set val_out [expr $val * $norm_scalar]
#@ 
#@   sproc_pinfo -mode stop
#@ 
#@   return $val_out
#@ 
#@ }
#@ 
#@ define_proc_attributes sproc_metric_normalize   -info "Used to convert metric numbers from one unit standard to another."   -define_args {
#@   {-value "value to convert" decimal string required}
#@   {-current_unit "Units of current value" AString string required}
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_metric_clean_string:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_metric_clean_string { args } {
#@ 
#@   sproc_pinfo -mode start
#@ 
#@   set options(-string) ""
#@   parse_proc_arguments -args $args options
#@ 
#@   set string_before $options(-string)
#@ 
#@   ## Only allow alphanumric and underscore characters
#@   set string_after [regsub -all { [^\w\.] } $string_before {_}]
#@ 
#@   if {![string match $string_after $string_before]} {
#@     sproc_msg -warn "sproc_metric_clean_string: String <$string_before> changed to <$string_after>"
#@   }
#@ 
#@   sproc_pinfo -mode stop
#@ 
#@   return $string_after
#@ }
#@ 
#@ define_proc_attributes sproc_metric_clean_string   -info "Removes characters not supported for metric strings."   -define_args {
#@   {-string  "The string that needs cleaning." AString string required}
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_metric_time_elapsed:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_metric_time_elapsed { args } {
#@ 
#@   sproc_pinfo -mode start
#@ 
#@   set options(-start) 0
#@   set options(-stop) 0
#@   parse_proc_arguments -args $args options
#@ 
#@   set seconds_in_day [expr 24 * 3600.0]
#@   set total_seconds [expr $options(-stop) - $options(-start)]
#@   set num_days_f [expr floor($total_seconds / $seconds_in_day)]
#@   set partial_day_f [expr ($total_seconds / $seconds_in_day) - $num_days_f]
#@   set num_days [expr int($num_days_f)]
#@   set partial_day [expr int($partial_day_f * $seconds_in_day)]
#@   set hms [clock format $partial_day -format %T -gmt true]
#@   set dhms [format "%02d:%s" $num_days $hms]
#@ 
#@   sproc_pinfo -mode stop
#@   return "$dhms"
#@ }
#@ 
#@ define_proc_attributes sproc_metric_time_elapsed   -info "Used to generate metrics related to duration of task execution."   -define_args {
#@   {-start "Indicates start time in seconds." "" int required}
#@   {-stop  "Indicates stop time in seconds." "" int required}
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_metric_time_elapsed:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_metric_time_elapsed { args } {
#@ 
#@   sproc_pinfo -mode start
#@ 
#@   set options(-start) 0
#@   set options(-stop) 0
#@   parse_proc_arguments -args $args options
#@ 
#@   set seconds_in_day [expr 24 * 3600.0]
#@   set total_seconds [expr $options(-stop) - $options(-start)]
#@   set num_days_f [expr floor($total_seconds / $seconds_in_day)]
#@   set partial_day_f [expr ($total_seconds / $seconds_in_day) - $num_days_f]
#@   set num_days [expr int($num_days_f)]
#@   set partial_day [expr int($partial_day_f * $seconds_in_day)]
#@   set hms [clock format $partial_day -format %T -gmt true]
#@   set dhms [format "%02d:%s" $num_days $hms]
#@ 
#@   sproc_pinfo -mode stop
#@   return "$dhms"
#@ }
#@ 
#@ define_proc_attributes sproc_metric_time_elapsed   -info "Used to generate metrics related to duration of task execution."   -define_args {
#@   {-start "Indicates start time in seconds." "" int required}
#@   {-stop  "Indicates stop time in seconds." "" int required}
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_early_complete:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_early_complete  { args } {
#@ 
#@   sproc_pinfo -mode start
#@ 
#@   global SEV SVAR
#@   global synopsys_program_name
#@ 
#@   set options(-suppress) 0
#@   parse_proc_arguments -args $args options
#@ 
#@   if { $SVAR(misc,early_complete_enable) && ( $options(-suppress) == 0 ) } {
#@ 
#@     sproc_msg -warning "Early complete enabled."
#@ 
#@     set fname [file rootname $SEV(log_file)].early
#@     set fid [open $fname w]
#@     puts $fid "Early complete at [date]"
#@     close $fid
#@ 
#@   } else {
#@ 
#@     sproc_msg -warning "Early complete disabled."
#@ 
#@   }
#@ 
#@   sproc_pinfo -mode stop
#@ 
#@ }
#@ 
#@ define_proc_attributes sproc_early_complete    -info "Procedure to signal early completion of task to RTM."   -define_args {
#@   {-suppress      "Optionally disable early complete (0 enable, 1 disable)." AnInt int optional}
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_early_complete:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_early_complete  { args } {
#@ 
#@   sproc_pinfo -mode start
#@ 
#@   global SEV SVAR
#@   global synopsys_program_name
#@ 
#@   set options(-suppress) 0
#@   parse_proc_arguments -args $args options
#@ 
#@   if { $SVAR(misc,early_complete_enable) && ( $options(-suppress) == 0 ) } {
#@ 
#@     sproc_msg -warning "Early complete enabled."
#@ 
#@     set fname [file rootname $SEV(log_file)].early
#@     set fid [open $fname w]
#@     puts $fid "Early complete at [date]"
#@     close $fid
#@ 
#@   } else {
#@ 
#@     sproc_msg -warning "Early complete disabled."
#@ 
#@   }
#@ 
#@   sproc_pinfo -mode stop
#@ 
#@ }
#@ 
#@ define_proc_attributes sproc_early_complete    -info "Procedure to signal early completion of task to RTM."   -define_args {
#@   {-suppress      "Optionally disable early complete (0 enable, 1 disable)." AnInt int optional}
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_pt_report_qor:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_pt_report_qor { args } {
#@ 
#@   global env SEV SVAR TEV
#@   global synopsys_program_name
#@   global sh_product_version
#@   global sh_dev_null
#@   global pt_shell_mode
#@ 
#@   ## -------------------------------------
#@   ## Process arguments
#@   ## -------------------------------------
#@ 
#@   set options(-scenario) [list]
#@   parse_proc_arguments -args $args options
#@ 
#@   ## -------------------------------------
#@   ## Basic error checking
#@   ## -------------------------------------
#@ 
#@   if { $synopsys_program_name != "pt_shell" } {
#@     puts "Error: This script only functions properly in PrimeTime."
#@     return 0
#@   }
#@ 
#@   switch $pt_shell_mode {
#@     primetime {
#@       if { [llength $options(-scenario)] != 1 } {
#@         puts "Error: A single scenario must be specified."
#@         return 0
#@       }
#@     }
#@     primetime_slave {
#@       if { [llength $options(-scenario)] != 1 } {
#@         puts "Error: A single scenario must be specified."
#@         return 0
#@       }
#@       if { $options(-scenario) != [current_scenario] } {
#@         puts "Error: Slave session does not match selected scenario."
#@         return 0
#@       }
#@     }
#@     primetime_master {
#@       puts "Error: This command not implemented for PT DMSA Masters."
#@       return 0
#@     }
#@   }
#@ 
#@   catch { set design [current_design] } result
#@   if { $design == "" } {
#@     return 0
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Variables to configure this procedure.
#@   ## -------------------------------------
#@ 
#@   set max_path_count 100000
#@ 
#@   ## -------------------------------------
#@   ## Print banner
#@   ## -------------------------------------
#@ 
#@   puts "## -------------------------------------"
#@   puts "## Report : Lynx Design System version of 'report_qor' for Primetime"
#@   puts "## Design : [get_object_name $design]"
#@   puts "## Scenario(s):"
#@   foreach scenario $options(-scenario) {
#@     puts "##   $scenario"
#@   }
#@   puts "## Version: $sh_product_version"
#@   puts "## Date   : [date]"
#@   puts "## -------------------------------------"
#@   puts ""
#@ 
#@   ## -------------------------------------
#@   ## Gather data for report. (per path_group)
#@   ## -------------------------------------
#@ 
#@   set path_group_name_list [list]
#@ 
#@   foreach_in_collection path_group_obj [get_path_groups] {
#@ 
#@     set path_group_name [get_object_name $path_group_obj]
#@ 
#@     set timing_path_max_worst [get_timing_paths -group $path_group_obj -delay_type max]
#@ 
#@     set num_of_paths [sizeof_collection $timing_path_max_worst]
#@ 
#@     if { $num_of_paths == 0 } {
#@ 
#@       continue
#@ 
#@     } else {
#@ 
#@       lappend path_group_name_list $path_group_name
#@ 
#@       ## -------------------------------------
#@       ## Max info (per path_group)
#@       ## -------------------------------------
#@ 
#@       set pg($path_group_name,max,levels) [sproc_pt_report_qor_count_levels $timing_path_max_worst]
#@       set pg($path_group_name,max,delay) [get_attribute $timing_path_max_worst arrival]
#@       set slack [get_attribute $timing_path_max_worst slack]
#@       if { $slack == "" } {
#@         set pg($path_group_name,max,wns) 99.99
#@       } else {
#@         set pg($path_group_name,max,wns) $slack
#@       }
#@ 
#@       set endpoint_clock [get_attribute $timing_path_max_worst endpoint_clock]
#@       if { $endpoint_clock == "" } {
#@         set pg($path_group_name,max,period) 0.0
#@       } else {
#@         set period [get_attribute $endpoint_clock period]
#@         if { $period == "" } {
#@           set pg($path_group_name,max,period) 0.0
#@         } else {
#@           set pg($path_group_name,max,period) $period
#@         }
#@       }
#@ 
#@       set tns 0.0
#@       set nvp 0
#@       if { $pg($path_group_name,max,wns) < 0.0 } {
#@         set timing_paths_max [get_timing_paths -group $path_group_obj -delay_type max -slack_lesser_than 0.0 -max_paths $max_path_count]
#@         set nvp [sizeof_collection $timing_paths_max]
#@         foreach_in_collection path $timing_paths_max {
#@           set slack [get_attribute $path slack]
#@           set tns [expr $tns + $slack]
#@         }
#@       }
#@       set pg($path_group_name,max,tns) $tns
#@       set pg($path_group_name,max,nvp) $nvp
#@ 
#@       ## -------------------------------------
#@       ## Min info (per path_group)
#@       ## -------------------------------------
#@ 
#@       set timing_path_min_worst [get_timing_paths -group $path_group_name -delay_type min]
#@ 
#@       set slack [get_attribute $timing_path_min_worst slack]
#@       if { $slack == "" } {
#@         set pg($path_group_name,min,wns) 99.99
#@       } else {
#@         set pg($path_group_name,min,wns) $slack
#@       }
#@ 
#@       set tns 0.0
#@       set nvp 0
#@       if { $pg($path_group_name,min,wns) < 0.0 } {
#@         set timing_paths_min [get_timing_paths -group $path_group_obj -delay_type min -slack_lesser_than 0.0 -max_paths $max_path_count]
#@         set nvp [sizeof_collection $timing_paths_min]
#@         foreach_in_collection path $timing_paths_min {
#@           set slack [get_attribute $path slack]
#@           set tns [expr $tns + $slack]
#@         }
#@       }
#@       set pg($path_group_name,min,tns) $tns
#@       set pg($path_group_name,min,nvp) $nvp
#@ 
#@     }
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Gather data for report. (per scenario)
#@   ## -------------------------------------
#@ 
#@   ## set timing_path_max_worst [get_timing_paths -delay_type max]
#@   set worst_slack ""
#@   foreach_in_collection path [get_timing_paths -delay_type max] {
#@     set slack [get_attribute $path slack]
#@     if { $slack != "" } {
#@       if { $worst_slack == "" } {
#@         set worst_slack $slack
#@         set timing_path_max_worst $path
#@       } else {
#@         if { $slack < $worst_slack } {
#@           set worst_slack $slack
#@           set timing_path_max_worst $path
#@         }
#@       }
#@     }
#@   }
#@   if { $worst_slack == "" } {
#@     set timing_path_max_worst $path
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Max info (per scenario)
#@   ## -------------------------------------
#@ 
#@   set path_group_name ___DESIGN___
#@ 
#@   set pg($path_group_name,max,levels) [sproc_pt_report_qor_count_levels $timing_path_max_worst]
#@   set pg($path_group_name,max,delay) [get_attribute $timing_path_max_worst arrival]
#@   set slack [get_attribute $timing_path_max_worst slack]
#@ 
#@   if { $slack == "" } {
#@     set pg($path_group_name,max,wns) 0.0
#@   } else {
#@     if { $slack < 0.0 } {
#@       set pg($path_group_name,max,wns) [expr abs($slack)]
#@     } else {
#@       set pg($path_group_name,max,wns) 0.0
#@     }
#@   }
#@ 
#@   set endpoint_clock [get_attribute $timing_path_max_worst endpoint_clock]
#@   if { $endpoint_clock == "" } {
#@     set pg($path_group_name,max,period) n/a
#@   } else {
#@     set period [get_attribute $endpoint_clock period]
#@     if { $period == "" } {
#@       set pg($path_group_name,max,period) n/a
#@     } else {
#@       set pg($path_group_name,max,period) $period
#@     }
#@   }
#@ 
#@   set tns 0.0
#@   set nvp 0
#@   if { $pg($path_group_name,max,wns) > 0.0 } {
#@     set timing_paths_max [get_timing_paths -delay_type max -slack_lesser_than 0.0 -max_paths $max_path_count]
#@     set nvp [sizeof_collection $timing_paths_max]
#@     foreach_in_collection path $timing_paths_max {
#@       set slack [get_attribute $path slack]
#@       set tns [expr $tns + $slack]
#@     }
#@   }
#@   set pg($path_group_name,max,tns) [expr abs($tns)]
#@   set pg($path_group_name,max,nvp) $nvp
#@ 
#@   ## -------------------------------------
#@   ## Min info (per scenario)
#@   ## -------------------------------------
#@ 
#@   ## set timing_path_min_worst [get_timing_paths -delay_type min]
#@   set worst_slack ""
#@   foreach_in_collection path [get_timing_paths -delay_type min] {
#@     set slack [get_attribute $path slack]
#@     if { $slack != "" } {
#@       if { $worst_slack == "" } {
#@         set worst_slack $slack
#@         set timing_path_min_worst $path
#@       } else {
#@         if { $slack < $worst_slack } {
#@           set worst_slack $slack
#@           set timing_path_min_worst $path
#@         }
#@       }
#@     }
#@   }
#@   if { $worst_slack == "" } {
#@     set timing_path_min_worst $path
#@   }
#@ 
#@   set slack [get_attribute $timing_path_min_worst slack]
#@   if { $slack == "" } {
#@     set pg($path_group_name,min,wns) 0.00
#@   } else {
#@     if { $slack < 0.0 } {
#@       set pg($path_group_name,min,wns) [expr abs($slack)]
#@     } else {
#@       set pg($path_group_name,min,wns) 0.0
#@     }
#@   }
#@ 
#@   set tns 0.0
#@   set nvp 0
#@   if { $pg($path_group_name,min,wns) > 0.0 } {
#@     set timing_paths_min [get_timing_paths -delay_type min -slack_lesser_than 0.0 -max_paths $max_path_count]
#@     set nvp [sizeof_collection $timing_paths_min]
#@     foreach_in_collection path $timing_paths_min {
#@       set slack [get_attribute $path slack]
#@       set tns [expr $tns + $slack]
#@     }
#@   }
#@   set pg($path_group_name,min,tns) [expr abs($tns)]
#@   set pg($path_group_name,min,nvp) $nvp
#@ 
#@   ## -------------------------------------
#@   ## Create body of report.
#@   ## -------------------------------------
#@ 
#@   foreach scenario $options(-scenario) {
#@     foreach path_group_name $path_group_name_list {
#@ 
#@       puts "  Scenario '$scenario'"
#@       puts "  Timing Path Group '$path_group_name'"
#@       puts "  -----------------------------------"
#@       puts "  Levels of Logic:             $pg($path_group_name,max,levels)"
#@       puts "  Critical Path Length:        $pg($path_group_name,max,delay)"
#@       puts "  Critical Path Slack:         $pg($path_group_name,max,wns)"
#@       puts "  Critical Path Clk Period:    $pg($path_group_name,max,period)"
#@       puts "  Total Negative Slack:        $pg($path_group_name,max,tns)"
#@       puts "  No. of Violating Paths:      $pg($path_group_name,max,nvp)"
#@       puts "  Worst Hold Violation:        $pg($path_group_name,min,wns)"
#@       puts "  Total Hold Violation:        $pg($path_group_name,min,tns)"
#@       puts "  No. of Hold Violations:      $pg($path_group_name,min,nvp)"
#@       puts "  -----------------------------------"
#@       puts ""
#@       if { $pg($path_group_name,max,nvp) >= $max_path_count } {
#@         puts "Warning: No. of Violating Paths exceeds $max_path_count"
#@         puts ""
#@       }
#@       if { $pg($path_group_name,min,nvp) >= $max_path_count } {
#@         puts "Warning: No. of Hold Violations exceeds $max_path_count"
#@         puts ""
#@       }
#@     }
#@ 
#@     set path_group_name ___DESIGN___
#@     puts "  Scenario: $scenario        WNS: $pg($path_group_name,max,wns) TNS: $pg($path_group_name,max,tns) Number of Violating Paths: $pg($path_group_name,max,nvp)"
#@     puts "  Design                     WNS: $pg($path_group_name,max,wns) TNS: $pg($path_group_name,max,tns) Number of Violating Paths: $pg($path_group_name,max,nvp)"
#@     puts ""
#@     puts "  Scenario: $scenario (Hold) WNS: $pg($path_group_name,min,wns) TNS: $pg($path_group_name,min,tns) Number of Violating Paths: $pg($path_group_name,min,nvp)"
#@     puts "  Design              (Hold) WNS: $pg($path_group_name,min,wns) TNS: $pg($path_group_name,min,tns) Number of Violating Paths: $pg($path_group_name,min,nvp)"
#@     puts ""
#@ 
#@   }
#@ 
#@   puts "End of Report"
#@ 
#@ }
#@ 
#@ define_proc_attributes sproc_pt_report_qor   -info "Report QoR for Primetime"   -define_args {    {-scenario "The scenario to process." AString string optional}
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_pt_report_qor:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_pt_report_qor { args } {
#@ 
#@   global env SEV SVAR TEV
#@   global synopsys_program_name
#@   global sh_product_version
#@   global sh_dev_null
#@   global pt_shell_mode
#@ 
#@   ## -------------------------------------
#@   ## Process arguments
#@   ## -------------------------------------
#@ 
#@   set options(-scenario) [list]
#@   parse_proc_arguments -args $args options
#@ 
#@   ## -------------------------------------
#@   ## Basic error checking
#@   ## -------------------------------------
#@ 
#@   if { $synopsys_program_name != "pt_shell" } {
#@     puts "Error: This script only functions properly in PrimeTime."
#@     return 0
#@   }
#@ 
#@   switch $pt_shell_mode {
#@     primetime {
#@       if { [llength $options(-scenario)] != 1 } {
#@         puts "Error: A single scenario must be specified."
#@         return 0
#@       }
#@     }
#@     primetime_slave {
#@       if { [llength $options(-scenario)] != 1 } {
#@         puts "Error: A single scenario must be specified."
#@         return 0
#@       }
#@       if { $options(-scenario) != [current_scenario] } {
#@         puts "Error: Slave session does not match selected scenario."
#@         return 0
#@       }
#@     }
#@     primetime_master {
#@       puts "Error: This command not implemented for PT DMSA Masters."
#@       return 0
#@     }
#@   }
#@ 
#@   catch { set design [current_design] } result
#@   if { $design == "" } {
#@     return 0
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Variables to configure this procedure.
#@   ## -------------------------------------
#@ 
#@   set max_path_count 100000
#@ 
#@  ## -------------------------------------
#@   ## Print banner
#@   ## -------------------------------------
#@ 
#@   puts "## -------------------------------------"
#@   puts "## Report : Lynx Design System version of 'report_qor' for Primetime"
#@   puts "## Design : [get_object_name $design]"
#@   puts "## Scenario(s):"
#@   foreach scenario $options(-scenario) {
#@     puts "##   $scenario"
#@   }
#@   puts "## Version: $sh_product_version"
#@   puts "## Date   : [date]"
#@   puts "## -------------------------------------"
#@   puts ""
#@ 
#@   ## -------------------------------------
#@   ## Gather data for report. (per path_group)
#@   ## -------------------------------------
#@ 
#@   set path_group_name_list [list]
#@ 
#@   foreach_in_collection path_group_obj [get_path_groups] {
#@ 
#@     set path_group_name [get_object_name $path_group_obj]
#@ 
#@     set timing_path_max_worst [get_timing_paths -group $path_group_obj -delay_type max]
#@ 
#@     set num_of_paths [sizeof_collection $timing_path_max_worst]
#@ 
#@     if { $num_of_paths == 0 } {
#@ 
#@       continue
#@ 
#@     } else {
#@ 
#@       lappend path_group_name_list $path_group_name
#@ 
#@       ## -------------------------------------
#@       ## Max info (per path_group)
#@       ## -------------------------------------
#@ 
#@       set pg($path_group_name,max,levels) [sproc_pt_report_qor_count_levels $timing_path_max_worst]
#@       set pg($path_group_name,max,delay) [get_attribute $timing_path_max_worst arrival]
#@       set slack [get_attribute $timing_path_max_worst slack]
#@       if { $slack == "" } {
#@         set pg($path_group_name,max,wns) 99.99
#@       } else {
#@         set pg($path_group_name,max,wns) $slack
#@       }
#@ 
#@       set endpoint_clock [get_attribute $timing_path_max_worst endpoint_clock]
#@       if { $endpoint_clock == "" } {
#@         set pg($path_group_name,max,period) 0.0
#@       } else {
#@         set period [get_attribute $endpoint_clock period]
#@         if { $period == "" } {
#@           set pg($path_group_name,max,period) 0.0
#@         } else {
#@           set pg($path_group_name,max,period) $period
#@         }
#@       }
#@ 
#@       set tns 0.0
#@       set nvp 0
#@       if { $pg($path_group_name,max,wns) < 0.0 } {
#@         set timing_paths_max [get_timing_paths -group $path_group_obj -delay_type max -slack_lesser_than 0.0 -max_paths $max_path_count]
#@         set nvp [sizeof_collection $timing_paths_max]
#@         foreach_in_collection path $timing_paths_max {
#@           set slack [get_attribute $path slack]
#@           set tns [expr $tns + $slack]
#@         }
#@       }
#@       set pg($path_group_name,max,tns) $tns
#@       set pg($path_group_name,max,nvp) $nvp
#@ 
#@       ## -------------------------------------
#@       ## Min info (per path_group)
#@       ## -------------------------------------
#@ 
#@       set timing_path_min_worst [get_timing_paths -group $path_group_name -delay_type min]
#@ 
#@       set slack [get_attribute $timing_path_min_worst slack]
#@       if { $slack == "" } {
#@         set pg($path_group_name,min,wns) 99.99
#@       } else {
#@         set pg($path_group_name,min,wns) $slack
#@       }
#@ 
#@       set tns 0.0
#@       set nvp 0
#@       if { $pg($path_group_name,min,wns) < 0.0 } {
#@         set timing_paths_min [get_timing_paths -group $path_group_obj -delay_type min -slack_lesser_than 0.0 -max_paths $max_path_count]
#@         set nvp [sizeof_collection $timing_paths_min]
#@         foreach_in_collection path $timing_paths_min {
#@           set slack [get_attribute $path slack]
#@           set tns [expr $tns + $slack]
#@         }
#@       }
#@       set pg($path_group_name,min,tns) $tns
#@       set pg($path_group_name,min,nvp) $nvp
#@ 
#@     }
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Gather data for report. (per scenario)
#@   ## -------------------------------------
#@ 
#@   ## set timing_path_max_worst [get_timing_paths -delay_type max]
#@   set worst_slack ""
#@   foreach_in_collection path [get_timing_paths -delay_type max] {
#@     set slack [get_attribute $path slack]
#@     if { $slack != "" } {
#@       if { $worst_slack == "" } {
#@         set worst_slack $slack
#@         set timing_path_max_worst $path
#@       } else {
#@         if { $slack < $worst_slack } {
#@           set worst_slack $slack
#@           set timing_path_max_worst $path
#@         }
#@       }
#@     }
#@   }
#@   if { $worst_slack == "" } {
#@     set timing_path_max_worst $path
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Max info (per scenario)
#@   ## -------------------------------------
#@ 
#@   set path_group_name ___DESIGN___
#@ 
#@   set pg($path_group_name,max,levels) [sproc_pt_report_qor_count_levels $timing_path_max_worst]
#@   set pg($path_group_name,max,delay) [get_attribute $timing_path_max_worst arrival]
#@   set slack [get_attribute $timing_path_max_worst slack]
#@ 
#@   if { $slack == "" } {
#@     set pg($path_group_name,max,wns) 0.0
#@   } else {
#@     if { $slack < 0.0 } {
#@       set pg($path_group_name,max,wns) [expr abs($slack)]
#@     } else {
#@       set pg($path_group_name,max,wns) 0.0
#@     }
#@   }
#@ 
#@   set endpoint_clock [get_attribute $timing_path_max_worst endpoint_clock]
#@   if { $endpoint_clock == "" } {
#@     set pg($path_group_name,max,period) n/a
#@   } else {
#@     set period [get_attribute $endpoint_clock period]
#@     if { $period == "" } {
#@       set pg($path_group_name,max,period) n/a
#@     } else {
#@       set pg($path_group_name,max,period) $period
#@     }
#@   }
#@ 
#@   set tns 0.0
#@   set nvp 0
#@   if { $pg($path_group_name,max,wns) > 0.0 } {
#@     set timing_paths_max [get_timing_paths -delay_type max -slack_lesser_than 0.0 -max_paths $max_path_count]
#@     set nvp [sizeof_collection $timing_paths_max]
#@     foreach_in_collection path $timing_paths_max {
#@       set slack [get_attribute $path slack]
#@       set tns [expr $tns + $slack]
#@     }
#@   }
#@   set pg($path_group_name,max,tns) [expr abs($tns)]
#@   set pg($path_group_name,max,nvp) $nvp
#@ 
#@   ## -------------------------------------
#@   ## Min info (per scenario)
#@   ## -------------------------------------
#@ 
#@   ## set timing_path_min_worst [get_timing_paths -delay_type min]
#@   set worst_slack ""
#@   foreach_in_collection path [get_timing_paths -delay_type min] {
#@     set slack [get_attribute $path slack]
#@     if { $slack != "" } {
#@       if { $worst_slack == "" } {
#@         set worst_slack $slack
#@         set timing_path_min_worst $path
#@       } else {
#@         if { $slack < $worst_slack } {
#@           set worst_slack $slack
#@           set timing_path_min_worst $path
#@         }
#@       }
#@     }
#@   }
#@   if { $worst_slack == "" } {
#@     set timing_path_min_worst $path
#@   }
#@ 
#@   set slack [get_attribute $timing_path_min_worst slack]
#@   if { $slack == "" } {
#@     set pg($path_group_name,min,wns) 0.00
#@   } else {
#@     if { $slack < 0.0 } {
#@       set pg($path_group_name,min,wns) [expr abs($slack)]
#@     } else {
#@       set pg($path_group_name,min,wns) 0.0
#@     }
#@   }
#@ 
#@   set tns 0.0
#@   set nvp 0
#@   if { $pg($path_group_name,min,wns) > 0.0 } {
#@     set timing_paths_min [get_timing_paths -delay_type min -slack_lesser_than 0.0 -max_paths $max_path_count]
#@     set nvp [sizeof_collection $timing_paths_min]
#@     foreach_in_collection path $timing_paths_min {
#@       set slack [get_attribute $path slack]
#@       set tns [expr $tns + $slack]
#@     }
#@   }
#@   set pg($path_group_name,min,tns) [expr abs($tns)]
#@   set pg($path_group_name,min,nvp) $nvp
#@ 
#@   ## -------------------------------------
#@   ## Create body of report.
#@   ## -------------------------------------
#@ 
#@   foreach scenario $options(-scenario) {
#@     foreach path_group_name $path_group_name_list {
#@ 
#@       puts "  Scenario '$scenario'"
#@       puts "  Timing Path Group '$path_group_name'"
#@       puts "  -----------------------------------"
#@       puts "  Levels of Logic:             $pg($path_group_name,max,levels)"
#@       puts "  Critical Path Length:        $pg($path_group_name,max,delay)"
#@       puts "  Critical Path Slack:         $pg($path_group_name,max,wns)"
#@       puts "  Critical Path Clk Period:    $pg($path_group_name,max,period)"
#@       puts "  Total Negative Slack:        $pg($path_group_name,max,tns)"
#@       puts "  No. of Violating Paths:      $pg($path_group_name,max,nvp)"
#@       puts "  Worst Hold Violation:        $pg($path_group_name,min,wns)"
#@       puts "  Total Hold Violation:        $pg($path_group_name,min,tns)"
#@       puts "  No. of Hold Violations:      $pg($path_group_name,min,nvp)"
#@       puts "  -----------------------------------"
#@       puts ""
#@       if { $pg($path_group_name,max,nvp) >= $max_path_count } {
#@         puts "Warning: No. of Violating Paths exceeds $max_path_count"
#@         puts ""
#@       }
#@       if { $pg($path_group_name,min,nvp) >= $max_path_count } {
#@         puts "Warning: No. of Hold Violations exceeds $max_path_count"
#@         puts ""
#@       }
#@     }
#@ 
#@     set path_group_name ___DESIGN___
#@     puts "  Scenario: $scenario        WNS: $pg($path_group_name,max,wns) TNS: $pg($path_group_name,max,tns) Number of Violating Paths: $pg($path_group_name,max,nvp)"
#@     puts "  Design                     WNS: $pg($path_group_name,max,wns) TNS: $pg($path_group_name,max,tns) Number of Violating Paths: $pg($path_group_name,max,nvp)"
#@     puts ""
#@     puts "  Scenario: $scenario (Hold) WNS: $pg($path_group_name,min,wns) TNS: $pg($path_group_name,min,tns) Number of Violating Paths: $pg($path_group_name,min,nvp)"
#@     puts "  Design              (Hold) WNS: $pg($path_group_name,min,wns) TNS: $pg($path_group_name,min,tns) Number of Violating Paths: $pg($path_group_name,min,nvp)"
#@     puts ""
#@ 
#@   }
#@ 
#@   puts "End of Report"
#@ 
#@ }
#@ 
#@ define_proc_attributes sproc_pt_report_qor   -info "Report QoR for Primetime"   -define_args {    {-scenario "The scenario to process." AString string optional}
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_pt_report_qor_count_levels:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_pt_report_qor_count_levels { path } {
#@   set levels 0
#@   set endpoint [get_object_name [get_attribute -quiet $path endpoint]]
#@   foreach_in_collection point [get_attribute -quiet $path points] {
#@     set object [get_attribute -quiet $point object]
#@     if {[get_attribute -quiet $object object_class] == "pin"} {
#@       if {[get_attribute -quiet $object pin_direction] == "in"} {
#@         if {[get_attribute -quiet $object is_port] == "false"} {
#@           if {[get_attribute -quiet $object full_name] != $endpoint} {
#@             incr levels
#@           }
#@         }
#@       }
#@     }
#@   }
#@   return $levels
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_pt_report_qor_count_levels:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_pt_report_qor_count_levels { path } {
#@   set levels 0
#@   set endpoint [get_object_name [get_attribute -quiet $path endpoint]]
#@   foreach_in_collection point [get_attribute -quiet $path points] {
#@     set object [get_attribute -quiet $point object]
#@     if {[get_attribute -quiet $object object_class] == "pin"} {
#@       if {[get_attribute -quiet $object pin_direction] == "in"} {
#@         if {[get_attribute -quiet $object is_port] == "false"} {
#@           if {[get_attribute -quiet $object full_name] != $endpoint} {
#@             incr levels
#@           }
#@         }
#@       }
#@     }
#@   }
#@   return $levels
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_send_aro_mem:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_send_aro_mem { args } {
#@ 
#@   sproc_pinfo -mode start
#@ 
#@   global env SEV SVAR TEV
#@ 
#@   set options(-job_id) ""
#@   set options(-memory_used) ""
#@   parse_proc_arguments -args $args options
#@ 
#@   ## -------------------------------------
#@   ## Open a blocking-style socket
#@   ## -------------------------------------
#@ 
#@   set socket_host $SEV(aro_server)
#@   set socket_port $SEV(aro_port)
#@ 
#@   set socket_ok 0
#@   set max_socket_attempts 10
#@   for { set i 1 } { $i < [expr $max_socket_attempts + 1] } { incr i } {
#@     set socket_return [catch { socket $socket_host $socket_port } socket_channel]
#@     if { $socket_return } {
#@       puts "SNPS_INFO: Unable to establish socket channel on attempt $i"
#@       after 1000
#@     } else {
#@       set socket_ok 1
#@       break
#@     }
#@   }
#@ 
#@   if { !$socket_ok } {
#@     puts "SNPS_ERROR : Unable to create socket ($socket_host:$socket_port) from [info host] to ARO Daemon"
#@     puts "SNPS_ERROR : Socket returns $socket_channel"
#@   } else {
#@ 
#@     fconfigure $socket_channel -blocking 1
#@ 
#@     ## -------------------------------------
#@     ## Send MEM command to ARO daemon
#@     ## -------------------------------------
#@ 
#@     puts $socket_channel "ARO_MEM_START"
#@     puts $socket_channel "FILE|$options(-job_id).aro_mem"
#@     puts $socket_channel "INFO.MEMORY_USED|INTEGER|$options(-memory_used)"
#@     puts $socket_channel "ARO_MEM_STOP"
#@ 
#@     flush $socket_channel
#@ 
#@     ## -------------------------------------
#@     ## Read MEM response from ARO daemon
#@     ## -------------------------------------
#@ 
#@     set lines [list]
#@     while {1} {
#@       set line [gets $socket_channel]
#@       if { [eof $socket_channel] } {
#@         close $socket_channel
#@         break
#@       } else {
#@         lappend lines $line
#@       }
#@     }
#@ 
#@     set aro_reply_status [lindex [split [lindex $lines 0] "|"] 0]
#@     set aro_reply_msg    [lindex [split [lindex $lines 0] "|"] 1]
#@ 
#@     if { $aro_reply_status == "1" } {
#@       sproc_msg -info "Successful send of ARO_MEM"
#@     } else {
#@       sproc_msg -error "Reply during ARO_MEM: $aro_reply_msg"
#@     }
#@ 
#@   }
#@ 
#@   sproc_pinfo -mode stop
#@ 
#@ }
#@ 
#@ define_proc_attributes sproc_send_aro_mem   -info "Used to determine the version of a script."   -define_args {
#@   {-job_id      "The job id for the task reporting memory usage." AnInt int required}
#@   {-memory_used "The amount of memory in MB."                     AnInt int required}
#@ }
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_send_aro_mem:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_send_aro_mem { args } {
#@ 
#@   sproc_pinfo -mode start
#@ 
#@   global env SEV SVAR TEV
#@ 
#@   set options(-job_id) ""
#@   set options(-memory_used) ""
#@   parse_proc_arguments -args $args options
#@ 
#@   ## -------------------------------------
#@   ## Open a blocking-style socket
#@   ## -------------------------------------
#@ 
#@   set socket_host $SEV(aro_server)
#@   set socket_port $SEV(aro_port)
#@ 
#@   set socket_ok 0
#@   set max_socket_attempts 10
#@   for { set i 1 } { $i < [expr $max_socket_attempts + 1] } { incr i } {
#@     set socket_return [catch { socket $socket_host $socket_port } socket_channel]
#@     if { $socket_return } {
#@       puts "SNPS_INFO: Unable to establish socket channel on attempt $i"
#@       after 1000
#@     } else {
#@       set socket_ok 1
#@       break
#@     }
#@   }
#@ 
#@   if { !$socket_ok } {
#@     puts "SNPS_ERROR : Unable to create socket ($socket_host:$socket_port) from [info host] to ARO Daemon"
#@     puts "SNPS_ERROR : Socket returns $socket_channel"
#@   } else {
#@ 
#@     fconfigure $socket_channel -blocking 1
#@ 
#@     ## -------------------------------------
#@     ## Send MEM command to ARO daemon
#@     ## -------------------------------------
#@ 
#@     puts $socket_channel "ARO_MEM_START"
#@     puts $socket_channel "FILE|$options(-job_id).aro_mem"
#@     puts $socket_channel "INFO.MEMORY_USED|INTEGER|$options(-memory_used)"
#@     puts $socket_channel "ARO_MEM_STOP"
#@ 
#@     flush $socket_channel
#@ 
#@     ## -------------------------------------
#@     ## Read MEM response from ARO daemon
#@     ## -------------------------------------
#@ 
#@     set lines [list]
#@     while {1} {
#@       set line [gets $socket_channel]
#@       if { [eof $socket_channel] } {
#@         close $socket_channel
#@         break
#@       } else {
#@         lappend lines $line
#@       }
#@     }
#@ 
#@     set aro_reply_status [lindex [split [lindex $lines 0] "|"] 0]
#@     set aro_reply_msg    [lindex [split [lindex $lines 0] "|"] 1]
#@ 
#@     if { $aro_reply_status == "1" } {
#@       sproc_msg -info "Successful send of ARO_MEM"
#@     } else {
#@       sproc_msg -error "Reply during ARO_MEM: $aro_reply_msg"
#@     }
#@ 
#@   }
#@ 
#@   sproc_pinfo -mode stop
#@ 
#@ }
#@ 
#@ define_proc_attributes sproc_send_aro_mem   -info "Used to determine the version of a script."   -define_args {
#@   {-job_id      "The job id for the task reporting memory usage." AnInt int required}
#@   {-memory_used "The amount of memory in MB."                     AnInt int required}
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_metric_parse_report_units:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_metric_parse_report_units { args } {
#@ 
#@   sproc_pinfo -mode start
#@ 
#@   global env SEV SVAR synopsys_program_name pt_shell_mode
#@ 
#@   set options(-file) ""
#@   parse_proc_arguments -args $args options
#@ 
#@   ## -------------------------------------
#@   ## Standard setup
#@   ## -------------------------------------
#@ 
#@   set rval(error_flag)       0
#@   set rval(time_unit)        "undefined"
#@ 
#@   set rval(text_time)        "undefined"
#@   set rval(text_capacitance) "undefined"
#@   set rval(text_resistance)  "undefined"
#@   set rval(text_voltage)     "undefined"
#@   set rval(text_power)       "undefined"
#@   set rval(text_current)     "undefined"
#@ 
#@   ## -------------------------------------
#@   ## Standard argument processing
#@   ## -------------------------------------
#@ 
#@   if { [file exists $options(-file)] } {
#@     sproc_msg -info "The specified report file is: '$options(-file)'"
#@   } else {
#@     sproc_msg -error "The specified report file does not exist: '$options(-file)'"
#@     set rval(error_flag) 1
#@     sproc_pinfo -mode stop
#@     return [array get rval]
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Read the report
#@   ## -------------------------------------
#@ 
#@   set fid [open $options(-file) r]
#@   set string_file [read $fid]
#@   close $fid
#@   set lines [split $string_file \n]
#@ 
#@   ## -------------------------------------
#@   ## Parse the report
#@   ## -------------------------------------
#@ 
#@   if { $synopsys_program_name == "icc2_shell" } {
#@ 
#@     foreach line $lines {
#@       regexp {^time\s+:\s+[\d\.]*(.*)\s*$} $line match rval(text_time)
#@       regexp {^resistance\s+:\s+[\d\.]*(.*)\s*$} $line match rval(text_capacitance)
#@       regexp {^capacitance\s+:\s+[\d\.]*(.*)\s*$} $line match rval(text_resistance)
#@       regexp {^voltage\s+:\s+[\d\.]*(.*)\s*$} $line match rval(text_voltage)
#@       regexp {^current\s+:\s+[\d\.]*(.*)\s*$} $line match rval(text_power)
#@       regexp {^power\s+:\s+[\d\.]*(.*)\s*$} $line match rval(text_current)
#@     }
#@     set rval(time_unit) $rval(text_time)
#@ 
#@   } else {
#@ 
#@     set time_unit undefined
#@     foreach line $lines {
#@       regexp {(e\-\S\S)\s+Second} $line match time_unit
#@ 
#@       regexp {^Time_unit\s+:\s+(.*)\s*$} $line match rval(text_time)
#@       regexp {^Capacitive_load_unit\s+:\s+(.*)\s*$} $line match rval(text_capacitance)
#@       regexp {^Resistance_unit\s+:\s+(.*)\s*$} $line match rval(text_resistance)
#@       regexp {^Voltage_unit\s+:\s+(.*)\s*$} $line match rval(text_voltage)
#@       regexp {^Power_unit\s+:\s+(.*)\s*$} $line match rval(text_power)
#@       regexp {^Current_unit\s+:\s+(.*)\s*$} $line match rval(text_current)
#@     }
#@ 
#@     switch $time_unit {
#@       e-00 {
#@         set rval(time_unit) s
#@       }
#@       e-03 {
#@         set rval(time_unit) ms
#@       }
#@       e-06 {
#@         set rval(time_unit) us
#@       }
#@       e-09 {
#@         set rval(time_unit) ns
#@       }
#@       e-12 {
#@         set rval(time_unit) ps
#@       }
#@       e-15 {
#@         set rval(time_unit) fs
#@       }
#@       default {
#@         sproc_msg -error "Unrecognized value for time units: $time_unit"
#@         set rval(error_flag) 1
#@       }
#@     }
#@ 
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Return the parsed information
#@   ## -------------------------------------
#@ 
#@   sproc_pinfo -mode stop
#@   return [array get rval]
#@ }
#@ 
#@ define_proc_attributes sproc_metric_parse_report_units   -info "Parses information for report_units."   -define_args {    {-file "The report_units file to parse." AString string required}
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_metric_parse_report_qor:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_metric_parse_report_qor { args } {
#@ 
#@   sproc_pinfo -mode start
#@ 
#@   global env SEV SVAR synopsys_program_name pt_shell_mode
#@ 
#@   set options(-file) ""
#@   parse_proc_arguments -args $args options
#@ 
#@   ## -------------------------------------
#@   ## Standard setup
#@   ## -------------------------------------
#@ 
#@   set rval(error_flag) 0
#@ 
#@   ## -------------------------------------
#@   ## Standard argument processing
#@   ## -------------------------------------
#@ 
#@   if { [file exists $options(-file)] } {
#@     sproc_msg -info "The specified report file is: '$options(-file)'"
#@   } else {
#@     sproc_msg -error "The specified report file does not exist: '$options(-file)'"
#@     set rval(error_flag) 1
#@     sproc_pinfo -mode stop
#@     return [array get rval]
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Read the report
#@   ## -------------------------------------
#@ 
#@   set fid [open $options(-file) r]
#@   set string_file [read $fid]
#@   close $fid
#@   set lines [split $string_file \n]
#@ 
#@   ## -------------------------------------
#@   ## Parse the report for path group information.
#@   ## -------------------------------------
#@ 
#@   set rval(path_group_data,scenario_name_list) [list]
#@ 
#@   set scenario_name None/non-MCMM
#@ 
#@   set line_number 0
#@   set path_group_name NO_PATH_GROUP
#@   foreach line $lines {
#@     incr line_number
#@ 
#@     regexp {^\s*Scenario\s+\'(.*)\'} $line matchVar scenario_name
#@ 
#@     if { [regexp {^\s*Timing Path Group\s+'(\S+)'} $line matchVar path_group_name] } {
#@ 
#@       lappend rval(path_group_data,scenario_name_list) $scenario_name
#@       lappend rval(path_group_data,path_group_name_list,$scenario_name) $path_group_name
#@ 
#@       set rval(path_group_data,$scenario_name,$path_group_name,setup,logic_levels) NA
#@       set rval(path_group_data,$scenario_name,$path_group_name,setup,path_length)  NA
#@       set rval(path_group_data,$scenario_name,$path_group_name,setup,path_slack)   NA
#@       set rval(path_group_data,$scenario_name,$path_group_name,setup,path_period)  NA
#@       set rval(path_group_data,$scenario_name,$path_group_name,setup,tns)          NA
#@       set rval(path_group_data,$scenario_name,$path_group_name,setup,nvp)          NA
#@       set rval(path_group_data,$scenario_name,$path_group_name,hold,path_slack)    NA
#@       set rval(path_group_data,$scenario_name,$path_group_name,hold,tns)           NA
#@       set rval(path_group_data,$scenario_name,$path_group_name,hold,nvp)           NA
#@ 
#@       set rval(path_group_data,$scenario_name,$path_group_name,line_number) $line_number
#@ 
#@       set rval(path_group_data,$scenario_name,$path_group_name,setup,logic_levels,line_number) 1
#@       set rval(path_group_data,$scenario_name,$path_group_name,setup,path_length,line_number)  1
#@       set rval(path_group_data,$scenario_name,$path_group_name,setup,path_slack,line_number)   1
#@       set rval(path_group_data,$scenario_name,$path_group_name,setup,path_period,line_number)  1
#@       set rval(path_group_data,$scenario_name,$path_group_name,setup,tns,line_number)          1
#@       set rval(path_group_data,$scenario_name,$path_group_name,setup,nvp,line_number)          1
#@       set rval(path_group_data,$scenario_name,$path_group_name,hold,path_slack,line_number)    1
#@       set rval(path_group_data,$scenario_name,$path_group_name,hold,tns,line_number)           1
#@       set rval(path_group_data,$scenario_name,$path_group_name,hold,nvp,line_number)           1
#@     }
#@ 
#@     if { [regexp {^\s*Levels of Logic:\s+([\-\d\.]+)} $line matchVar data] } {
#@       set rval(path_group_data,$scenario_name,$path_group_name,setup,logic_levels) $data
#@       set rval(path_group_data,$scenario_name,$path_group_name,setup,logic_levels,line_number) $line_number
#@     }
#@     if { [regexp {^\s*Critical Path Length:\s+([\-\d\.]+)} $line matchVar data] } {
#@       set rval(path_group_data,$scenario_name,$path_group_name,setup,path_length) $data
#@       set rval(path_group_data,$scenario_name,$path_group_name,setup,path_length,line_number) $line_number
#@     }
#@     if { [regexp {^\s*Critical Path Slack:\s+([\-\d\.]+)} $line matchVar data] } {
#@       set rval(path_group_data,$scenario_name,$path_group_name,setup,path_slack) $data
#@       set rval(path_group_data,$scenario_name,$path_group_name,setup,path_slack,line_number) $line_number
#@     }
#@     if { [regexp {^\s*Critical Path Clk Period:\s+(\S+)} $line matchVar data] } {
#@       set rval(path_group_data,$scenario_name,$path_group_name,setup,path_period) $data
#@       set rval(path_group_data,$scenario_name,$path_group_name,setup,path_period,line_number) $line_number
#@     }
#@     if { [regexp {^\s*Total Negative Slack:\s+([\-\d\.]+)} $line matchVar data] } {
#@       set rval(path_group_data,$scenario_name,$path_group_name,setup,tns) $data
#@       set rval(path_group_data,$scenario_name,$path_group_name,setup,tns,line_number) $line_number
#@     }
#@     if { [regexp {^\s*No. of Violating Paths:\s+([\-\d\.]+)} $line matchVar data] } {
#@       set rval(path_group_data,$scenario_name,$path_group_name,setup,nvp) $data
#@       set rval(path_group_data,$scenario_name,$path_group_name,setup,nvp,line_number) $line_number
#@     }
#@     if { [regexp {^\s*Worst Hold Violation:\s+([\-\d\.]+)} $line matchVar data] } {
#@       set rval(path_group_data,$scenario_name,$path_group_name,hold,path_slack) $data
#@       set rval(path_group_data,$scenario_name,$path_group_name,hold,path_slack,line_number) $line_number
#@     }
#@     if { [regexp {^\s*Total Hold Violation:\s+([\-\d\.]+)} $line matchVar data] } {
#@       set rval(path_group_data,$scenario_name,$path_group_name,hold,tns) $data
#@       set rval(path_group_data,$scenario_name,$path_group_name,hold,tns,line_number) $line_number
#@     }
#@     if { [regexp {^\s*No. of Hold Violations:\s+([\-\d\.]+)} $line matchVar data] } {
#@       set rval(path_group_data,$scenario_name,$path_group_name,hold,nvp) $data
#@       set rval(path_group_data,$scenario_name,$path_group_name,hold,nvp,line_number) $line_number
#@     }
#@   }
#@ 
#@   set rval(path_group_data,scenario_name_list) [lsort -unique $rval(path_group_data,scenario_name_list)]
#@   foreach scenario_name $rval(path_group_data,scenario_name_list) {
#@     set rval(path_group_data,path_group_name_list,$scenario_name) [lsort -unique $rval(path_group_data,path_group_name_list,$scenario_name)]
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Parse the report for summary information.
#@   ## -------------------------------------
#@ 
#@   set rval(summary_data,_ss,scenario_name_list) [list]
#@   ## rval(summary_data,_ss,$scenario_name,setup,path_slack)
#@   ## rval(summary_data,_ss,$scenario_name,setup,tns)
#@   ## rval(summary_data,_ss,$scenario_name,setup,nvp)
#@   ## rval(summary_data,_ss,$scenario_name,hold,path_slack)
#@   ## rval(summary_data,_ss,$scenario_name,hold,tns)
#@   ## rval(summary_data,_ss,$scenario_name,hold,nvp)
#@ 
#@   ## rval(summary_data,_ms,setup,path_slack)
#@   ## rval(summary_data,_ms,setup,tns)
#@   ## rval(summary_data,_ms,setup,nvp)
#@   ## rval(summary_data,_ms,hold,path_slack)
#@   ## rval(summary_data,_ms,hold,tns)
#@   ## rval(summary_data,_ms,hold,nvp)
#@ 
#@   set line_number 0
#@   foreach line $lines {
#@     incr line_number
#@ 
#@     if { $synopsys_program_name == "icc2_shell" } {
#@ 
#@       ## -------------------------------------
#@       ## Per-scenario setup
#@       ## -------------------------------------
#@ 
#@       if { [scan $line { %s (Setup) %e %e %d } scenario_name wns tns nvp] == 4 } {
#@         lappend rval(summary_data,_ss,scenario_name_list) $scenario_name
#@         set rval(summary_data,_ss,$scenario_name,setup,path_slack)             $wns
#@         set rval(summary_data,_ss,$scenario_name,setup,tns)                    $tns
#@         set rval(summary_data,_ss,$scenario_name,setup,nvp)                    $nvp
#@         set rval(summary_data,_ss,$scenario_name,setup,path_slack,line_number) $line_number
#@         set rval(summary_data,_ss,$scenario_name,setup,tns,line_number)        $line_number
#@         set rval(summary_data,_ss,$scenario_name,setup,nvp,line_number)        $line_number
#@       }
#@  ## -------------------------------------
#@       ## Per-scenario hold
#@       ## -------------------------------------
#@ 
#@       if { [scan $line { %s (Hold) %e %e %d } scenario_name wns tns nvp] == 4 } {
#@         lappend rval(summary_data,_ss,scenario_name_list) $scenario_name
#@         set rval(summary_data,_ss,$scenario_name,hold,path_slack)             $wns
#@         set rval(summary_data,_ss,$scenario_name,hold,tns)                    $tns
#@         set rval(summary_data,_ss,$scenario_name,hold,nvp)                    $nvp
#@         set rval(summary_data,_ss,$scenario_name,hold,path_slack,line_number) $line_number
#@         set rval(summary_data,_ss,$scenario_name,hold,tns,line_number)        $line_number
#@         set rval(summary_data,_ss,$scenario_name,hold,nvp,line_number)        $line_number
#@       }
#@ 
#@       ## -------------------------------------
#@       ## Per-design setup
#@       ## -------------------------------------
#@ 
#@       if { [scan $line { Design (Setup) %e %e %d } wns tns nvp] == 3 } {
#@         set rval(summary_data,_ms,setup,path_slack)             $wns
#@         set rval(summary_data,_ms,setup,tns)                    $tns
#@         set rval(summary_data,_ms,setup,nvp)                    $nvp
#@         set rval(summary_data,_ms,setup,path_slack,line_number) $line_number
#@         set rval(summary_data,_ms,setup,tns,line_number)        $line_number
#@         set rval(summary_data,_ms,setup,nvp,line_number)        $line_number
#@       }
#@ 
#@       ## -------------------------------------
#@       ## Per-design hold
#@       ## -------------------------------------
#@ 
#@       if { [scan $line { Design (Hold) %e %e %d } wns tns nvp] == 3 } {
#@         set rval(summary_data,_ms,hold,path_slack)             $wns
#@         set rval(summary_data,_ms,hold,tns)                    $tns
#@         set rval(summary_data,_ms,hold,nvp)                    $nvp
#@         set rval(summary_data,_ms,hold,path_slack,line_number) $line_number
#@         set rval(summary_data,_ms,hold,tns,line_number)        $line_number
#@         set rval(summary_data,_ms,hold,nvp,line_number)        $line_number
#@       }
#@ 
#@     } else {
#@ 
#@       ## -------------------------------------
#@       ## Per-scenario setup
#@       ## -------------------------------------
#@ 
#@       if { [scan $line { Scenario: %s WNS: %e TNS: %e Number of Violating Paths: %d} scenario_name wns tns nvp] == 4 } {
#@         lappend rval(summary_data,_ss,scenario_name_list) $scenario_name
#@         ## Note that wns and tns numbers are negated to keep reporting consistent that negative is a violation
#@         set rval(summary_data,_ss,$scenario_name,setup,path_slack)             [format %f [expr 0.0 - $wns]]
#@         set rval(summary_data,_ss,$scenario_name,setup,tns)                    [format %f [expr 0.0 - $tns]]
#@         set rval(summary_data,_ss,$scenario_name,setup,nvp)                    $nvp
#@         set rval(summary_data,_ss,$scenario_name,setup,path_slack,line_number) $line_number
#@         set rval(summary_data,_ss,$scenario_name,setup,tns,line_number)        $line_number
#@         set rval(summary_data,_ss,$scenario_name,setup,nvp,line_number)        $line_number
#@       }
#@ 
#@       ## -------------------------------------
#@       ## Per-scenario hold
#@       ## -------------------------------------
#@ 
#@       if { [scan $line { Scenario: %s (Hold) WNS: %e TNS: %e Number of Violating Paths: %d} scenario_name wns tns nvp] == 4 } {
#@         lappend rval(summary_data,_ss,scenario_name_list) $scenario_name
#@         ## Note that wns and tns numbers are negated to keep reporting consistent that negative is a violation
#@         set rval(summary_data,_ss,$scenario_name,hold,path_slack)             [format %f [expr 0.0 - $wns]]
#@         set rval(summary_data,_ss,$scenario_name,hold,tns)                    [format %f [expr 0.0 - $tns]]
#@         set rval(summary_data,_ss,$scenario_name,hold,nvp)                    $nvp
#@         set rval(summary_data,_ss,$scenario_name,hold,path_slack,line_number) $line_number
#@         set rval(summary_data,_ss,$scenario_name,hold,tns,line_number)        $line_number
#@         set rval(summary_data,_ss,$scenario_name,hold,nvp,line_number)        $line_number
#@       }
#@ 
#@       ## -------------------------------------
#@       ## Per-design setup
#@       ## -------------------------------------
#@ 
#@       if { [scan $line { Design WNS: %e TNS: %e Number of Violating Paths: %d} wns tns nvp] == 3 } {
#@         ## Note that wns and tns numbers are negated to keep reporting consistent that negative is a violation
#@         set rval(summary_data,_ms,setup,path_slack)             [format %f [expr 0.0 - $wns]]
#@         set rval(summary_data,_ms,setup,tns)                    [format %f [expr 0.0 - $tns]]
#@         set rval(summary_data,_ms,setup,nvp)                    $nvp
#@         set rval(summary_data,_ms,setup,path_slack,line_number) $line_number
#@         set rval(summary_data,_ms,setup,tns,line_number)        $line_number
#@         set rval(summary_data,_ms,setup,nvp,line_number)        $line_number
#@       }
#@ 
#@       ## -------------------------------------
#@       ## Per-design hold
#@       ## -------------------------------------
#@ 
#@       if { [scan $line { Design (Hold) WNS: %e TNS: %e Number of Violating Paths: %d} wns tns nvp] == 3 } {
#@         ## Note that wns and tns numbers are negated to keep reporting consistent that negative is a violation
#@         set rval(summary_data,_ms,hold,path_slack)             [format %f [expr 0.0 - $wns]]
#@         set rval(summary_data,_ms,hold,tns)                    [format %f [expr 0.0 - $tns]]
#@         set rval(summary_data,_ms,hold,nvp)                    $nvp
#@         set rval(summary_data,_ms,hold,path_slack,line_number) $line_number
#@         set rval(summary_data,_ms,hold,tns,line_number)        $line_number
#@         set rval(summary_data,_ms,hold,nvp,line_number)        $line_number
#@       }
#@ 
#@     }
#@ 
#@   }
#@ 
#@   set rval(summary_data,_ss,scenario_name_list) [lsort -unique $rval(summary_data,_ss,scenario_name_list)]
#@ 
#@   ## -------------------------------------
#@   ## A "pt_concat.report_qor" file is generated after DMSA processing and is simply
#@   ## a concatenation of the "report_qor" files for each scenario (generated by the PT slaves),
#@   ## and the "pt_master.report_global_timing" file (generated by the PT master).
#@   ## The per-design metrics are extracted from the "pt_master.report_global_timing" content.
#@   ## -------------------------------------
#@ 
#@   if { [file tail $options(-file)] == "pt_concat.report_qor" } {
#@ 
#@     unset -nocomplain rval(summary_data,_ms,setup,path_slack)
#@     unset -nocomplain rval(summary_data,_ms,setup,tns)
#@     unset -nocomplain rval(summary_data,_ms,setup,nvp)
#@     unset -nocomplain rval(summary_data,_ms,setup,path_slack,line_number)
#@     unset -nocomplain rval(summary_data,_ms,setup,tns,line_number)
#@     unset -nocomplain rval(summary_data,_ms,setup,nvp,line_number)
#@ 
#@     unset -nocomplain rval(summary_data,_ms,hold,path_slack)
#@     unset -nocomplain rval(summary_data,_ms,hold,tns)
#@     unset -nocomplain rval(summary_data,_ms,hold,nvp)
#@     unset -nocomplain rval(summary_data,_ms,hold,path_slack,line_number)
#@     unset -nocomplain rval(summary_data,_ms,hold,tns,line_number)
#@     unset -nocomplain rval(summary_data,_ms,hold,nvp,line_number)
#@ 
#@     set line_number 0
#@     foreach line $lines {
#@       incr line_number
#@ 
#@       if { [regexp {^Setup violations} $line] } {
#@         set type setup
#@       }
#@       if { [regexp {^Hold violations} $line] } {
#@         set type hold
#@       }
#@ 
#@       if { [regexp {^WNS} $line] } {
#@         set rval(summary_data,_ms,$type,path_slack) [lindex $line 1]
#@         set rval(summary_data,_ms,$type,path_slack,line_number) $line_number
#@       }
#@       if { [regexp {^TNS} $line] } {
#@         set rval(summary_data,_ms,$type,tns)        [lindex $line 1]
#@         set rval(summary_data,_ms,$type,tns,line_number)        $line_number
#@       }
#@       if { [regexp {^NUM} $line] } {
#@         set rval(summary_data,_ms,$type,nvp)        [lindex $line 1]
#@         set rval(summary_data,_ms,$type,nvp,line_number)        $line_number
#@       }
#@ 
#@       if { [regexp {^No setup violations found} $line] } {
#@         set type setup
#@         set rval(summary_data,_ms,$type,path_slack) 0.0
#@         set rval(summary_data,_ms,$type,tns)        0.0
#@         set rval(summary_data,_ms,$type,nvp)        0
#@         set rval(summary_data,_ms,$type,tns,line_number)        $line_number
#@         set rval(summary_data,_ms,$type,path_slack,line_number) $line_number
#@         set rval(summary_data,_ms,$type,nvp,line_number)        $line_number
#@       }
#@       if { [regexp {^No hold violations found} $line] } {
#@         set type hold
#@         set rval(summary_data,_ms,$type,path_slack) 0.0
#@         set rval(summary_data,_ms,$type,tns)        0.0
#@         set rval(summary_data,_ms,$type,nvp)        0
#@         set rval(summary_data,_ms,$type,tns,line_number)        $line_number
#@         set rval(summary_data,_ms,$type,path_slack,line_number) $line_number
#@         set rval(summary_data,_ms,$type,nvp,line_number)        $line_number
#@       }
#@ 
#@     }
#@ 
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Parse the report for design information.
#@   ## -------------------------------------
#@ 
#@   set rval(design_data,leaf_cell_count)     -1
#@   set rval(design_data,bufinv_cell_count)   -1
#@   set rval(design_data,ctbufinv_cell_count) -1
#@ 
#@   set rval(design_data,comb_cell_count)     -1
#@   set rval(design_data,seq_cell_count)      -1
#@   set rval(design_data,macro_cell_count)    -1
#@ 
#@   set rval(design_data,cell_area)           -1
#@   set rval(design_data,design_area)         -1
#@   set rval(design_data,net_length)          -1
#@ 
#@   set rval(design_data,net_count)           -1
#@   set rval(design_data,ldrc_total)          -1
#@   set rval(design_data,ldrc_trans)          -1
#@   set rval(design_data,ldrc_cap)            -1
#@ 
#@   ## -------------------------------------
#@ 
#@   set rval(design_data,leaf_cell_count,line_number)     1
#@   set rval(design_data,bufinv_cell_count,line_number)   1
#@   set rval(design_data,ctbufinv_cell_count,line_number) 1
#@ 
#@   set rval(design_data,comb_cell_count,line_number)     1
#@   set rval(design_data,seq_cell_count,line_number)      1
#@   set rval(design_data,macro_cell_count,line_number)    1
#@ 
#@   set rval(design_data,cell_area,line_number)           1
#@   set rval(design_data,design_area,line_number)         1
#@   set rval(design_data,net_length,line_number)          1
#@ 
#@   set rval(design_data,net_count,line_number)           1
#@   set rval(design_data,ldrc_total,line_number)          1
#@   set rval(design_data,ldrc_trans,line_number)          1
#@   set rval(design_data,ldrc_cap,line_number)            1
#@ 
#@   ## -------------------------------------
#@ 
#@   set line_number 0
#@   foreach line $lines {
#@     incr line_number
#@ 
#@     if { [regexp {Leaf Cell Count:\s+([\d\.]+)} $line match data] } {
#@       set rval(design_data,leaf_cell_count) $data
#@       set rval(design_data,leaf_cell_count,line_number) $line_number
#@     }
#@     if { [regexp {^\s*Buf/Inv Cell Count:\s+([\d\.]+)} $line match data] } {
#@       set rval(design_data,bufinv_cell_count) $data
#@       set rval(design_data,bufinv_cell_count,line_number) $line_number
#@     }
#@     if { [regexp {^\s*CT Buf/Inv Cell Count:\s+([\d\.]+)} $line match data] } {
#@       set rval(design_data,ctbufinv_cell_count) $data
#@       set rval(design_data,ctbufinv_cell_count,line_number) $line_number
#@     }
#@ 
#@     if { [regexp {Combinational Cell Count:\s+([\d\.]+)} $line match data] } {
#@       set rval(design_data,comb_cell_count) $data
#@       set rval(design_data,comb_cell_count,line_number) $line_number
#@     }
#@     if { [regexp {Sequential Cell Count:\s+([\d\.]+)} $line match data] } {
#@       set rval(design_data,seq_cell_count) $data
#@       set rval(design_data,seq_cell_count,line_number) $line_number
#@     }
#@     if { [regexp {Macro Count:\s+([\d\.]+)} $line match data] } {
#@       set rval(design_data,macro_cell_count) $data
#@       set rval(design_data,macro_cell_count,line_number) $line_number
#@     }
#@ 
#@     if { [regexp {Cell Area:\s+([\d\.]+)} $line match data] } {
#@       set rval(design_data,cell_area) $data
#@       set rval(design_data,cell_area,line_number) $line_number
#@     }
#@     if { [regexp {Design Area:\s+([\d\.]+)} $line match data] } {
#@       set rval(design_data,design_area) $data
#@       set rval(design_data,design_area,line_number) $line_number
#@     }
#@     if { [regexp {Net Length\s+:\s+([\d\.]+)} $line match data] } {
#@       set rval(design_data,net_length) $data
#@       set rval(design_data,net_length,line_number) $line_number
#@     }
#@ 
#@     if { [regexp {Total Number of Nets:\s+([\d\.]+)} $line match data] } {
#@       set rval(design_data,net_count) $data
#@       set rval(design_data,net_count,line_number) $line_number
#@     }
#@     if { [regexp {Nets With Violations:\s+([\d]+)} $line match data] } {
#@       set rval(design_data,ldrc_total) $data
#@       set rval(design_data,ldrc_total,line_number) $line_number
#@     }
#@     if { [regexp {Max Trans Violations:\s+([\d]+)} $line match data] } {
#@       set rval(design_data,ldrc_trans) $data
#@       set rval(design_data,ldrc_trans,line_number) $line_number
#@     }
#@     if { [regexp {Max Cap Violations:\s+([\d]+)} $line match data] } {
#@       set rval(design_data,ldrc_cap) $data
#@       set rval(design_data,ldrc_cap,line_number) $line_number
#@     }
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Return the parsed information
#@   ## -------------------------------------
#@ 
#@   sproc_pinfo -mode stop
#@   return [array get rval]
#@ }
#@ 
#@ define_proc_attributes sproc_metric_parse_report_qor   -info "Parses information for report_qor."   -define_args {    {-file "The report_qor file to parse." AString string required}
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_metric_parse_report_congestion:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_metric_parse_report_congestion { args } {
#@ 
#@   sproc_pinfo -mode start
#@ 
#@   global env SEV SVAR synopsys_program_name pt_shell_mode
#@ 
#@   set options(-file) ""
#@   parse_proc_arguments -args $args options
#@ 
#@   ## -------------------------------------
#@   ## Standard setup
#@   ## -------------------------------------
#@ 
#@   set rval(error_flag) 0
#@ 
#@   ## -------------------------------------
#@   ## Standard argument processing
#@   ## -------------------------------------
#@ 
#@   if { [file exists $options(-file)] } {
#@     sproc_msg -info "The specified report file is: '$options(-file)'"
#@   } else {
#@     sproc_msg -error "The specified report file does not exist: '$options(-file)'"
#@     set rval(error_flag) 1
#@     sproc_pinfo -mode stop
#@     return [array get rval]
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Read the report
#@   ## -------------------------------------
#@ 
#@   set fid [open $options(-file) r]
#@   set string_file [read $fid]
#@   close $fid
#@   set lines [split $string_file \n]
#@ 
#@   ## -------------------------------------
#@   ## Parse the report
#@   ## -------------------------------------
#@ 
#@   set rval(grc_overflow) undefined
#@ 
#@   foreach line $lines {
#@     regexp {Both Dirs: Overflow.*\(([\d\.]+)%\)} $line match rval(grc_overflow)
#@   }
#@ 
#@   if { $rval(grc_overflow) == "undefined" } {
#@     sproc_msg -error "Unable to parse value for 'Both Dirs: Overflow'"
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Return the parsed information
#@   ## -------------------------------------
#@ 
#@   sproc_pinfo -mode stop
#@   return [array get rval]
#@ }
#@ 
#@ define_proc_attributes sproc_metric_parse_report_congestion   -info "Parses information for report_congestion."   -define_args {    {-file "The report_congestion file to parse." AString string required}
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_metric_parse_report_threshold_voltage_group:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_metric_parse_report_threshold_voltage_group { args } {
#@ 
#@   sproc_pinfo -mode start
#@ 
#@   global env SEV SVAR synopsys_program_name pt_shell_mode
#@ 
#@   set options(-file) ""
#@   parse_proc_arguments -args $args options
#@ 
#@   ## -------------------------------------
#@   ## Standard setup
#@   ## -------------------------------------
#@ 
#@   set rval(error_flag) 0
#@ 
#@   ## -------------------------------------
#@   ## Standard argument processing
#@   ## -------------------------------------
#@ 
#@   if { [file exists $options(-file)] } {
#@     sproc_msg -info "The specified report file is: '$options(-file)'"
#@   } else {
#@     sproc_msg -error "The specified report file does not exist: '$options(-file)'"
#@     set rval(error_flag) 1
#@     sproc_pinfo -mode stop
#@     return [array get rval]
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Read the report
#@   ## -------------------------------------
#@ 
#@   set fid [open $options(-file) r]
#@   set string_file [read $fid]
#@   close $fid
#@   set lines [split $string_file \n]
#@ 
#@   ## -------------------------------------
#@   ## Parse the report
#@   ## -------------------------------------
#@ 
#@   set rval(vth,vth_names) [list]
#@   ## rval(cell_count,$vth_name)
#@   ## rval(cell_percentage,$vth_name)
#@ 
#@   set flag_name 0
#@   set flag_astr 0
#@ 
#@   set line_number 0
#@   foreach line $lines {
#@     incr line_number
#@ 
#@     if { [regexp {^Name} $line] } {
#@       incr flag_name
#@       continue
#@     }
#@ 
#@     if { $flag_name == 1 } {
#@       if { [regexp {^[\*\-]} $line] } {
#@         incr flag_astr
#@         continue
#@       }
#@     }
#@ 
#@     if { ($flag_name == 1) && ($flag_astr == 1) } {
#@       ## We are in the data section
#@       set parse 0
#@ 
#@       if { [llength $line] == 1 } {
#@         set save_line $line
#@       }
#@       if { [llength $line] == 6 } {
#@         set line "$save_line $line"
#@         set parse 1
#@       }
#@       if { [llength $line] == 7 } {
#@         set parse 1
#@       }
#@ 
#@       if { $parse } {
#@         regexp {^(\S+)\s+([\d\.]+)\s+\(([\d\.]+)\%\)} $line match vth_name cell_count cell_percentage
#@         lappend rval(vth,vth_names) $vth_name
#@         set rval(cell_count,$vth_name)                  $cell_count
#@         set rval(cell_percentage,$vth_name)             $cell_percentage
#@         set rval(cell_count,$vth_name,line_number)      $line_number
#@         set rval(cell_percentage,$vth_name,line_number) $line_number
#@       }
#@ 
#@     }
#@ 
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Return the parsed information
#@   ## -------------------------------------
#@ 
#@   sproc_pinfo -mode stop
#@   return [array get rval]
#@ }
#@ 
#@ define_proc_attributes sproc_metric_parse_report_threshold_voltage_group   -info "Parses information for report_threshold_voltage_group."   -define_args {    {-file "The report_threshold_voltage_group file to parse." AString string required}
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_metric_parse_report_design_physical:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_metric_parse_report_design_physical { args } {
#@ 
#@   sproc_pinfo -mode start
#@ 
#@   global env SEV SVAR synopsys_program_name pt_shell_mode
#@ 
#@   set options(-file) ""
#@   parse_proc_arguments -args $args options
#@ 
#@   ## -------------------------------------
#@   ## Standard setup
#@   ## -------------------------------------
#@ 
#@   set rval(error_flag) 0
#@ 
#@   ## -------------------------------------
#@   ## Standard argument processing
#@   ## -------------------------------------
#@ 
#@   if { [file exists $options(-file)] } {
#@     sproc_msg -info "The specified report file is: '$options(-file)'"
#@   } else {
#@     sproc_msg -error "The specified report file does not exist: '$options(-file)'"
#@     set rval(error_flag) 1
#@     sproc_pinfo -mode stop
#@     return [array get rval]
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Read the report
#@   ## -------------------------------------
#@ 
#@   set fid [open $options(-file) r]
#@   set string_file [read $fid]
#@   close $fid
#@   set lines [split $string_file \n]
#@ 
#@   ## -------------------------------------
#@   ## Parse the report
#@   ## -------------------------------------
#@ 
#@   set rval(cell2core_ratio)                -1
#@   set rval(chip_width)                     -1
#@   set rval(chip_height)                    -1
#@   set rval(chip_area)                      -1
#@   set rval(num_drc_errors)                 -1
#@   set rval(num_drc_errors_types)           -1
#@ 
#@   ## -------------------------------------
#@ 
#@   set rval(cell2core_ratio,line_number)      1
#@   set rval(chip_width,line_number)           1
#@   set rval(chip_height,line_number)          1
#@   set rval(chip_area,line_number)            1
#@   set rval(num_drc_errors,line_number)       1
#@   set rval(num_drc_errors_types,line_number) 1
#@ 
#@   ## -------------------------------------
#@ 
#@   set num_drc_errors_types -1
#@   set capture_error_types 0
#@ 
#@   set line_number 0
#@   foreach line $lines {
#@     incr line_number
#@ 
#@     if { [regexp {^Cell/Core Ratio\s+:\s+([\d\.]+)\%} $line match value] } {
#@       set rval(cell2core_ratio)             $value
#@       set rval(cell2core_ratio,line_number) $line_number
#@     }
#@ 
#@     if { [regexp {^Chip\s+([\d\.]+)\s+([\d\.]+)\s+([\d\.]+)} $line match value1 value2 value3] } {
#@       set rval(chip_width)              $value1
#@       set rval(chip_height)             $value2
#@       set rval(chip_area)               $value3
#@       set rval(chip_width,line_number)  $line_number
#@       set rval(chip_height,line_number) $line_number
#@       set rval(chip_area,line_number)   $line_number
#@     }
#@ 
#@     if { [regexp {^DRC information:\s*$} $line] } {
#@       set num_drc_errors_types 0
#@       set capture_error_types 1
#@       continue
#@     }
#@     if { $capture_error_types } {
#@       if { [regexp {^\s+Total error number:\s+([\d\.]+)} $line match data] } {
#@         set rval(num_drc_errors)                   $data
#@         set rval(num_drc_errors_types)             $num_drc_errors_types
#@         set rval(num_drc_errors,line_number)       $line_number
#@         set rval(num_drc_errors_types,line_number) $line_number
#@         set capture_error_types 0
#@         continue
#@       } else {
#@         incr num_drc_errors_types
#@       }
#@     }
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Return the parsed information
#@   ## -------------------------------------
#@ 
#@   sproc_pinfo -mode stop
#@   return [array get rval]
#@ }
#@ 
#@ define_proc_attributes sproc_metric_parse_report_design_physical   -info "Parses information for report_design_physical."   -define_args {    {-file "The report_design_physical file to parse." AString string required}
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_metric_parse_report_power:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_metric_parse_report_power { args } {
#@ 
#@   sproc_pinfo -mode start
#@ 
#@   global env SEV SVAR synopsys_program_name pt_shell_mode
#@ 
#@   set options(-file) ""
#@   set options(-scenario) ""
#@   parse_proc_arguments -args $args options
#@ 
#@   ## -------------------------------------
#@   ## Standard setup
#@   ## -------------------------------------
#@ 
#@   set rval(error_flag) 0
#@ 
#@   ## -------------------------------------
#@   ## Standard argument processing
#@   ## -------------------------------------
#@ 
#@   if { [file exists $options(-file)] } {
#@     sproc_msg -info "The specified report file is: '$options(-file)'"
#@   } else {
#@     sproc_msg -error "The specified report file does not exist: '$options(-file)'"
#@     set rval(error_flag) 1
#@     sproc_pinfo -mode stop
#@     return [array get rval]
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Read the report
#@   ## -------------------------------------
#@ 
#@   set fid [open $options(-file) r]
#@   set string_file [read $fid]
#@   close $fid
#@   set lines [split $string_file \n]
#@ 
#@   ## -------------------------------------
#@   ## Parse the report
#@   ## -------------------------------------
#@ 
#@   set rval(scenario_name_list) [list]
#@ 
#@   if { $options(-scenario) == "" } {
#@     set scenario_name None/non-MCMM
#@   } else {
#@     set scenario_name $options(-scenario)
#@   }
#@ 
#@   switch $synopsys_program_name {
#@ 
#@     dc_shell -
#@     icc_shell {
#@ 
#@       set line_number 0
#@       foreach line $lines {
#@         incr line_number
#@ 
#@         regexp {^Scenario\(s\):\s+(\S+)} $line match scenario_name
#@ 
#@         if { [scan $line "Total %s %s %s %s %s %s %s %s" m1 m2 m3 m4 m5 m6 m7 m8] == 8 } {
#@           set rval($scenario_name,internal_power)        $m1
#@           set rval($scenario_name,internal_power_units)  $m2
#@           set rval($scenario_name,switching_power)       $m3
#@           set rval($scenario_name,switching_power_units) $m4
#@           set rval($scenario_name,leakage_power)         $m5
#@           set rval($scenario_name,leakage_power_units)   $m6
#@           set rval($scenario_name,total_power)           $m7
#@           set rval($scenario_name,total_power_units)     $m8
#@ 
#@           set rval($scenario_name,internal_power,line_number)        $line_number
#@           set rval($scenario_name,internal_power_units,line_number)  $line_number
#@           set rval($scenario_name,switching_power,line_number)       $line_number
#@           set rval($scenario_name,switching_power_units,line_number) $line_number
#@           set rval($scenario_name,leakage_power,line_number)         $line_number
#@           set rval($scenario_name,leakage_power_units,line_number)   $line_number
#@           set rval($scenario_name,total_power,line_number)           $line_number
#@           set rval($scenario_name,total_power_units,line_number)     $line_number
#@ 
#@           lappend rval(scenario_name_list) $scenario_name
#@         }
#@       }
#@       set rval(scenario_name_list) [lsort -unique $rval(scenario_name_list)]
#@ 
#@     }
#@ 
#@     icc2_shell {
#@ 
#@       set line_number 0
#@       foreach line $lines {
#@         incr line_number
#@ 
#@         regexp {^Mode:\s+(\S+)} $line match mode_name
#@         regexp {^Corner:\s+(\S+)} $line match corner_name
#@ 
#@         if { [scan $line "Total %s %s %s %s" m1 m2 m3 m4] == 4 } {
#@           set scenario_name "${mode_name}.${corner_name}"
#@           set rval($scenario_name,leakage_power)         $m1
#@           set rval($scenario_name,leakage_power_units)   $m2
#@           set rval($scenario_name,total_power)           $m3
#@           set rval($scenario_name,total_power_units)     $m4
#@ 
#@           set rval($scenario_name,leakage_power,line_number)         $line_number
#@           set rval($scenario_name,leakage_power_units,line_number)   $line_number
#@           set rval($scenario_name,total_power,line_number)           $line_number
#@           set rval($scenario_name,total_power_units,line_number)     $line_number
#@ 
#@           lappend rval(scenario_name_list) $scenario_name
#@         }
#@       }
#@       set rval(scenario_name_list) [lsort -unique $rval(scenario_name_list)]
#@ 
#@     }
#@ 
#@     pt_shell {
#@ 
#@       set line_number 0
#@       foreach line $lines {
#@         incr line_number
#@ 
#@         regexp {^LYNX_SCENARIO:\s+(\S+)} $line match scenario_name
#@ 
#@         if { [regexp {^\s*Net Switching Power\s+=\s+(\S+)} $line match value] } {
#@           set rval($scenario_name,switching_power)                   $value
#@           set rval($scenario_name,switching_power_units)             W
#@ 
#@           set rval($scenario_name,switching_power,line_number)       $line_number
#@           set rval($scenario_name,switching_power_units,line_number) 1
#@         }
#@         if { [regexp {^\s*Cell Internal Power\s+=\s+(\S+)} $line match value] } {
#@           set rval($scenario_name,internal_power)                    $value
#@           set rval($scenario_name,internal_power_units)              W
#@ 
#@           set rval($scenario_name,internal_power,line_number)        $line_number
#@           set rval($scenario_name,internal_power_units,line_number)  1
#@         }
#@         if { [regexp {^\s*Cell Leakage Power\s+=\s+(\S+)} $line match value] } {
#@           set rval($scenario_name,leakage_power)                     $value
#@           set rval($scenario_name,leakage_power_units)               W
#@ 
#@           set rval($scenario_name,leakage_power,line_number)         $line_number
#@           set rval($scenario_name,leakage_power_units,line_number)   1
#@         }
#@         if { [regexp {^\s*Total Power\s+=\s+(\S+)} $line match value] } {
#@           set rval($scenario_name,total_power)                       $value
#@           set rval($scenario_name,total_power_units)                 W
#@ 
#@           set rval($scenario_name,total_power,line_number)           $line_number
#@           set rval($scenario_name,total_power_units,line_number)     1
#@ 
#@           lappend rval(scenario_name_list) $scenario_name
#@         }
#@       }
#@       set rval(scenario_name_list) [lsort -unique $rval(scenario_name_list)]
#@ 
#@     }
#@ 
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Return the parsed information
#@   ## -------------------------------------
#@ 
#@   sproc_pinfo -mode stop
#@   return [array get rval]
#@ }
#@ 
#@ define_proc_attributes sproc_metric_parse_report_power   -info "Parses information for report_power."   -define_args {    {-file "The report_power file to parse." AString string required}
#@   {-scenario "The scenario name." AString string optional}
#@ }
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_metric_parse_report_timing:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_metric_parse_report_timing { args } {
#@ 
#@   sproc_pinfo -mode start
#@ 
#@   global env SEV SVAR synopsys_program_name pt_shell_mode
#@ 
#@   set options(-file) ""
#@   set options(-scenario) ""
#@   parse_proc_arguments -args $args options
#@ 
#@   ## -------------------------------------
#@   ## Standard setup
#@   ## -------------------------------------
#@ 
#@   set rval(error_flag) 0
#@   set rval(path_items) [list]
#@ 
#@   ## -------------------------------------
#@   ## Standard argument processing
#@   ## -------------------------------------
#@ 
#@   if { [file exists $options(-file)] } {
#@     sproc_msg -info "The specified report file is: '$options(-file)'"
#@   } else {
#@     sproc_msg -error "The specified report file does not exist: '$options(-file)'"
#@     set rval(error_flag) 1
#@     sproc_pinfo -mode stop
#@     return [array get rval]
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Read the report
#@   ## -------------------------------------
#@ 
#@   set fid [open $options(-file) r]
#@   set string_file [read $fid]
#@   close $fid
#@   set lines [split $string_file \n]
#@ 
#@   ## -------------------------------------
#@   ## Parse the report
#@   ## -------------------------------------
#@ 
#@   if { $options(-scenario) == "" } {
#@     set scenario_name None/non-MCMM
#@   } else {
#@     set scenario_name $options(-scenario)
#@   }
#@ 
#@   set line_number 0
#@   foreach line $lines {
#@     incr line_number
#@ 
#@     regexp {^\s+Startpoint:\s+(\S+)} $line match start_point
#@     regexp {^\s+Endpoint:\s+(\S+)}   $line match end_point
#@     regexp {^\s+Scenario:\s+(\S+)}   $line match scenario_name
#@     regexp {^\s+Path Group:\s+(\S+)} $line match path_group
#@     regexp {^\s+Path Type:\s+(\S+)}  $line match path_type
#@     if { [regexp {^\s+slack\s+\(\S+\)\s+([\d\.\-]+)} $line match value] } {
#@       set slack $value
#@       set line $line_number
#@       set path_item "$scenario_name $start_point $end_point $path_group $path_type $slack $line"
#@       lappend rval(path_items) $path_item
#@     }
#@ 
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Return the parsed information
#@   ## -------------------------------------
#@ 
#@   sproc_pinfo -mode stop
#@   return [array get rval]
#@ }
#@ 
#@ define_proc_attributes sproc_metric_parse_report_timing   -info "Parses information for report_timing."   -define_args {    {-file     "The report_units file to parse." AString string required}
#@   {-scenario "The scenario name." AString string optional}
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_qv_report_units:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_qv_report_units { args } {
#@ 
#@   sproc_pinfo -mode start
#@ 
#@   global env SEV SVAR
#@ 
#@   set options(-file) ""
#@   set options(-output) ""
#@   set options(-attributes) ""
#@   parse_proc_arguments -args $args options
#@ 
#@   if { ![file exists $options(-file)] } {
#@     sproc_msg -error "The argument for -file does not exist: '$options(-file)'"
#@     sproc_pinfo -mode stop
#@     return
#@   } else {
#@     array set units [sproc_metric_parse_report_units -file $options(-file)]
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Start output
#@   ## -------------------------------------
#@ 
#@   set output [list]
#@   lappend output "{"
#@ 
#@     ## -------------------------------------
#@     ## Process attributes
#@     ## -------------------------------------
#@ 
#@     foreach attribute $options(-attributes) {
#@       set name  [lindex $attribute 0]
#@       set value [lindex $attribute 1]
#@       lappend output "\"$name\": \"$value\""
#@     }
#@ 
#@     ## -------------------------------------
#@     ## Process units
#@     ## -------------------------------------
#@ 
#@     lappend output "\"Time_unit\": \"$units(text_time)\""
#@     lappend output "\"Capacitive_load_unit\": \"$units(text_capacitance)\""
#@     lappend output "\"Resistance_unit\": \"$units(text_resistance)\""
#@     lappend output "\"Voltage_unit\": \"$units(text_voltage)\""
#@     lappend output "\"Power_unit\": \"$units(text_power)\""
#@     lappend output "\"Current_unit\": \"$units(text_current)\""
#@ 
#@     ## -------------------------------------
#@     ## Complete output & create file
#@     ## -------------------------------------
#@ 
#@   lappend output "}"
#@ 
#@   set output [sproc_qv_add_commas -lines $output]
#@   set output [join $output "\n"]
#@ 
#@   set fid [open $options(-output) w]
#@   puts $fid $output
#@   close $fid
#@ 
#@   sproc_pinfo -mode stop
#@ }
#@ 
#@ define_proc_attributes sproc_qv_report_units   -info "Proc that parses report_units reports and returns metrics in JSON."   -define_args {
#@   {-file        "File name for the report." AString string required}
#@   {-output      "Output file." AString string required}
#@   {-attributes  "Attribute pairs to write to file" AString string required}
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_metric_atpg:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_metric_atpg { args } {
#@ 
#@   sproc_pinfo -mode start
#@ 
#@   global env SEV SVAR synopsys_program_name pt_shell_mode
#@ 
#@   if { ( $SEV(metrics_enable_generation) == 0 ) } {
#@     sproc_msg -warning "Metrics are disabled per SEV(metrics_enable_generation)"
#@     sproc_pinfo -mode stop
#@     return
#@   }
#@ 
#@   parse_proc_arguments -args $args options
#@ 
#@   ## -------------------------------------
#@   ## Set default values
#@   ## -------------------------------------
#@ 
#@   set total_faults NaM
#@   set test_coverage NaM
#@   set fault_coverage 0
#@   set atpg_effectiveness 0
#@ 
#@   ## -------------------------------------
#@   ## Read the report
#@   ## -------------------------------------
#@ 
#@   set fname $SEV(rpt_dir)/tmax_rm.report_summaries
#@ 
#@   set fid [open $fname r]
#@   set string_file [read $fid]
#@   close $fid
#@   set lines [split $string_file \n]
#@ 
#@   ## -------------------------------------
#@   ## Parse the report
#@   ## -------------------------------------
#@ 
#@   set fault_types "Iddq Transition Path_delay Bridging Dynamic_bridging Hold_time IDDQ_bridging"
#@ 
#@   foreach fault_type $fault_types {
#@     set ${fault_type}_faults "NaM"
#@     set ${fault_type}_coverage "NaM"
#@   }
#@ 
#@   foreach line $lines {
#@     foreach fault_type $fault_types {
#@       regexp "$fault_type\\s+\(\[\\.\\d\]+\)\\s+\(\[\\.\\d\]+\)\\%" $line matchVar ${fault_type}_faults ${fault_type}_coverage
#@       regexp {total faults\s+([\d]+)} $line matchVar total_faults
#@       regexp {test coverage\s+([\.\d]+)\%} $line matchVar fault_coverage
#@     }
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Generate metrics
#@   ## -------------------------------------
#@ 
#@   sproc_msg -info "METRIC | INTEGER ATPG.TRANSITION.FAULTS         | $Transition_faults"
#@   sproc_msg -info "METRIC | DOUBLE  ATPG.TRANSITION.COVERAGE       | $Transition_coverage"
#@   sproc_msg -info "METRIC | INTEGER ATPG.BRIDGING.FAULTS           | $Bridging_faults"
#@   sproc_msg -info "METRIC | DOUBLE  ATPG.BRIDGING.COVERAGE         | $Bridging_coverage"
#@   sproc_msg -info "METRIC | INTEGER ATPG.HOLD_TIME.FAULTS          | $Hold_time_faults"
#@   sproc_msg -info "METRIC | DOUBLE  ATPG.HOLD_TIME.COVERAGE        | $Hold_time_coverage"
#@   sproc_msg -info "METRIC | INTEGER ATPG.IDDQ_BRIDGING.FAULTS      | $IDDQ_bridging_faults"
#@   sproc_msg -info "METRIC | DOUBLE  ATPG.IDDQ_BRIDGING.COVERAGE    | $IDDQ_bridging_coverage"
#@   sproc_msg -info "METRIC | INTEGER ATPG.IDDQ.FAULTS               | $Iddq_faults"
#@   sproc_msg -info "METRIC | DOUBLE  ATPG.IDDQ.COVERAGE             | $Iddq_coverage"
#@   sproc_msg -info "METRIC | INTEGER ATPG.PATH_DELAY.FAULTS         | $Path_delay_faults"
#@   sproc_msg -info "METRIC | DOUBLE  ATPG.PATH_DELAY.COVERAGE       | $Path_delay_coverage"
#@   sproc_msg -info "METRIC | INTEGER ATPG.DYNAMIC_BRIDGING.FAULTS   | $Dynamic_bridging_faults"
#@   sproc_msg -info "METRIC | DOUBLE  ATPG.DYNAMIC_BRIDGING.COVERAGE | $Dynamic_bridging_coverage"
#@   sproc_msg -info "METRIC | INTEGER ATPG.STUCK_AT.FAULTS   | $total_faults"
#@   sproc_msg -info "METRIC | DOUBLE  ATPG.STUCK_AT.COVERAGE | $fault_coverage"
#@ 
#@   sproc_pinfo -mode stop
#@ }
#@ 
#@ define_proc_attributes sproc_metric_atpg   -info "Gathers ATPG information for metrics reporting."   -define_args {
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_metric_main:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_metric_main { args } {
#@ 
#@   sproc_pinfo -mode start
#@ 
#@   global env SEV SVAR synopsys_program_name pt_shell_mode
#@   global TEV SNPS_time_start
#@ 
#@   set options(-scenario_name) ""
#@   set options(-metrics_sta) 0
#@   set options(-metrics_power) 0
#@   set options(-metrics_design) 0
#@   set options(-metrics_cts) 0
#@   set options(-report_qor) ""
#@   set options(-report_units) ""
#@   set options(-report_power) ""
#@   set options(-report_congestion) ""
#@   set options(-report_design_physical) ""
#@   set options(-report_threshold_voltage_group) ""
#@   set options(-report_clock_tree) ""
#@   parse_proc_arguments -args $args options
#@ 
#@   ## -------------------------------------
#@   ## If reporting is turned off, then metrics are disabled as well.
#@   ## -------------------------------------
#@ 
#@   if { [regexp -nocase {NONE} $TEV(report_level)] || ($SEV(metrics_enable_generation) == 0) } {
#@     sproc_msg -warning "Metrics are disabled per TEV(report_level) or SEV(metrics_enable_generation)"
#@     sproc_pinfo -mode stop
#@     return
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Determine the file names for reports
#@   ## -------------------------------------
#@ 
#@   if { $synopsys_program_name == "pt_shell" } {
#@     if { ($pt_shell_mode == "primetime") && ($options(-scenario_name) == "") } {
#@       sproc_msg -error "You must specify a scenario name using the -scenario_name argument."
#@     }
#@     switch $pt_shell_mode {
#@       primetime {
#@         if { $options(-report_qor) == "" } {
#@           set options(-report_qor) $SEV(rpt_dir)/pt.$options(-scenario_name).report_qor
#@         }
#@         if { $options(-report_units) == "" } {
#@           set options(-report_units) $SEV(rpt_dir)/pt.$options(-scenario_name).report_units
#@         }
#@         if { $options(-report_power) == "" } {
#@           set options(-report_power) $SEV(rpt_dir)/pt.$options(-scenario_name).report_power
#@         }
#@       }
#@       primetime_master {
#@         if { $options(-report_qor) == "" } {
#@           set options(-report_qor) $SEV(rpt_dir)/pt_concat.report_qor
#@         }
#@         if { $options(-report_units) == "" } {
#@           set options(-report_units) $SEV(rpt_dir)/pt_concat.report_units
#@         }
#@         if { $options(-report_power) == "" } {
#@           set options(-report_power) $SEV(rpt_dir)/pt_concat.report_power
#@         }
#@       }
#@     }
#@   } elseif { $synopsys_program_name == "icc_shell" } {
#@     if { $options(-report_qor) == "" } {
#@       set options(-report_qor) $SEV(rpt_dir)/icc.report_qor
#@     }
#@     if { $options(-report_units) == "" } {
#@       set options(-report_units) $SEV(rpt_dir)/icc.report_units
#@     }
#@     if { $options(-report_power) == "" } {
#@       set options(-report_power) $SEV(rpt_dir)/icc.report_power
#@     }
#@     if { $options(-report_congestion) == "" } {
#@       set options(-report_congestion) $SEV(rpt_dir)/icc.report_congestion
#@     }
#@     if { $options(-report_threshold_voltage_group) == "" } {
#@       set options(-report_threshold_voltage_group) $SEV(rpt_dir)/icc.report_threshold_voltage_group
#@     }
#@     if { $options(-report_design_physical) == "" } {
#@       set options(-report_design_physical) $SEV(rpt_dir)/icc.report_design_physical
#@     }
#@     if { $options(-report_clock_tree) == "" } {
#@       set options(-report_clock_tree) $SEV(rpt_dir)/icc.cts.report_clock_tree
#@     }
#@   } elseif { $synopsys_program_name == "dc_shell" } {
#@     if { $options(-report_qor) == "" } {
#@       set options(-report_qor) $SEV(rpt_dir)/dc.report_qor
#@     }
#@     if { $options(-report_units) == "" } {
#@       set options(-report_units) $SEV(rpt_dir)/dc.report_units
#@     }
#@     if { $options(-report_power) == "" } {
#@       set options(-report_power) $SEV(rpt_dir)/dc.report_power
#@     }
#@     if { $options(-report_congestion) == "" } {
#@       if {![shell_is_in_exploration_mode]} {
#@         set options(-report_congestion) $SEV(rpt_dir)/dc.report_congestion
#@       }
#@     }
#@     if { $options(-report_threshold_voltage_group) == "" } {
#@       set options(-report_threshold_voltage_group) $SEV(rpt_dir)/dc.report_threshold_voltage_group
#@     }
#@   } elseif { $synopsys_program_name == "icc2_shell" } {
#@     if { $options(-report_qor) == "" } {
#@       set options(-report_qor) $SEV(rpt_dir)/icc2.report_qor
#@     }
#@     if { $options(-report_power) == "" } {
#@       set options(-report_power) $SEV(rpt_dir)/icc2.report_power
#@     }
#@     if { $options(-report_units) == "" } {
#@       set options(-report_units) $SEV(rpt_dir)/icc2.report_user_units
#@     }
#@     if { $options(-report_threshold_voltage_group) == "" } {
#@       set options(-report_threshold_voltage_group) $SEV(rpt_dir)/icc2.report_threshold_voltage_group
#@     }
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Determine the list of reports that are needed.
#@   ## -------------------------------------
#@ 
#@   set report_type_list [list     -report_qor     -report_units     -report_power     -report_congestion     -report_design_physical     -report_threshold_voltage_group     -report_clock_tree     ]
#@ 
#@   foreach report_type $report_type_list {
#@     set required($report_type) 0
#@   }
#@ 
#@   if { $options(-metrics_sta) } {
#@     set required(-report_qor) 1
#@     set required(-report_units) 1
#@   }
#@ 
#@   if { $options(-metrics_power) } {
#@     set required(-report_power) 1
#@   }
#@ 
#@   if { $options(-metrics_design) } {
#@     set required(-report_qor) 1
#@     set required(-report_threshold_voltage_group) 1
#@     if { [file exists $options(-report_congestion)] } {
#@       set required(-report_congestion) 1
#@     }
#@     if { $synopsys_program_name == "icc_shell" } {
#@       set required(-report_design_physical) 1
#@     }
#@   }
#@ 
#@   if { $options(-metrics_cts) } {
#@     set required(-report_clock_tree) 1
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Check that reports are available
#@   ## -------------------------------------
#@ 
#@   set error 0
#@   foreach report_type $report_type_list {
#@     if { $required($report_type) } {
#@       if { ![file exists $options($report_type)] } {
#@         set error 1
#@         if { $SEV(metrics_flag_errors) } {
#@           sproc_msg -error   "The file specified by '$report_type' does not exist: '$options($report_type)'"
#@         } else {
#@           sproc_msg -warning "The file specified by '$report_type' does not exist: '$options($report_type)'"
#@         }
#@       }
#@     }
#@   }
#@ 
#@   if { $error } {
#@     sproc_pinfo -mode stop
#@     return
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Parse the reports
#@   ## -------------------------------------
#@ 
#@   foreach report_type $report_type_list {
#@     if { $required($report_type) } {
#@       switch -- $report_type {
#@         -report_qor                     { array set qor   [sproc_metric_parse_report_qor                     -file $options(-report_qor)] }
#@         -report_units                   { array set units [sproc_metric_parse_report_units                   -file $options(-report_units)] }
#@         -report_power                   { array set power [sproc_metric_parse_report_power                   -file $options(-report_power)] }
#@         -report_congestion              { array set cong  [sproc_metric_parse_report_congestion              -file $options(-report_congestion)] }
#@         -report_design_physical         { array set phy   [sproc_metric_parse_report_design_physical         -file $options(-report_design_physical)] }
#@         -report_threshold_voltage_group { array set vth   [sproc_metric_parse_report_threshold_voltage_group -file $options(-report_threshold_voltage_group)] }
#@         -report_clock_tree              { array set cts   [sproc_metric_parse_report_clock_tree              -file $options(-report_clock_tree)] }
#@       }
#@     }
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Generate outputs
#@   ## -------------------------------------
#@ 
#@   if { $options(-metrics_sta) } {
#@ 
#@     ## -------------------------------------
#@     ## This code is for generation of path group metrics (setup)
#@     ## -------------------------------------
#@ 
#@     set ignore_list $SVAR(metrics,path_group_ignore_list_setup)
#@ 
#@     set path_group_setup_item_list [list]
#@ 
#@     foreach scenario_name $qor(path_group_data,scenario_name_list) {
#@       foreach path_group_name $qor(path_group_data,path_group_name_list,$scenario_name) {
#@         set item [list           $qor(path_group_data,$scenario_name,$path_group_name,setup,path_slack)           $path_group_name           $scenario_name           $qor(path_group_data,$scenario_name,$path_group_name,setup,path_length)           $qor(path_group_data,$scenario_name,$path_group_name,setup,path_period)           ]
#@         set valid 1
#@         if { ![string is double -strict $qor(path_group_data,$scenario_name,$path_group_name,setup,path_slack)] ||             ![string is double -strict $qor(path_group_data,$scenario_name,$path_group_name,setup,path_length)] ||             ![string is double -strict $qor(path_group_data,$scenario_name,$path_group_name,setup,path_period)]           } {
#@           set valid 0
#@         }
#@         if { $valid } {
#@           lappend path_group_setup_item_list $item
#@         }
#@       }
#@     }
#@ 
#@     set item_list [lsort -index 0 -increasing -real $path_group_setup_item_list]
#@     set item_list_length [llength $item_list]
#@ 
#@     set index_count 0
#@     set metric_count 0
#@ 
#@     while { $metric_count < $SVAR(metrics,max_path_group_count) } {
#@ 
#@       if { $index_count < $item_list_length } {
#@         set item [lindex $item_list $index_count]
#@         set path_slack      [lindex $item 0]
#@         set path_group_name [lindex $item 1]
#@         set scenario_name   [lindex $item 2]
#@         set path_length     [lindex $item 3]
#@         set path_period     [lindex $item 4]
#@ 
#@         set adj_path_slack [sproc_metric_normalize -value $path_slack -current_unit $units(time_unit)]
#@ 
#@         if { [string is double -strict $path_length] && ($path_length != 0) } {
#@           set adj_path_length [sproc_metric_normalize -value $path_length -current_unit $units(time_unit)]
#@           set freq_actual [expr 1.0 / ( $adj_path_length / 1000000000000.0 )]
#@         } else {
#@           set freq_actual NaM
#@         }
#@ 
#@         if { [string is double -strict $path_period] && ($path_period != 0) } {
#@           set adj_path_period [sproc_metric_normalize -value $path_period -current_unit $units(time_unit)]
#@           set freq_target [expr 1.0 / ( $adj_path_period / 1000000000000.0 )]
#@         } else {
#@           set freq_target NaM
#@         }
#@ 
#@         set ignore_flag 0
#@         foreach pattern $ignore_list {
#@           if { [string match $pattern $path_group_name] } {
#@             set ignore_flag 1
#@           }
#@         }
#@         if { $ignore_flag } {
#@           incr index_count
#@           continue
#@         }
#@       } else {
#@         set path_slack      NaM
#@         set path_group_name NaM
#@         set scenario_name   NaM
#@         set freq_actual     NaM
#@         set freq_target     NaM
#@         set adj_path_slack  NaM
#@       }
#@ 
#@       ## set path_group_name_displayed [sproc_metric_clean_string -string $path_group_name]
#@       set path_group_name_displayed $path_group_name
#@ 
#@       sproc_msg -info "METRIC | DOUBLE STA.SETUP_$metric_count.SLACK                  | $adj_path_slack"
#@       sproc_msg -info "METRIC | STRING STA.SETUP_$metric_count.PATH_GROUP             | $path_group_name_displayed"
#@       sproc_msg -info "METRIC | STRING STA.SETUP_$metric_count.SCENARIO               | $scenario_name"
#@       sproc_msg -info "METRIC | STRING STA.SETUP_$metric_count.CALCULATED_FREQ_ACTUAL | $freq_actual"
#@       sproc_msg -info "METRIC | STRING STA.SETUP_$metric_count.CALCULATED_FREQ_TARGET | $freq_target"
#@       incr index_count
#@       incr metric_count
#@ 
#@     }
#@ 
#@     ## -------------------------------------
#@     ## This code is for generation of path group metrics (hold)
#@     ## -------------------------------------
#@ 
#@     set ignore_list $SVAR(metrics,path_group_ignore_list_hold)
#@ 
#@     set path_group_hold_item_list [list]
#@     foreach scenario_name $qor(path_group_data,scenario_name_list) {
#@       foreach path_group_name $qor(path_group_data,path_group_name_list,$scenario_name) {
#@         set item [list           $qor(path_group_data,$scenario_name,$path_group_name,hold,path_slack)           $path_group_name           $scenario_name           ]
#@         set valid 1
#@         if { ![string is double -strict $qor(path_group_data,$scenario_name,$path_group_name,hold,path_slack)] } {
#@           set valid 0
#@         }
#@         if { $valid } {
#@           lappend path_group_hold_item_list $item
#@         }
#@       }
#@     }
#@ 
#@     set item_list [lsort -index 0 -increasing -real $path_group_hold_item_list]
#@     set item_list_length [llength $item_list]
#@ 
#@     set index_count 0
#@     set metric_count 0
#@ 
#@     while { $metric_count < $SVAR(metrics,max_path_group_count) } {
#@ 
#@       if { $index_count < $item_list_length } {
#@         set item [lindex $item_list $index_count]
#@         set path_slack      [lindex $item 0]
#@         set path_group_name [lindex $item 1]
#@         set scenario_name   [lindex $item 2]
#@ 
#@         set adj_path_slack [sproc_metric_normalize -value $path_slack -current_unit $units(time_unit)]
#@ 
#@         set ignore_flag 0
#@         foreach pattern $ignore_list {
#@           if { [string match $pattern $path_group_name] } {
#@             set ignore_flag 1
#@           }
#@         }
#@         if { $ignore_flag } {
#@           incr index_count
#@           continue
#@         }
#@       } else {
#@         set path_slack      NaM
#@         set path_group_name NaM
#@         set scenario_name   NaM
#@         set adj_path_slack  NaM
#@       }
#@ 
#@       ## set path_group_name_displayed [sproc_metric_clean_string -string $path_group_name]
#@       set path_group_name_displayed $path_group_name
#@ 
#@       sproc_msg -info "METRIC | DOUBLE STA.HOLD_$metric_count.SLACK                  | $adj_path_slack"
#@       sproc_msg -info "METRIC | STRING STA.HOLD_$metric_count.PATH_GROUP             | $path_group_name_displayed"
#@       sproc_msg -info "METRIC | STRING STA.HOLD_$metric_count.SCENARIO               | $scenario_name"
#@       incr index_count
#@       incr metric_count
#@ 
#@     }
#@ 
#@     ## -------------------------------------
#@     ## This code is for generation of summary metrics
#@     ## -------------------------------------
#@ 
#@     foreach scenario_name $qor(summary_data,_ss,scenario_name_list) {
#@       set scenario_name_displayed [sproc_metric_clean_string -string $scenario_name]
#@       if { $qor(summary_data,_ss,$scenario_name,setup,path_slack) != "" } {
#@         set path_slack  [sproc_metric_normalize -value $qor(summary_data,_ss,$scenario_name,setup,path_slack) -current_unit $units(time_unit)]
#@         set tns         [sproc_metric_normalize -value $qor(summary_data,_ss,$scenario_name,setup,tns) -current_unit $units(time_unit)]
#@         set nvp                                        $qor(summary_data,_ss,$scenario_name,setup,nvp)
#@         sproc_msg -info "METRIC | DOUBLE STA.WNS_MAX.SCENARIO.$scenario_name_displayed  | $path_slack"
#@         sproc_msg -info "METRIC | DOUBLE STA.TNS_MAX.SCENARIO.$scenario_name_displayed  | $tns"
#@         sproc_msg -info "METRIC | INTEGER STA.NVP_MAX.SCENARIO.$scenario_name_displayed | $nvp"
#@       }
#@       if { [info exists qor(summary_data,_ss,$scenario_name,hold,path_slack)] } {
#@         if { $qor(summary_data,_ss,$scenario_name,hold,path_slack) != "" } {
#@           set path_slack  [sproc_metric_normalize -value $qor(summary_data,_ss,$scenario_name,hold,path_slack) -current_unit $units(time_unit)]
#@           set tns         [sproc_metric_normalize -value $qor(summary_data,_ss,$scenario_name,hold,tns) -current_unit $units(time_unit)]
#@           set nvp                                        $qor(summary_data,_ss,$scenario_name,hold,nvp)
#@           sproc_msg -info "METRIC | DOUBLE STA.WNS_MIN.SCENARIO.$scenario_name_displayed  | $path_slack"
#@           sproc_msg -info "METRIC | DOUBLE STA.TNS_MIN.SCENARIO.$scenario_name_displayed  | $tns"
#@           sproc_msg -info "METRIC | INTEGER STA.NVP_MIN.SCENARIO.$scenario_name_displayed | $nvp"
#@         }
#@       }
#@     }
#@ 
#@     if { [info exists qor(summary_data,_ms,setup,path_slack)] } {
#@       set path_slack  [sproc_metric_normalize -value $qor(summary_data,_ms,setup,path_slack) -current_unit $units(time_unit)]
#@       set tns         [sproc_metric_normalize -value $qor(summary_data,_ms,setup,tns) -current_unit $units(time_unit)]
#@       set nvp                                        $qor(summary_data,_ms,setup,nvp)
#@       sproc_msg -info "METRIC | DOUBLE STA.WNS_MAX.COMPOSITE  | $path_slack"
#@       sproc_msg -info "METRIC | DOUBLE STA.TNS_MAX.COMPOSITE  | $tns"
#@       sproc_msg -info "METRIC | INTEGER STA.NVP_MAX.COMPOSITE | $nvp"
#@     }
#@     if { [info exists qor(summary_data,_ms,hold,path_slack)] } {
#@       set path_slack  [sproc_metric_normalize -value $qor(summary_data,_ms,hold,path_slack) -current_unit $units(time_unit)]
#@       set tns         [sproc_metric_normalize -value $qor(summary_data,_ms,hold,tns) -current_unit $units(time_unit)]
#@       set nvp                                        $qor(summary_data,_ms,hold,nvp)
#@       sproc_msg -info "METRIC | DOUBLE STA.WNS_MIN.COMPOSITE  | $path_slack"
#@       sproc_msg -info "METRIC | DOUBLE STA.TNS_MIN.COMPOSITE  | $tns"
#@       sproc_msg -info "METRIC | INTEGER STA.NVP_MIN.COMPOSITE | $nvp"
#@     }
#@ 
#@     ## -------------------------------------
#@     ## This code is for generation of all path group metrics
#@     ## By default this code is disabled to prevent generation
#@     ## of an extemely large number of metrics for some designs.
#@     ## -------------------------------------
#@ 
#@     if {1} {
#@       foreach scenario_name $qor(path_group_data,scenario_name_list) {
#@         foreach path_group_name $qor(path_group_data,path_group_name_list,$scenario_name) {
#@ 
#@           set path_group_name_displayed [sproc_metric_clean_string -string $path_group_name]
#@           set scenario_name_displayed   [sproc_metric_clean_string -string $scenario_name]
#@           set metric_name $path_group_name_displayed.$scenario_name_displayed
#@ 
#@           set data $qor(path_group_data,$scenario_name,$path_group_name,setup,logic_levels)
#@           if { $data != "NA" } {
#@             set value [expr int($data)]
#@             sproc_msg -info "METRIC | INTEGER STA.LOGIC_LEVELS_MAX.$metric_name | $value"
#@           }
#@ 
#@           set data $qor(path_group_data,$scenario_name,$path_group_name,setup,path_slack)
#@           if { $data != "NA" } {
#@             set value [sproc_metric_normalize -value $data -current_unit $units(time_unit)]
#@             sproc_msg -info "METRIC | DOUBLE STA.WNS_MAX.$metric_name | $value"
#@           }
#@ 
#@           set data $qor(path_group_data,$scenario_name,$path_group_name,hold,path_slack)
#@           if { $data != "NA" } {
#@             set value [sproc_metric_normalize -value $data -current_unit $units(time_unit)]
#@             sproc_msg -info "METRIC | DOUBLE STA.WNS_MIN.$metric_name | $value"
#@           }
#@ 
#@           set data $qor(path_group_data,$scenario_name,$path_group_name,setup,tns)
#@           if { $data != "NA" } {
#@             set value [sproc_metric_normalize -value $data -current_unit $units(time_unit)]
#@             sproc_msg -info "METRIC | DOUBLE STA.TNS_MAX.$metric_name | $value"
#@           }
#@ 
#@           set data $qor(path_group_data,$scenario_name,$path_group_name,hold,tns)
#@           if { $data != "NA" } {
#@             set value [sproc_metric_normalize -value $data -current_unit $units(time_unit)]
#@             sproc_msg -info "METRIC | DOUBLE STA.TNS_MIN.$metric_name | $value"
#@           }
#@ 
#@           set data $qor(path_group_data,$scenario_name,$path_group_name,setup,nvp)
#@           if { $data != "NA" } {
#@             set value [expr int($data)]
#@             sproc_msg -info "METRIC | INTEGER STA.NVP_MAX.$metric_name | $value"
#@           }
#@ 
#@           set data $qor(path_group_data,$scenario_name,$path_group_name,hold,nvp)
#@           if { $data != "NA" } {
#@             set value [expr int($data)]
#@             sproc_msg -info "METRIC | INTEGER STA.NVP_MIN.$metric_name | $value"
#@           }
#@         }
#@       }
#@     }
#@ 
#@   }
#@ 
#@   if { $options(-metrics_power) } {
#@ 
#@     foreach scenario_name $power(scenario_name_list) {
#@ 
#@       if { [string is double -strict $power($scenario_name,total_power)] } {
#@         set total_power   [sproc_metric_normalize -value $power($scenario_name,total_power)   -current_unit $power($scenario_name,total_power_units)]
#@       } else {
#@         set total_power   NaM
#@       }
#@       if { [string is double -strict $power($scenario_name,leakage_power)] } {
#@         set leakage_power [sproc_metric_normalize -value $power($scenario_name,leakage_power) -current_unit $power($scenario_name,leakage_power_units)]
#@       } else {
#@         set leakage_power NaM
#@       }
#@ 
#@       if { $scenario_name == "None/non-MCMM" } {
#@         if { $synopsys_program_name == "pt_shell" } {
#@           if { $pt_shell_mode == "primetime" } {
#@             set scenario_name $options(-scenario_name)
#@           }
#@         }
#@       }
#@       set scenario_name_displayed [sproc_metric_clean_string -string $scenario_name]
#@ 
#@       sproc_msg -info "METRIC | DOUBLE PWR.TOTAL.$scenario_name_displayed   | $total_power"
#@       sproc_msg -info "METRIC | DOUBLE PWR.LEAKAGE.$scenario_name_displayed | $leakage_power"
#@ 
#@     }
#@ 
#@   }
#@ 
#@   if { $options(-metrics_design) } {
#@ 
#@     ## From report_threshold_voltage_group
#@ 
#@     foreach vth_name $vth(vth,vth_names) {
#@       sproc_msg -info "METRIC | INTEGER PWR.VTH_NUM_CELLS.$vth_name     | $vth(cell_count,$vth_name)"
#@       sproc_msg -info "METRIC | PERCENT PWR.VTH_PERCENT_CELLS.$vth_name | $vth(cell_percentage,$vth_name)"
#@     }
#@ 
#@     ## From report_congestion
#@ 
#@     if { [info exists cong(error_flag)] } {
#@       sproc_msg -info "METRIC | PERCENT PHYSICAL.CONGESTION | $cong(grc_overflow)"
#@     }
#@ 
#@     ## From report_qor
#@ 
#@     sproc_msg -info "METRIC | DOUBLE  LOGICAL.CELL_AREA     | $qor(design_data,cell_area)"
#@     sproc_msg -info "METRIC | INTEGER LOGICAL.NUM_INSTS     | $qor(design_data,leaf_cell_count)"
#@     sproc_msg -info "METRIC | INTEGER LOGICAL.NUM_MACROS    | $qor(design_data,macro_cell_count)"
#@     sproc_msg -info "METRIC | INTEGER LOGICAL.NUM_FLIPFLOPS | $qor(design_data,seq_cell_count)"
#@     sproc_msg -info "METRIC | INTEGER LOGICAL.NUM_NETS      | $qor(design_data,net_count)"
#@ 
#@     sproc_msg -info "METRIC | DOUBLE  PHYSICAL.WLENGTH      | $qor(design_data,net_length)"
#@ 
#@     sproc_msg -info "METRIC | INTEGER STA.LOGICAL_DRC.TOTAL | $qor(design_data,ldrc_total)"
#@     sproc_msg -info "METRIC | INTEGER STA.LOGICAL_DRC.TRANS | $qor(design_data,ldrc_trans)"
#@     sproc_msg -info "METRIC | INTEGER STA.LOGICAL_DRC.CAP   | $qor(design_data,ldrc_cap)"
#@ 
#@     ## From report_design_physical
#@ 
#@     if { $synopsys_program_name == "icc_shell" } {
#@       sproc_msg -info "METRIC | PERCENT PHYSICAL.UTIL         | $phy(cell2core_ratio)"
#@       sproc_msg -info "METRIC | DOUBLE  PHYSICAL.AREA         | $phy(chip_area)"
#@       sproc_msg -info "METRIC | DOUBLE  PHYSICAL.WIDTH        | $phy(chip_width)"
#@       sproc_msg -info "METRIC | DOUBLE  PHYSICAL.HEIGHT       | $phy(chip_height)"
#@       sproc_msg -info "METRIC | INTEGER VERIFY.DRC.NUM_ERRORS | $phy(num_drc_errors)"
#@       sproc_msg -info "METRIC | INTEGER VERIFY.DRC.NUM_TYPES  | $phy(num_drc_errors_types)"
#@       sproc_msg -info "METRIC | STRING  VERIFY.DRC.TOOL       | ICC"
#@     }
#@ 
#@   }
#@ 
#@   if { $options(-metrics_cts) } {
#@     if {1} {
#@       sproc_msg -warning "CTS metrics must be enabled via edit to procs_metrics.tcl file."
#@     } else {
#@       foreach name [array names cts *,skew] {
#@         set scenario_name [lindex [split $name ,] 0]
#@         set clock_name    [lindex [split $name ,] 1]
#@ 
#@         set clock_name_displayed    [sproc_metric_clean_string -string $clock_name]
#@         set scenario_name_displayed [sproc_metric_clean_string -string $scenario_name]
#@         set metric_name $clock_name_displayed.$scenario_name_displayed
#@ 
#@         set data $cts($name)
#@         set value [sproc_metric_normalize -value $data -current_unit $units(time_unit)]
#@         sproc_msg -info "METRIC | DOUBLE CTS.SKEW.$metric_name | $value"
#@       }
#@       foreach name [array names cts *,path] {
#@         set scenario_name [lindex [split $name ,] 0]
#@         set clock_name    [lindex [split $name ,] 1]
#@ 
#@         set clock_name_displayed    [sproc_metric_clean_string -string $clock_name]
#@         set scenario_name_displayed [sproc_metric_clean_string -string $scenario_name]
#@         set metric_name $clock_name_displayed.$scenario_name_displayed
#@ 
#@         set data $cts($name)
#@         set value [sproc_metric_normalize -value $data -current_unit $units(time_unit)]
#@         sproc_msg -info "METRIC | DOUBLE CTS.PATH.$metric_name | $value"
#@       }
#@       foreach name [array names cts *,sinks] {
#@         set scenario_name [lindex [split $name ,] 0]
#@         set clock_name    [lindex [split $name ,] 1]
#@ 
#@         set clock_name_displayed    [sproc_metric_clean_string -string $clock_name]
#@         set scenario_name_displayed [sproc_metric_clean_string -string $scenario_name]
#@         set metric_name $clock_name_displayed.$scenario_name_displayed
#@ 
#@         set value $cts($name)
#@         sproc_msg -info "METRIC | INTEGER CTS.SINKS.$metric_name | $value"
#@       }
#@       foreach name [array names cts *,drc] {
#@         set scenario_name [lindex [split $name ,] 0]
#@         set clock_name    [lindex [split $name ,] 1]
#@ 
#@         set clock_name_displayed    [sproc_metric_clean_string -string $clock_name]
#@         set scenario_name_displayed [sproc_metric_clean_string -string $scenario_name]
#@         set metric_name $clock_name_displayed.$scenario_name_displayed
#@ 
#@         set value $cts($name)
#@         sproc_msg -info "METRIC | INTEGER CTS.DRC.$metric_name | $value"
#@       }
#@     }
#@   }
#@ 
#@   ## -------------------------------------
#@   ## This code creates the file used to support the QoR summary report.
#@   ## -------------------------------------
#@ 
#@   ## -------------------------------------
#@   ## Define required attributes
#@   ## -------------------------------------
#@ 
#@   set attributes [list]
#@   lappend attributes [list STEP   $SEV(step)]
#@   lappend attributes [list TASK   $SEV(task)]
#@   lappend attributes [list DST    $SEV(dst)]
#@   lappend attributes [list DESIGN $SVAR(design_name)]
#@   if { [info exists SEV(flow_order)] } {
#@     lappend attributes [list FLOW_ORDER $SEV(flow_order)]
#@   } else {
#@     lappend attributes [list FLOW_ORDER -1]
#@   }
#@   lappend attributes [list TYPE FLOW_SUMMARY]
#@ 
#@   ## -------------------------------------
#@   ## Start output
#@   ## -------------------------------------
#@ 
#@   set fs_output [list]
#@   lappend fs_output "{"
#@ 
#@     ## -------------------------------------
#@     ## Process attributes
#@     ## -------------------------------------
#@ 
#@     foreach attribute $attributes {
#@       set name  [lindex $attribute 0]
#@       set value [lindex $attribute 1]
#@       lappend fs_output "\"$name\": \"$value\""
#@     }
#@     lappend fs_output "\"flow_summary\": \["
#@ 
#@     ## -------------------------------------
#@     ## All content below here is optional
#@     ## -------------------------------------
#@ 
#@     ## -------------------------------------
#@     ## This code generates per-design summary information.
#@     ## -------------------------------------
#@ 
#@     if { [info exists qor] } {
#@       set file $options(-report_qor)
#@       set file [join [lrange [split $file /] end-3 end] /]
#@     }
#@ 
#@     if { [info exists qor(summary_data,_ms,setup,path_slack)] } {
#@       set fs_output [sproc_qv_flow_summary         -o $fs_output         -name "Design Setup WNS ($units(time_unit))"         -value $qor(summary_data,_ms,setup,path_slack)         -section 1         -file $file         -line $qor(summary_data,_ms,setup,path_slack,line_number)]
#@       set fs_output [sproc_qv_flow_summary         -o $fs_output         -name "Design Setup TNS ($units(time_unit))"         -value $qor(summary_data,_ms,setup,tns)         -section 1         -file $file         -line $qor(summary_data,_ms,setup,tns,line_number)]
#@       set fs_output [sproc_qv_flow_summary         -o $fs_output         -name "Design Setup Violations"         -value $qor(summary_data,_ms,setup,nvp)         -section 1         -file $file         -line $qor(summary_data,_ms,setup,nvp,line_number)]
#@     }
#@     if { [info exists qor(summary_data,_ms,hold,path_slack)] } {
#@       set fs_output [sproc_qv_flow_summary         -o $fs_output         -name "Design Hold WNS ($units(time_unit))"         -value $qor(summary_data,_ms,hold,path_slack)         -section 1         -file $file         -line $qor(summary_data,_ms,hold,path_slack,line_number)]
#@       set fs_output [sproc_qv_flow_summary         -o $fs_output         -name "Design Hold TNS ($units(time_unit))"         -value $qor(summary_data,_ms,hold,tns)         -section 1         -file $file         -line $qor(summary_data,_ms,hold,tns,line_number)]
#@       set fs_output [sproc_qv_flow_summary         -o $fs_output         -name "Design Hold Violations"         -value $qor(summary_data,_ms,hold,nvp)         -section 1         -file $file         -line $qor(summary_data,_ms,hold,nvp,line_number)]
#@     }
#@ 
#@     if { [info exists qor(design_data,leaf_cell_count)] } {
#@       set value $qor(design_data,leaf_cell_count)
#@       if { $value != -1 } {
#@         set fs_output [sproc_qv_flow_summary           -o $fs_output           -name "Leaf Cell Count"           -value $value           -section 4           -file $file           -line $qor(design_data,leaf_cell_count,line_number)]
#@       }
#@     }
#@     if { [info exists qor(design_data,bufinv_cell_count)] } {
#@       set value $qor(design_data,bufinv_cell_count)
#@       if { $value != -1 } {
#@         set fs_output [sproc_qv_flow_summary           -o $fs_output           -name "Buf/Inv Cell Count"           -value $value           -section 4           -file $file           -line $qor(design_data,bufinv_cell_count,line_number)]
#@       }
#@     }
#@     if { [info exists qor(design_data,ctbufinv_cell_count)] } {
#@       set value $qor(design_data,ctbufinv_cell_count)
#@       if { $value != -1 } {
#@         set fs_output [sproc_qv_flow_summary           -o $fs_output           -name "CT Buf/Inv Cell Count"           -value $value           -section 4           -file $file           -line $qor(design_data,ctbufinv_cell_count,line_number)]
#@       }
#@     }
#@ 
#@     if { [info exists qor(design_data,comb_cell_count)] } {
#@       set value $qor(design_data,comb_cell_count)
#@       if { $value != -1 } {
#@         set fs_output [sproc_qv_flow_summary           -o $fs_output           -name "Comb Cell Count"           -value $value           -section 4           -file $file           -line $qor(design_data,comb_cell_count,line_number)]
#@       }
#@     }
#@     if { [info exists qor(design_data,seq_cell_count)] } {
#@       set value $qor(design_data,seq_cell_count)
#@       if { $value != -1 } {
#@         set fs_output [sproc_qv_flow_summary           -o $fs_output           -name "Seq Cell Count"           -value $value           -section 4           -file $file           -line $qor(design_data,seq_cell_count,line_number)]
#@       }
#@     }
#@     if { [info exists qor(design_data,macro_cell_count)] } {
#@       set value $qor(design_data,macro_cell_count)
#@       if { $value != -1 } {
#@         set fs_output [sproc_qv_flow_summary           -o $fs_output           -name "Macro Cell Count"           -value $value           -section 4           -file $file           -line $qor(design_data,macro_cell_count,line_number)]
#@       }
#@     }
#@ 
#@     if { [info exists qor(design_data,cell_area)] } {
#@       set value $qor(design_data,cell_area)
#@       if { $value != -1 } {
#@         set fs_output [sproc_qv_flow_summary           -o $fs_output           -name "Cell Area"           -value $value           -section 4           -file $file           -line $qor(design_data,cell_area,line_number)]
#@       }
#@     }
#@     if { [info exists qor(design_data,design_area)] } {
#@       set value $qor(design_data,design_area)
#@       if { $value != -1 } {
#@         set fs_output [sproc_qv_flow_summary           -o $fs_output           -name "Design Area"           -value $value           -section 4           -file $file           -line $qor(design_data,design_area,line_number)]
#@       }
#@     }
#@     if { [info exists qor(design_data,net_length)] } {
#@       set value $qor(design_data,net_length)
#@       if { $value != -1 } {
#@         set fs_output [sproc_qv_flow_summary           -o $fs_output           -name "Net Length"           -value $value           -section 4           -file $file           -line $qor(design_data,net_length,line_number)]
#@       }
#@     }
#@ 
#@     if { [info exists qor(design_data,net_count)] } {
#@       set value $qor(design_data,net_count)
#@       if { $value != -1 } {
#@         set fs_output [sproc_qv_flow_summary           -o $fs_output           -name "Net Count"           -value $value           -section 4           -file $file           -line $qor(design_data,net_count,line_number)]
#@       }
#@     }
#@     if { [info exists qor(design_data,ldrc_total)] } {
#@       set value $qor(design_data,ldrc_total)
#@       if { $value != -1 } {
#@         set fs_output [sproc_qv_flow_summary           -o $fs_output           -name "Net Violations Total"           -value $value           -section 5           -file $file           -line $qor(design_data,ldrc_total,line_number)]
#@       }
#@     }
#@     if { [info exists qor(design_data,ldrc_trans)] } {
#@       set value $qor(design_data,ldrc_trans)
#@       if { $value != -1 } {
#@         set fs_output [sproc_qv_flow_summary           -o $fs_output           -name "Net Violations Trans"           -value $value           -section 5           -file $file           -line $qor(design_data,ldrc_trans,line_number)]
#@       }
#@     }
#@     if { [info exists qor(design_data,ldrc_cap)] } {
#@       set value $qor(design_data,ldrc_cap)
#@       if { $value != -1 } {
#@         set fs_output [sproc_qv_flow_summary           -o $fs_output           -name "Net Violations MaxCap"           -value $value           -section 5           -file $file           -line $qor(design_data,ldrc_cap,line_number)]
#@       }
#@     }
#@ 
#@     if { [info exists phy] } {
#@       set file $options(-report_design_physical)
#@       set file [join [lrange [split $file /] end-3 end] /]
#@     }
#@ 
#@     if { [info exists phy(cell2core_ratio)] } {
#@       set fs_output [sproc_qv_flow_summary         -o $fs_output         -name "Utilization"         -value $phy(cell2core_ratio)         -section 4         -file $file         -line $phy(cell2core_ratio,line_number)]
#@     }
#@     if { [info exists phy(num_drc_errors)] } {
#@       set fs_output [sproc_qv_flow_summary         -o $fs_output         -name "DRC Errors Total"         -value $phy(num_drc_errors)         -section 5         -file $file         -line $phy(num_drc_errors,line_number)]
#@     }
#@     if { [info exists phy(num_drc_errors_types)] } {
#@       set fs_output [sproc_qv_flow_summary         -o $fs_output         -name "DRC Errors Types"         -value $phy(num_drc_errors_types)         -section 5         -file $file         -line $phy(num_drc_errors_types,line_number)]
#@     }
#@ 
#@     if { [info exists vth] } {
#@       set file $options(-report_threshold_voltage_group)
#@       set file [join [lrange [split $file /] end-3 end] /]
#@       foreach vth_name $vth(vth,vth_names) {
#@         set fs_output [sproc_qv_flow_summary           -o $fs_output           -name "Vth Percent ($vth_name)"           -value $vth(cell_percentage,$vth_name)           -section 3           -file $file           -line $vth(cell_percentage,$vth_name,line_number)]
#@         set fs_output [sproc_qv_flow_summary           -o $fs_output           -name "Vth Count   ($vth_name)"           -value $vth(cell_count,$vth_name)           -section 3           -file $file           -line $vth(cell_count,$vth_name,line_number)]
#@       }
#@     }
#@ 
#@     if { [info exists power] } {
#@       set file $options(-report_power)
#@       set file [join [lrange [split $file /] end-3 end] /]
#@ 
#@       set total_power_max ""
#@       set total_power_units ""
#@       set total_power_line_number ""
#@       set leakage_power_max ""
#@       set leakage_power_units ""
#@       set leakage_power_line_number ""
#@ 
#@       foreach scenario_name $power(scenario_name_list) {
#@         set total_power_units   $power($scenario_name,total_power_units)
#@         set leakage_power_units $power($scenario_name,leakage_power_units)
#@ 
#@         if { [string is double -strict $power($scenario_name,total_power)] } {
#@           if { ($total_power_max == "") || ($power($scenario_name,total_power) > $total_power_max) } {
#@             set total_power_max         $power($scenario_name,total_power)
#@             set total_power_line_number $power($scenario_name,total_power,line_number)
#@           }
#@         }
#@ 
#@         if { [string is double -strict $power($scenario_name,leakage_power)] } {
#@           if { ($leakage_power_max == "") || ($power($scenario_name,leakage_power) > $leakage_power_max) } {
#@             set leakage_power_max         $power($scenario_name,leakage_power)
#@             set leakage_power_line_number $power($scenario_name,leakage_power,line_number)
#@           }
#@         }
#@       }
#@ 
#@       if { [string is double -strict $total_power_max] } {
#@         set total_power_max_adj [sproc_metric_normalize -value $total_power_max -current_unit $total_power_units]
#@         set fs_output [sproc_qv_flow_summary           -o $fs_output           -name "Power Total (mW)"           -value $total_power_max_adj           -section 2           -file $file           -line $total_power_line_number]
#@       }
#@ 
#@       if { [string is double -strict $leakage_power_max] } {
#@         set leakage_power_max_adj [sproc_metric_normalize -value $leakage_power_max -current_unit $leakage_power_units]
#@         set fs_output [sproc_qv_flow_summary           -o $fs_output           -name "Power Leakage (mW)"           -value $leakage_power_max_adj           -section 2           -file $file           -line $leakage_power_line_number]
#@       }
#@ 
#@     }
#@ 
#@     ## -------------------------------------
#@     ## Complete output & create file
#@     ## -------------------------------------
#@ 
#@     lappend fs_output "\]"
#@   lappend fs_output "}"
#@ 
#@   set fs_output [sproc_qv_add_commas -lines $fs_output]
#@   set fs_output [join $fs_output "\n"]
#@ 
#@   set fid [open $SEV(rpt_dir)/.$SEV(block_name).$SEV(step).$SEV(task).$SEV(dst).design_summary-flow_summary.qor w]
#@   puts $fid $fs_output
#@   close $fid
#@ 
#@   sproc_qv_gen_files
#@ 
#@   sproc_pinfo -mode stop
#@ 
#@ }
#@ 
#@ define_proc_attributes sproc_metric_main   -info "This is the main metrics procedure."   -define_args {     {-scenario_name                  "Specifies the scenario name"           AString string optional}
#@   {-metrics_sta                    "Generate 'sta' metrics"                "" boolean optional}
#@   {-metrics_power                  "Generate 'power' metrics"              "" boolean optional}
#@   {-metrics_design                 "Generate 'design' metrics"             "" boolean optional}
#@   {-metrics_cts                    "Generate 'cts' metrics"                "" boolean optional}
#@   {-report_qor                     "The file to parse."                    AString string optional}
#@   {-report_units                   "The file to parse."                    AString string optional}
#@   {-report_power                   "The file to parse."                    AString string optional}
#@   {-report_congestion              "The file to parse."                    AString string optional}
#@   {-report_design_physical         "The file to parse."                    AString string optional}
#@   {-report_threshold_voltage_group "The file to parse."                    AString string optional}
#@   {-report_clock_tree              "The file to parse."                    AString string optional}
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_metric_tags:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_metric_tags { args } {
#@ 
#@   global env SEV SVAR TEV DEV
#@ 
#@   sproc_pinfo -mode start
#@ 
#@   ## -------------------------------------
#@   ## This section of code is for automatic generation of metrics.
#@   ## The metrics SYS.TAG_21 - SYS.TAG_30 are allocated for this purpose.
#@   ## -------------------------------------
#@ 
#@   ## -------------------------------------
#@   ## SYS.TAG_21
#@   ##
#@   ## We are setting this metric to a value that always indicates the date of the next Sunday.
#@   ## This ensures data is tagged according to the week it is developed.
#@   ## (and the data is ready for reporting on Monday morning)
#@   ## -------------------------------------
#@ 
#@   set seconds_per_day [expr 24 * 60 * 60]
#@   set today_in_seconds [clock seconds]
#@   set today_in_name [clock format $today_in_seconds -format "%A"]
#@ 
#@   while { $today_in_name != "Sunday" } {
#@     set today_in_seconds [expr $today_in_seconds + $seconds_per_day]
#@     set today_in_name [clock format $today_in_seconds -format "%A"]
#@   }
#@ 
#@   set metric_value [clock format $today_in_seconds -format "%Y_%m_%d"]
#@   sproc_msg -info "METRIC | TAG SYS.TAG_21 | $metric_value"
#@ 
#@   ## -------------------------------------
#@   ## SYS.TAG_22
#@   ##
#@   ## We are setting this metric to indicate if the RTM is running the flow.
#@   ## -------------------------------------
#@ 
#@   sproc_msg -info "METRIC | TAG SYS.TAG_22 | [info exists env(LYNX_RTM_PRESENT)]"
#@ 
#@   ## -------------------------------------
#@   ## SYS.TAG_23 - SYS.TAG_30
#@   ##
#@   ## These are placeholders for more interesting content.
#@   ## -------------------------------------
#@ 
#@   sproc_msg -info "METRIC | TAG SYS.TAG_23 | TagValue23"
#@   sproc_msg -info "METRIC | TAG SYS.TAG_24 | TagValue24"
#@   sproc_msg -info "METRIC | TAG SYS.TAG_25 | TagValue25"
#@   sproc_msg -info "METRIC | TAG SYS.TAG_26 | TagValue26"
#@   sproc_msg -info "METRIC | TAG SYS.TAG_27 | TagValue27"
#@   sproc_msg -info "METRIC | TAG SYS.TAG_28 | TagValue28"
#@   sproc_msg -info "METRIC | TAG SYS.TAG_29 | TagValue29"
#@   sproc_msg -info "METRIC | TAG SYS.TAG_30 | TagValue30"
#@ 
#@   sproc_pinfo -mode stop
#@ 
#@ }
#@ 
#@ define_proc_attributes sproc_metric_tags   -info "Generates automatic tag metrics."   -define_args {
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_qv_flow_summary:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_qv_flow_summary { args } {
#@ 
#@   set options(-o) ""
#@   set options(-name) ""
#@   set options(-value) ""
#@   set options(-file) ""
#@   set options(-line) ""
#@   set options(-section) ""
#@   parse_proc_arguments -args $args options
#@ 
#@   set output $options(-o)
#@ 
#@   lappend output "{"
#@ 
#@     lappend output "\"name\": \"$options(-name)\""
#@     lappend output "\"value\": \"$options(-value)\""
#@ 
#@     if { $options(-file) != "" } {
#@       lappend output "\"file\": \"$options(-file)\""
#@     }
#@     if { $options(-line) != "" } {
#@       lappend output "\"line\": \"$options(-line)\""
#@     }
#@     if { $options(-section) != "" } {
#@       lappend output "\"section\": \"$options(-section)\""
#@     }
#@ 
#@   lappend output "}"
#@ 
#@   return $output
#@ 
#@ }
#@ 
#@ define_proc_attributes sproc_qv_flow_summary   -info "Proc that creates flow summary entries in JSON."   -define_args {     {-o          "Output"        AString string required}
#@   {-name       "Item name"     AString string required}
#@   {-value      "Item value"    AString string required}
#@   {-file       "Item file"     AString string optional}
#@   {-line       "Item line"     AnInt int optional}
#@   {-section    "Item section"  AnInt int optional}
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_qv_add_commas:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_qv_add_commas { args } {
#@ 
#@   set options(-lines) ""
#@   parse_proc_arguments -args $args options
#@ 
#@   set results [list]
#@ 
#@   set index 0
#@   set index_max [llength $options(-lines)]
#@ 
#@   while { $index < $index_max } {
#@     set this_line [lindex $options(-lines) $index]
#@     set next_line [lindex $options(-lines) [expr $index + 1]]
#@     if { [regexp {[\},\]]$} $this_line] && [regexp {[\[\{]$} $next_line] } {
#@       set this_line ${this_line},
#@     }
#@     if { [regexp {\"$} $this_line] && [regexp {^\"} $next_line] } {
#@       set this_line ${this_line},
#@     }
#@     if { [regexp {[0-9]$} $this_line] && [regexp {^\"} $next_line] } {
#@       set this_line ${this_line},
#@     }
#@     if { [regexp {(true|false)$} $this_line] && [regexp {^\"} $next_line] } {
#@       set this_line ${this_line},
#@     }
#@     lappend results $this_line
#@     incr index
#@   }
#@ 
#@   return $results
#@ }
#@ 
#@ define_proc_attributes sproc_qv_add_commas   -info "Proc that add commas for JSON output."   -define_args {
#@   {-lines       "The lines that need commas." AString string required}
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_qv_gen_files:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_qv_gen_files { args } {
#@ 
#@   sproc_pinfo -mode start
#@ 
#@   global SEV SVAR
#@ 
#@   ## -------------------------------------
#@   ## Useful truncations
#@   ## -------------------------------------
#@ 
#@   set block $SEV(block_name)
#@ 
#@   set rpt_root [file normalize $SEV(block_dir)/../$block/$SEV(step)/rpts/$SEV(dst)]
#@ 
#@   foreach c_rpt [glob -nocomplain -type f $rpt_root/*] {
#@ 
#@     ## -------------------------------------
#@     ## Define required attributes
#@     ## -------------------------------------
#@ 
#@     set attributes [list]
#@     lappend attributes [list STEP   $SEV(step)]
#@     lappend attributes [list TASK   $SEV(task)]
#@     lappend attributes [list DST    $SEV(dst)]
#@     lappend attributes [list DESIGN $SVAR(design_name)]
#@     if { [info exists SEV(flow_order)] } {
#@       lappend attributes [list FLOW_ORDER $SEV(flow_order)]
#@     } else {
#@       lappend attributes [list FLOW_ORDER -1]
#@     }
#@ 
#@     ## -------------------------------------
#@     ## Set FILE attribute to a relative path
#@     ## -------------------------------------
#@ 
#@     set rel_rpt $SEV(step)/rpts/$SEV(dst)/[file tail $c_rpt]
#@ 
#@     ## -------------------------------------
#@     ## Match the report to the parser
#@     ## -------------------------------------
#@ 
#@     switch -glob [file tail $c_rpt] {
#@ 
#@       dc.report_qor -
#@       icc.report_qor -
#@       pt.*.report_qor -
#@       pt_concat.report_qor {
#@ 
#@         if { [regexp {.*/pt\.(\S+)\.report_qor} $c_rpt match value] } {
#@           set scenario $value
#@           if { $SEV(task) != "scenario.$scenario" } {
#@             continue
#@           }
#@         } else {
#@           set scenario ""
#@         }
#@ 
#@         set o_file $SEV(rpt_dir)/.${block}.$SEV(step).$SEV(task).$SEV(dst).qor.qor
#@         lappend attributes [list TYPE QOR]
#@         lappend attributes [list FILE $rel_rpt]
#@         sproc_qv_report_qor -file $c_rpt -output $o_file -attributes $attributes
#@       }
#@ 
#@       dc.report_power -
#@       icc.report_power -
#@       pt.*.report_power -
#@       pt_concat.report_power {
#@ 
#@         if { [regexp {.*/pt\.(\S+)\.report_power} $c_rpt match value] } {
#@           set scenario $value
#@           if { $SEV(task) != "scenario.$scenario" } {
#@             continue
#@           }
#@         } else {
#@           set scenario ""
#@         }
#@ 
#@         set o_file $SEV(rpt_dir)/.${block}.$SEV(step).$SEV(task).$SEV(dst).power.qor
#@         lappend attributes [list TYPE POWER]
#@         lappend attributes [list FILE $rel_rpt]
#@         sproc_qv_report_power -file $c_rpt -output $o_file -attributes $attributes -scenario $scenario
#@       }
#@ 
#@       dc.report_timing -
#@       icc.report_timing.min -
#@       icc.report_timing.max -
#@       pt.*.report_timing.* -
#@       pt_concat.report_timing.* -
#@       *.max.tim -
#@       *.min.tim -
#@       *.mapped.timing.rpt {
#@ 
#@         if { [regexp {.*/pt\.(\S+)\.report_timing\.m??} $c_rpt match value] } {
#@           set scenario $value
#@           if { $SEV(task) != "scenario.$scenario" } {
#@             continue
#@           }
#@         } else {
#@           set scenario ""
#@         }
#@ 
#@         if { [string match */*.report_timing.min $c_rpt] || [string match */*.min.tim $c_rpt] } {
#@           set C_TYPE MIN
#@           set c_type min
#@         } else {
#@           set C_TYPE MAX
#@           set c_type max
#@         }
#@ 
#@         set o_file $SEV(rpt_dir)/.${block}.$SEV(step).$SEV(task).$SEV(dst).timing_${c_type}.qor
#@         lappend attributes [list TYPE TIMING_$C_TYPE]
#@         lappend attributes [list FILE $rel_rpt]
#@         sproc_qv_report_timing -file $c_rpt -output $o_file -attributes $attributes -scenario $scenario
#@       }
#@ 
#@       dc.report_units -
#@       icc.report_units {
#@ 
#@         set o_file $SEV(rpt_dir)/.${block}.$SEV(step).$SEV(task).$SEV(dst).units.qor
#@         lappend attributes [list TYPE UNITS]
#@         lappend attributes [list FILE $rel_rpt]
#@         sproc_qv_report_units -file $c_rpt -output $o_file -attributes $attributes
#@       }
#@ 
#@       icc.cts.report_clock_tree {
#@         set o_file_matrix $SEV(rpt_dir)/.${block}.$SEV(step).$SEV(task).$SEV(dst).clock_tree_matrix-matrix.qor
#@         set o_file_table $SEV(rpt_dir)/.${block}.$SEV(step).$SEV(task).$SEV(dst).clock_tree_summary-table.qor
#@         lappend attributes [list TYPE UD_MATRIX]
#@         lappend attributes [list FILE $rel_rpt]
#@         sproc_qv_report_clock_tree -file $c_rpt -matrix_output $o_file_matrix -table_output $o_file_table -attributes $attributes
#@       }
#@ 
#@     }
#@ 
#@   }
#@ 
#@   sproc_pinfo -mode stop
#@ }
#@ 
#@ define_proc_attributes sproc_qv_gen_files   -info "Proc that generates QoR Viewer files."   -define_args {
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_qv_report_timing:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_qv_report_timing { args } {
#@ 
#@   sproc_pinfo -mode start
#@ 
#@   global env SEV SVAR
#@ 
#@   set options(-file) ""
#@   set options(-output) ""
#@   set options(-attributes) ""
#@   set options(-scenario) ""
#@   parse_proc_arguments -args $args options
#@ 
#@   if { ![file exists $options(-file)] } {
#@     sproc_msg -error "The argument for -file does not exist: '$options(-file)'"
#@     sproc_pinfo -mode stop
#@     return
#@   } else {
#@     array set tim [sproc_metric_parse_report_timing -file $options(-file) -scenario $options(-scenario)]
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Start output
#@   ## -------------------------------------
#@ 
#@   set output [list]
#@   lappend output "{"
#@ 
#@     ## -------------------------------------
#@     ## Process attributes
#@     ## -------------------------------------
#@ 
#@     foreach attribute $options(-attributes) {
#@       set name  [lindex $attribute 0]
#@       set value [lindex $attribute 1]
#@       lappend output "\"$name\": \"$value\""
#@     }
#@ 
#@     ## -------------------------------------
#@     ## Process timing
#@     ## -------------------------------------
#@ 
#@     lappend output "\"timing\": \["
#@ 
#@     foreach path_item $tim(path_items) {
#@ 
#@       set scenario_name [lindex $path_item 0]
#@       set start_point   [lindex $path_item 1]
#@       set end_point     [lindex $path_item 2]
#@       set path_group    [lindex $path_item 3]
#@       set path_type     [lindex $path_item 4]
#@       set slack         [lindex $path_item 5]
#@       set line          [lindex $path_item 6]
#@ 
#@       lappend output "{"
#@         lappend output "\"Scenario\": \"$scenario_name\""
#@         lappend output "\"Path Group\": \"$path_group\""
#@         lappend output "\"Path Type\": \"$path_type\""
#@         lappend output "\"Startpoint\": \"$start_point\""
#@         lappend output "\"Endpoint\": \"$end_point\""
#@         lappend output "\"Slack\": \"$slack\""
#@         lappend output "\"line\": \"$line\""
#@       lappend output "}"
#@ 
#@     }
#@ 
#@     lappend output "\]"
#@ 
#@     ## -------------------------------------
#@     ## Complete output & create file
#@     ## -------------------------------------
#@ 
#@   lappend output "}"
#@ 
#@   set output [sproc_qv_add_commas -lines $output]
#@   set output [join $output "\n"]
#@ 
#@   set fid [open $options(-output) w]
#@   puts $fid $output
#@   close $fid
#@ 
#@   sproc_pinfo -mode stop
#@ }
#@ 
#@ define_proc_attributes sproc_qv_report_timing   -info "Proc that parses report_timing reports and returns metrics in JSON."   -define_args {
#@   {-file        "File name for the report." AString string required}
#@   {-output      "Output file." AString string required}
#@   {-attributes  "Attribute pairs to write to file" AString string required}
#@   {-scenario    "The scenario name." AString string optional}
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_qv_report_qor:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_qv_report_qor { args } {
#@ 
#@   sproc_pinfo -mode start
#@ 
#@   global env SEV SVAR
#@ 
#@   set options(-file) ""
#@   set options(-output) ""
#@   set options(-attributes) ""
#@   parse_proc_arguments -args $args options
#@ 
#@   if { ![file exists $options(-file)] } {
#@     sproc_msg -error "The argument for -file does not exist: '$options(-file)'"
#@     sproc_pinfo -mode stop
#@     return
#@   } else {
#@     array set qor [sproc_metric_parse_report_qor -file $options(-file)]
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Start output
#@   ## -------------------------------------
#@ 
#@   set output [list]
#@   lappend output "{"
#@ 
#@     ## -------------------------------------
#@     ## Process attributes
#@     ## -------------------------------------
#@ 
#@     foreach attribute $options(-attributes) {
#@       set name  [lindex $attribute 0]
#@       set value [lindex $attribute 1]
#@       lappend output "\"$name\": \"$value\""
#@     }
#@ 
#@     ## -------------------------------------
#@     ## Process timing entry
#@     ## -------------------------------------
#@ 
#@     lappend output "\"timing\": \["
#@ 
#@     foreach scenario_name $qor(path_group_data,scenario_name_list) {
#@       foreach path_group_name $qor(path_group_data,path_group_name_list,$scenario_name) {
#@         lappend output "{"
#@           lappend output "\"Scenario\": \"$scenario_name\""
#@           lappend output "\"Timing Path Group\": \"$path_group_name\""
#@           lappend output "\"line\": \"$qor(path_group_data,$scenario_name,$path_group_name,line_number)\""
#@           lappend output "\"Levels of Logic\": \"$qor(path_group_data,$scenario_name,$path_group_name,setup,logic_levels)\""
#@           lappend output "\"Critical Path Length\": \"$qor(path_group_data,$scenario_name,$path_group_name,setup,path_length)\""
#@           lappend output "\"Critical Path Slack\": \"$qor(path_group_data,$scenario_name,$path_group_name,setup,path_slack)\""
#@           lappend output "\"Critical Path Clk Period\": \"$qor(path_group_data,$scenario_name,$path_group_name,setup,path_period)\""
#@           lappend output "\"Total Negative Slack\": \"$qor(path_group_data,$scenario_name,$path_group_name,setup,tns)\""
#@           lappend output "\"No. of Violating Paths\": \"$qor(path_group_data,$scenario_name,$path_group_name,setup,nvp)\""
#@           lappend output "\"Worst Hold Violation\": \"$qor(path_group_data,$scenario_name,$path_group_name,hold,path_slack)\""
#@           lappend output "\"Total Hold Violation\": \"$qor(path_group_data,$scenario_name,$path_group_name,hold,tns)\""
#@           lappend output "\"No. of Hold Violations\": \"$qor(path_group_data,$scenario_name,$path_group_name,hold,nvp)\""
#@         lappend output "}"
#@       }
#@     }
#@     lappend output "\]"
#@ 
#@     ## -------------------------------------
#@     ## Complete output & create file
#@     ## -------------------------------------
#@ 
#@   lappend output "}"
#@ 
#@   set output [sproc_qv_add_commas -lines $output]
#@   set output [join $output "\n"]
#@ 
#@   set fid [open $options(-output) w]
#@   puts $fid $output
#@   close $fid
#@ 
#@   sproc_pinfo -mode stop
#@ }
#@ 
#@ define_proc_attributes sproc_qv_report_qor   -info "Proc that parses report_qor reports and returns metrics in JSON."   -define_args {
#@   {-file        "File name for the report." AString string required}
#@   {-output      "Output file." AString string required}
#@   {-attributes  "Attribute pairs to write to file" AString string required}
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_qv_report_power:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_qv_report_power { args } {
#@ 
#@   sproc_pinfo -mode start
#@ 
#@   global env SEV SVAR
#@ 
#@   set options(-file) ""
#@   set options(-output) ""
#@   set options(-attributes) ""
#@   set options(-scenario) ""
#@   parse_proc_arguments -args $args options
#@ 
#@   if { ![file exists $options(-file)] } {
#@     sproc_msg -error "The argument for -file does not exist: '$options(-file)'"
#@     sproc_pinfo -mode stop
#@     return
#@   } else {
#@     array set power [sproc_metric_parse_report_power -file $options(-file) -scenario $options(-scenario)]
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Start output
#@   ## -------------------------------------
#@ 
#@   set output [list]
#@   lappend output "{"
#@ 
#@     ## -------------------------------------
#@     ## Process attributes
#@     ## -------------------------------------
#@ 
#@     foreach attribute $options(-attributes) {
#@       set name  [lindex $attribute 0]
#@       set value [lindex $attribute 1]
#@       lappend output "\"$name\": \"$value\""
#@     }
#@ 
#@     ## -------------------------------------
#@     ## Process power
#@     ## -------------------------------------
#@ 
#@     lappend output "\"power\": \["
#@ 
#@     foreach scenario_name $power(scenario_name_list) {
#@       lappend output "{"
#@         lappend output "\"Scenario\": \"$scenario_name\""
#@         lappend output "\"line\": \"$power($scenario_name,total_power,line_number)\""
#@         lappend output "\"total\": {"
#@ 
#@           if { $power($scenario_name,internal_power) != "N/A" } {
#@             lappend output "\"Internal\": \"$power($scenario_name,internal_power)$power($scenario_name,internal_power_units)\""
#@           } else {
#@             lappend output "\"Internal\": \"\""
#@           }
#@           if { $power($scenario_name,switching_power) != "N/A" } {
#@             lappend output "\"Switching\": \"$power($scenario_name,switching_power)$power($scenario_name,switching_power_units)\""
#@           } else {
#@             lappend output "\"Switching\": \"\""
#@           }
#@           if { $power($scenario_name,leakage_power) != "N/A" } {
#@             lappend output "\"Leakage\": \"$power($scenario_name,leakage_power)$power($scenario_name,leakage_power_units)\""
#@           } else {
#@             lappend output "\"Leakage\": \"\""
#@           }
#@           if { $power($scenario_name,total_power) != "N/A" } {
#@             lappend output "\"Total\": \"$power($scenario_name,total_power)$power($scenario_name,total_power_units)\""
#@           } else {
#@             lappend output "\"Total\": \"\""
#@           }
#@ 
#@         lappend output "}"
#@       lappend output "}"
#@     }
#@ 
#@     lappend output "\]"
#@ 
#@     ## -------------------------------------
#@     ## Complete output & create file
#@     ## -------------------------------------
#@ 
#@   lappend output "}"
#@ 
#@   set output [sproc_qv_add_commas -lines $output]
#@   set output [join $output "\n"]
#@ 
#@   set fid [open $options(-output) w]
#@   puts $fid $output
#@   close $fid
#@ 
#@   sproc_pinfo -mode stop
#@ }
#@ 
#@ define_proc_attributes sproc_qv_report_power   -info "Proc that parses report_power reports and returns metrics in JSON."   -define_args {
#@   {-file        "File name for the report." AString string required}
#@   {-output      "Output file." AString string required}
#@   {-attributes  "Attribute pairs to write to file" AString string required}
#@   {-scenario    "The scenario name." AString string optional}
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_qv_report_clock_tree:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_qv_report_clock_tree { args } {
#@ 
#@   sproc_pinfo -mode start
#@ 
#@   global env SEV SVAR
#@ 
#@   set options(-file) ""
#@   set options(-matrix_output) ""
#@   set options(-table_output) ""
#@   set options(-attributes) ""
#@   parse_proc_arguments -args $args options
#@ 
#@   if { ![file exists $options(-file)] } {
#@     sproc_msg -error "The argument for -file does not exist: '$options(-file)'"
#@     sproc_pinfo -mode stop
#@     return
#@   } else {
#@     array set cts [sproc_metric_parse_report_clock_tree -file $options(-file)]
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Start output
#@   ## -------------------------------------
#@ 
#@   set matrix_output [list]
#@   set table_output [list]
#@   lappend matrix_output "\{"
#@   lappend table_output "\{"
#@ 
#@   ## -------------------------------------
#@   ## Process attributes
#@   ## -------------------------------------
#@ 
#@   foreach attribute $options(-attributes) {
#@     set name  [lindex $attribute 0]
#@     set value [lindex $attribute 1]
#@     lappend matrix_output "\"$name\": \"$value\""
#@     if {$name == "TYPE"} {
#@       set value UD_TABLE
#@       lappend table_output "\"$name\": \"$value\""
#@     } else {
#@       lappend table_output "\"$name\": \"$value\""
#@     }
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Create CTS Matrix
#@   ## -------------------------------------
#@ 
#@   lappend matrix_output "\"data\": \["
#@   lappend table_output "\"data\": \["
#@   set file [lindex [lindex $options(-attributes) end] end]
#@ 
#@   foreach scenario_name $cts(scenario_name_list) {
#@     foreach clk_name $cts($scenario_name,clk_name_list) {
#@       lappend matrix_output "\{"
#@       lappend matrix_output "\"Scenario\": \"$scenario_name\""
#@       lappend matrix_output "\"Clock\": \"$clk_name\""
#@       foreach name $cts(name_list) {
#@         lappend matrix_output "\"$name\" \: \{"
#@         lappend matrix_output "\"value\" \: \"$cts($scenario_name,$clk_name,$name,value)\""
#@         lappend matrix_output "\"file\" \: \"$file\""
#@         lappend matrix_output "\"line\" \: \"$cts($scenario_name,$clk_name,$name,line_number)\""
#@         lappend matrix_output "\}"
#@       }
#@       lappend matrix_output "\}"
#@     }
#@   }
#@   lappend matrix_output "\]"
#@ 
#@   ## Specification section
#@ 
#@   lappend matrix_output "\"specification\" \: \{"
#@   lappend matrix_output "\"Rows\" \: \["
#@   lappend matrix_output "\"Clock\""
#@   lappend matrix_output "\]"
#@   lappend matrix_output "\"Columns\" \: \["
#@   lappend matrix_output "\"Scenario\""
#@   lappend matrix_output "\]"
#@   lappend matrix_output "\"Values\" \: \["
#@   lappend matrix_output "\"Max Global Skew\""
#@   lappend matrix_output "\"Longest path delay\""
#@   lappend matrix_output "\"Shortest path delay\""
#@   lappend matrix_output "\]"
#@   lappend matrix_output "\}"
#@ 
#@   ## -------------------------------------
#@   ## Create CTS Table
#@   ## -------------------------------------
#@ 
#@   foreach clk_name $cts(clk_name_list) {
#@     foreach scenario_name $cts(scenario_name_list) {
#@       if { [lsearch $cts($scenario_name,clk_name_list) $clk_name] >= 0 } {
#@         foreach name $cts(name_list) {
#@           lappend table_output "\{"
#@           lappend table_output "\"Clock\": \"${clk_name}\""
#@           lappend table_output "\"Scenario\": \"${scenario_name}\""
#@           lappend table_output "\"Metric\" \: \"$name\""
#@           lappend table_output "\"value\" \: \"$cts($scenario_name,$clk_name,$name,value)\""
#@           lappend table_output "\"line\" \: \"$cts($scenario_name,$clk_name,$name,line_number)\""
#@           lappend table_output "\"file\" \: \"$file\""
#@           lappend table_output "\}"
#@         }
#@       }
#@ 
#@     }
#@   }
#@   lappend table_output "\]"
#@ 
#@   ## Specification section
#@ 
#@   lappend table_output "\"specification\" \: \{"
#@ 
#@   lappend table_output "\"Rows\" \: \["
#@   lappend table_output "\"Clock\""
#@   lappend table_output "\"Scenario\""
#@   lappend table_output "\]"
#@ 
#@   lappend table_output "\"Columns\" \: \["
#@   lappend table_output "\"Metric\""
#@   lappend table_output "\]"
#@   lappend table_output "\"Values\" \: \["
#@   lappend table_output "\"value\""
#@   lappend table_output "\]"
#@   lappend table_output "\"Properties\" \: \{"
#@   lappend table_output "\"model\" \: \{"
#@   lappend table_output "\"metric_on_columns\" \: true"
#@   lappend table_output "\"metric_index\" \: 0"
#@   lappend table_output "\}"
#@   lappend table_output "\}"
#@   lappend table_output "\}"
#@ 
#@   ## -------------------------------------
#@   ## Complete output & create file
#@   ## -------------------------------------
#@ 
#@   lappend matrix_output "\}"
#@   lappend table_output "\}"
#@ 
#@   set matrix_output [sproc_qv_add_commas -lines $matrix_output]
#@   set matrix_output [join $matrix_output "\n"]
#@ 
#@   set table_output [sproc_qv_add_commas -lines $table_output]
#@   set table_output [join $table_output "\n"]
#@ 
#@   set fid [open $options(-matrix_output) w]
#@   puts $fid $matrix_output
#@   close $fid
#@ 
#@   set fid2 [open $options(-table_output) w]
#@   puts $fid2 $table_output
#@   close $fid2
#@ 
#@   sproc_pinfo -mode stop
#@ }
#@ 
#@ define_proc_attributes sproc_qv_report_clock_tree   -info "Proc that parses report_qor reports and returns metrics in JSON."   -define_args {
#@   {-file        "File name for the report." AString string required}
#@   {-matrix_output      "Output file." AString string required}
#@   {-table_output      "II type Output file." AString string required}
#@   {-attributes  "Attribute pairs to write to file" AString string required}
#@ }
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## sproc_metric_parse_report_clock_tree:
#@ ## -----------------------------------------------------------------------------
#@ 
#@ proc sproc_metric_parse_report_clock_tree { args } {
#@ 
#@   sproc_pinfo -mode start
#@ 
#@   global env SEV SVAR synopsys_program_name pt_shell_mode
#@ 
#@   set options(-file) ""
#@   parse_proc_arguments -args $args options
#@ 
#@   ## -------------------------------------
#@   ## Standard setup
#@   ## -------------------------------------
#@ 
#@   set rval(error_flag) 0
#@   set rval(scenario_name_list) [list]
#@ 
#@   ## -------------------------------------
#@   ## Standard argument processing
#@   ## -------------------------------------
#@ 
#@   if { [file exists $options(-file)] } {
#@     sproc_msg -info "The specified report file is: '$options(-file)'"
#@   } else {
#@     sproc_msg -error "The specified report file does not exist: '$options(-file)'"
#@     set rval(error_flag) 1
#@     sproc_pinfo -mode stop
#@     return [array get rval]
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Read the report
#@   ## -------------------------------------
#@ 
#@   set fid [open $options(-file) r]
#@   set string_file [read $fid]
#@   close $fid
#@   set lines [split $string_file \n]
#@ 
#@   ## -------------------------------------
#@   ## Parse the report (for Clock Tree Summary info)
#@   ## This information used for METRICS
#@   ## -------------------------------------
#@ 
#@   set in_section 0
#@ 
#@   set index 0
#@   set line_number 0
#@   foreach line $lines {
#@     incr line_number
#@ 
#@     if { [regexp {\=\=Report for scenario \((\S+)\)\=\=} $line match value] } {
#@       set scenario_name $value
#@       lappend rval(scenario_name_list) $scenario_name
#@       continue
#@     }
#@ 
#@     if { [regexp {\=\= Clock Tree Summary =\=} $line] } {
#@       set in_section 1
#@       continue
#@     }
#@ 
#@     if { $in_section } {
#@       if { [regexp {Clock\s+Sinks\s+CTBuffers\s+ClkCells\s+Skew\s+LongestPath\s+TotalDRC\s+BufferArea} $line] } {
#@         ## This is header line
#@         continue
#@       } elseif { [regexp {^----} $line] } {
#@         ## This is seperator line
#@         continue
#@       } elseif { [scan $line {%s %s %s %s %s %s %s %s} clock_name sinks buffers cells skew path drc area] == 8 } {
#@         ## This is data line
#@         set rval($scenario_name,$clock_name,sinks) $sinks
#@         set rval($scenario_name,$clock_name,skew)  $skew
#@         set rval($scenario_name,$clock_name,path)  $path
#@         set rval($scenario_name,$clock_name,drc)   $drc
#@         set rval($scenario_name,$clock_name,sinks,line_number) $line_number
#@         set rval($scenario_name,$clock_name,skew,line_number)  $line_number
#@         set rval($scenario_name,$clock_name,path,line_number)  $line_number
#@         set rval($scenario_name,$clock_name,drc,line_number)   $line_number
#@         continue
#@       } else {
#@         ## No longer in summary
#@         set in_section 0
#@         continue
#@       }
#@     }
#@ 
#@   }
#@ 
#@   ## -------------------------------------
#@   ## Parse the report (for Global Skew Report info)
#@   ## This information used for QOR JSON files
#@   ## -------------------------------------
#@ 
#@   set rval(name_list) [list     "Clock Period"     "Number of Levels"     "Number of Sinks"     "Number of CT Buffers"     "Number of CTS added gates"     "Number of Preexisting Gates"     "Number of Preexisting Buf/Inv"     "Total Number of Clock Cells"     "Total Area of CT Buffers"     "Total Area of CT cells"     "Max Global Skew"     "Number of MaxTran Violators"     "Number of MaxCap Violators"     "Number of MaxFanout Violators"     "Clock global Skew"     "Longest path delay"     "Shortest path delay"     ]
#@ 
#@   set in_section 0
#@ 
#@   set index 0
#@   set line_number 0
#@   foreach line $lines {
#@     incr line_number
#@ 
#@     if { [regexp {\=\=Report for scenario \((\S+)\)\=\=} $line match value] } {
#@       set scenario_name $value
#@       lappend rval(scenario_name_list) $scenario_name
#@       continue
#@     }
#@ 
#@     if { [regexp {\=\= Global Skew Report =\=} $line] } {
#@       set in_section 1
#@       continue
#@     }
#@ 
#@     if { $in_section } {
#@ 
#@       if { [regexp "^Clock Tree Name" $line] } {
#@         set clk_name [lindex [split [string trim $line]] end]
#@         set clk_name [regsub -all {\"} $clk_name {}]
#@         puts "$scenario_name : $clk_name"
#@         lappend rval(clk_name_list) $clk_name
#@         lappend rval($scenario_name,clk_name_list) $clk_name
#@         foreach name $rval(name_list) {
#@           set rval($scenario_name,$clk_name,$name,value) unknown
#@           set rval($scenario_name,$clk_name,$name,line_number) 0
#@         }
#@         continue
#@       }
#@ 
#@       foreach name $rval(name_list) {
#@         if { [regexp "^$name\s*\:*\s*" $line] } {
#@           set value [lindex [split [string trim $line]] end]
#@           set rval($scenario_name,$clk_name,$name,value) $value
#@           set rval($scenario_name,$clk_name,$name,line_number) $line_number
#@ 
#@           ## set value_line [list $value $line_number]
#@           ## lappend rval($clk_name,$name,value_line_list) $value_line
#@ 
#@           continue
#@         }
#@       }
#@ 
#@       if { [regexp {^Report} $line] } {
#@         set in_section 0
#@         continue
#@       }
#@ 
#@     }
#@ 
#@   }
#@ 
#@   ## Clean up
#@ 
#@   set rval(scenario_name_list) [lsort -unique $rval(scenario_name_list)]
#@   set rval(clk_name_list)      [lsort -unique $rval(clk_name_list)]
#@ 
#@   ## -------------------------------------
#@   ## Return the parsed information
#@   ## -------------------------------------
#@ 
#@   sproc_pinfo -mode stop
#@   return [array get rval]
#@ }
#@ 
#@ define_proc_attributes sproc_metric_parse_report_clock_tree   -info "Parses information for report_clock_tree."   -define_args {    {-file "The report_clock_tree file to parse." AString string required}
#@ }
#@ 
#@ 
#@ sproc_msg -info "METRIC | INTEGER INFO.LCRM_RTM_MODE          | $LYNX(rtm_present)"
#@ 
#@ ## -----------------------------------------------------------------------------
#@ ## End of File
#@ ## -----------------------------------------------------------------------------
#@ # -- End source ../rm_setup/lcrm_setup.tcl

#@ source -echo ../rm_setup/icc_setup.tcl
#@ # -- Starting source ../rm_setup/icc_setup.tcl

#@ puts "RM-Info: Running script [info script]\n"
#@ 
#@ ##########################################################################################
#@ # Variables for IC Compiler Reference Methodology, IC Compiler Design Planning Reference 
#@ # Methodology, and IC Compiler Hierarchical Reference Methodology 
#@ # Script: icc_setup.tcl
#@ # Version: J-2014.09-SP2 (January 12, 2015)
#@ # Copyright (C) 2010-2015 Synopsys, Inc. All rights reserved.
#@ ##########################################################################################
#@ 
#@ # Sourcing the common variables
#@ source -echo ../rm_setup/common_setup.tcl 
#@ # -- Starting source ../rm_setup/common_setup.tcl

#@ puts "RM-Info: Running script [info script]\n"
#@ 
#@ ##########################################################################################
#@ # Variables common to all reference methodology scripts
#@ # Script: common_setup.tcl
#@ # Version: J-2014.09-SP2 (January 12, 2015)
#@ # Copyright (C) 2010-2015 Synopsys, Inc. All rights reserved.
#@ ##########################################################################################
#@ 
#@ set DESIGN_NAME                   "aestop"  ;#  The name of the top-level design
#@ 
#@ set WORKSHOP_REF_PATH             "../../../../hu40"
#@ set ICC_INPUTS_PATH               "../../dc/out"
#@ ###########################################################################
#@ # Hierarchical Flow Design Variables
#@ ##########################################################################################
#@ 
#@ set HIERARCHICAL_DESIGNS           "" ;# List of hierarchical block design names "DesignA DesignB" ...
#@ set HIERARCHICAL_CELLS             "" ;# List of hierarchical block cell instance names "u_DesignA u_DesignB" ...
#@ 
#@ ##########################################################################################
#@ # Library Setup Variables
#@ ##########################################################################################
#@ 
#@ # For the following variables, use a blank space to separate multiple entries.
#@ # Example: set TARGET_LIBRARY_FILES "lib1.db lib2.db lib3.db"
#@ 
#@ set ADDITIONAL_SEARCH_PATH        [join "
#@ 	$hu40 
#@ 	$hu40_dbpath 
#@ 	${ICC_INPUTS_PATH} 
#@ 	../out 
#@ 	../scr 
#@ 	"]
#@ 
#@ #       setup
#@ #               hold
#@ #                       leakage (and hold_hot)
#@ #       setup_hot
#@ #
#@ set TARGET_LIBRARY_FILES     [join "
#@ 	$hu40_db_ss_0v99_40c 
#@  	$hu40_db_ss_0v99_0c  
#@  	$hu40_db_ss_0v99_125c 
#@  	$hu40_db_tt_1v0_25c 
#@  	$hu40_db_tt_1v1_25c 
#@  	$hu40_db_tt_1v2_25c 
#@  	$hu40_db_ff_1v1_0c 
#@  	$hu40_db_ff_1v1_40c 
#@  	$hu40_db_ff_1v1_125c 
#@  	$hu40_db_ff_1v21_0c 
#@  	$hu40_db_ff_1v21_40c 
#@  	$hu40_db_ff_1v21_125c
#@  	$hu40_db_ff_1v26_0c 
#@  	$hu40_db_ff_1v26_40c 
#@  	$hu40_db_ff_1v26_125c
#@ 	"]
#@ 
#@ set ADDITIONAL_LINK_LIB_FILES     [join "
#@ 	$hu40_db_ss_0v99_40c 
#@  	$hu40_db_ss_0v99_0c  
#@  	$hu40_db_ss_0v99_125c 
#@  	$hu40_db_tt_1v0_25c 
#@  	$hu40_db_tt_1v1_25c 
#@  	$hu40_db_tt_1v2_25c 
#@  	$hu40_db_ff_1v1_0c 
#@  	$hu40_db_ff_1v1_40c 
#@  	$hu40_db_ff_1v1_125c 
#@  	$hu40_db_ff_1v21_0c 
#@  	$hu40_db_ff_1v21_40c 
#@  	$hu40_db_ff_1v21_125c
#@  	$hu40_db_ff_1v26_0c 
#@  	$hu40_db_ff_1v26_40c 
#@  	$hu40_db_ff_1v26_125c
#@ 
#@ "]
#@ 
#@ set MIN_LIBRARY_FILES             ""  ;#  List of max min library pairs "max1 min1 max2 min2 max3 min3"...
#@ 
#@ set MW_REFERENCE_LIB_DIRS         [join "
#@     $hu40_mw/hu40npksdst_m07f1f0f0_RDL
#@ 	"]
#@ 
#@ set MW_REFERENCE_CONTROL_FILE     ""  ;#  Reference Control file to define the Milkyway reference libs
#@ 
#@ #set TECH_FILE                     "mytech.tf"  ;#  Milkyway technology file
#@ set TECH_FILE                     "$hu40_tf7m"  ;#  Milkyway technology file
#@ set MAP_FILE                      "$hu40_map"  ;#  Mapping file for TLUplus
#@ set TLUPLUS_MAX_FILE              "$hu40_TLU_CMAX"  ;#  Max TLUplus file
#@ set TLUPLUS_MIN_FILE              "$hu40_TLU_CMIN"  ;#  Min TLUplus file
#@ set GDFMAPFILE			  "${hu40_mw}/tf/gds2.map"
#@ set ANTENNAFILE			  "${hu40_mw}/antenna/antenna_rule_db_update_${mstack}.tcl"
#@ set ALF_FILE_NAME		  "${hu40_mw}/alf/${libname}_${mstack}.alf"
#@ 
#@ 
#@ set MW_POWER_NET                "VDD" ;#
#@ set MW_POWER_PORT               "VDD" ;#
#@ set MW_GROUND_NET               "VSS" ;#
#@ set MW_GROUND_PORT              "VSS" ;#
#@ 
#@ set MIN_ROUTING_LAYER            "M1"   ;# Min routing layer
#@ set MAX_ROUTING_LAYER            "M6"   ;# Max routing layer
#@ 
#@ set LIBRARY_DONT_USE_FILE        ""   ;# Tcl file with library modifications for dont_use
#@ 
#@ ##########################################################################################
#@ # Multivoltage Common Variables
#@ #
#@ # Define the following multivoltage common variables for the reference methodology scripts 
#@ # for multivoltage flows. 
#@ # Use as few or as many of the following definitions as needed by your design.
#@ ##########################################################################################
#@ 
#@ set PD1                          ""           ;# Name of power domain/voltage area  1
#@ set VA1_COORDINATES              {}           ;# Coordinates for voltage area 1
#@ set MW_POWER_NET1                "VDD1"       ;# Power net for voltage area 1
#@ 
#@ set PD2                          ""           ;# Name of power domain/voltage area  2
#@ set VA2_COORDINATES              {}           ;# Coordinates for voltage area 2
#@ set MW_POWER_NET2                "VDD2"       ;# Power net for voltage area 2
#@ 
#@ set PD3                          ""           ;# Name of power domain/voltage area  3
#@ set VA3_COORDINATES              {}           ;# Coordinates for voltage area 3
#@ set MW_POWER_NET3                "VDD3"       ;# Power net for voltage area 3
#@ 
#@ set PD4                          ""           ;# Name of power domain/voltage area  4
#@ set VA4_COORDINATES              {}           ;# Coordinates for voltage area 4
#@ set MW_POWER_NET4                "VDD4"       ;# Power net for voltage area 4
#@ 
#@ puts "RM-Info: Completed script [info script]\n"
#@ # -- End source ../rm_setup/common_setup.tcl

#@ 
#@ ###############################
#@ ## Flow Variables
#@ ###############################
#@ set ICC_INIT_DESIGN_INPUT         "VERILOG"         ;# VERILOG|DDC|MW; specify the type of starting point;
#@ ;# if "VERILOG" is specified, you should also specify a valid $ICC_IN_VERILOG_NETLIST_FILE
#@ ;# if "DDC" is specified, you should also specify a valid $ICC_IN_DDC_FILE 
#@ ;# if "MW" is specified, you should also specify a valid $ICC_INPUT_CEL
#@ ;# If MW is specified, script will copy Milkyway design library from rm_dc/work/dc to rm_icc/work 
#@ set POWER_OPTIMIZATION            TRUE         ;# TRUE|FALSE; set TRUE to enable power optimization (-power option) for the core commands such as place_opt, clock_opt, 
#@ ;# route_opt, and focal_opt. If $ICC_CUSTOM_MULTI_VTH_CONSTRAINT_SCRIPT below is also specified, 
#@ ;# leakage power optimization is focused on lvt cell reduction; otherwise focused on leakage power reduction.
#@ ;# for MCMM, set set_scenario_options -leakage true to enable leakage power optimization on scenarios;
#@ ;# see rm_icc_scripts/mcmm.scenarios.example for more details.
#@ set ICC_PLACE_LOW_POWER_PLACEMENT FALSE	       ;# TRUE|FALSE; set TRUE to enable low power placement for place_opt; requires $POWER_OPTIMIZATION to be TRUE to be effective.
#@ 
#@ ;# for MCMM, this feature requires you to set set_scenario_options -dynamic true;
#@ ;# see rm_icc_scripts/mcmm.scenarios.example for more details.
#@ set ICC_CUSTOM_MULTI_VTH_CONSTRAINT_SCRIPT ""  ;# script for customized set_multi_vth_constraints constraints. effective only when $POWER_OPTIMIZATION is set to TRUE;
#@ ;# specify to make leakage power optimization focused on lvt cell reduction; 
#@ ;# refer to rm_icc_scripts/multi_vth_constraint.example as an example.	   
#@ set DFT                           FALSE  ;# TRUE|FALSE; set TRUE to enable scan reordering flow and add -optimize_dft option to place_opt and clock_opt commands;
#@ ;# if set TRUE, you should also provide a valid $ICC_IN_SCAN_DEF_FILE
#@ set ICC_TIE_CELL_FLOW             TRUE        ;# TRUE|FALSE, set TRUE if you want TIE-CELLS to be used during optimizations instead of TIE-nets
#@ set ICC_DBL_VIA                   TRUE         ;# TRUE|FALSE; set TRUE to enable redundant via insertion; more options in "Chipfinishing and Metal Fill Variables" section
#@ #modified by mimg 21.05.09
#@ set ICC_FIX_ANTENNA               TRUE        ;# TRUE|FALSE: set TRUE to enable antenna fixing; more options in "Chipfinishing Variables" section
#@ set ADD_FILLER_CELL               FALSE        ;# TRUE|FALSE; set TRUE to enable std cells filler insertion; more options in "Chipfinishing Variables" section
#@ set ICC_CREATE_MODEL              FALSE        ;# TRUE|FALSE; set TRUE to create block abstraction and FRAM view (at block level)
#@ set ICC_REDUCE_CRITICAL_AREA      TRUE         ;# TRUE|FALSE; set TRUE to enable detail route wire spreading
#@ set ADD_METAL_FILL                "ICV"        
#@ ;# Note : It is recommended to use ICV with signoff_metal_fill command for technology nodes 45nm and below
#@ 
#@ ;# ICV : signoff_metal_fill using IC Validator
#@ set ICC_REPORTING_EFFORT          "MED"        ;# OFF|LOW|MED; if set to OFF, no reporting is done; if set to LOW, report_qor/report_constraints/report_power are skipped,
#@ ;# additionally, report_timing is skipped in clock_opt_cts
#@ set ICC_SANITY_CHECK              FALSE        ;# TRUE|FALSE, set TRUE to perform check_physical_design
#@ set ICC_ENABLE_CHECKPOINT	  FALSE	       ;# TRUE|FALSE, set TRUE to perform checkpoint strategy for optimization commands 
#@ ;# ensure there is enough disk space before enabling this feature. refer to the set_checkpoint_strategy man page for details.
#@ 
#@ ###############################
#@ ## General Variables
#@ ###############################
#@ set ICC_INPUT_CEL                 "${DESIGN_NAME}_DCT" ;# starting CEL for flow with a Milkyway CEL input which can be the final CEL from Design Compiler Topographical 
#@ set PNET_METAL_LIST               ""           	;# List of metals in the design to be used for (partial) pnet options
#@ set PNET_METAL_LIST_COMPLETE	  ""	       	;# List of metals in the design to be used for (complete) pnet options
#@ set ICC_IN_DONT_USE_FILE          "$LIBRARY_DONT_USE_FILE" ;# script with library modifications for dont_use; default to $LIBRARY_DONT_USE_FILE in common_setup.tcl 
#@ set ICC_FIX_HOLD_PREFER_CELLS     ""           	;# Syntax: library/cell_name - Example: slow/DLY1X1 slow/DLY1X4
#@ set ICC_MAX_AREA                  ""           	;# max_area value used during area optimization
#@ set MW_EXTENDED_LAYER_MODE        FALSE         ;# FALSE|TRUE: Default FALSE creates a Milkyway design library with the default layer mode that supports user defined and routing layers on layers 1-187 in the technology file. Setting this to TRUE will create a library in the extended layer mode that supports from layers 1-4000 in the technology file. 
#@ set AREA_CRITICAL_RANGE_PRE_CTS   ""           	;# area critical range use during area optimization during place_opt
#@ set AREA_CRITICAL_RANGE_POST_CTS  ""           	;# area critical range use during area optimization during post-CTS optimization 
#@ set AREA_CRITICAL_RANGE_POST_RT   ""           	;# area critical range use during area optimization during route_opt
#@ set POWER_CRITICAL_RANGE_PRE_CTS  ""           	;# power critical range use during area optimization during place_opt
#@ set POWER_CRITICAL_RANGE_POST_CTS ""           	;# power critical range use during area optimization during post-CTS optimization 
#@ set POWER_CRITICAL_RANGE_POST_RT  ""           	;# power critical range use during area optimization during route_opt
#@ set ICC_NUM_CPUS                  1            	;# number of cpus for distributed processing
#@ ;# specify a number greater than 1 to enable it for classic router based route_opt and insert_redundant_via commands
#@ set ICC_NUM_CORES                 4            	;# number of cores on the local host for multicore support; 4 cores are recommended for IC Validator based signoff_metal_fill and
#@ ;# signoff_drc commands
#@ if {[info exists TEV(num_cores)] && [info exists env(LYNX_RTM_PRESENT)]} {
#@ set ICC_NUM_CORES                 $TEV(num_cores)  ;# TEV(num_cores) must be used to control the number of cores when running in Lynx;
#@                                                    ;# Only configure TEV(num_cores) using the Lynx RTM or by editing at the top of the LCRM script
#@ }
#@ set PLACE_OPT_EFFORT 		  "medium"      ;# low|medium|high; choose effort level for place_opt command
#@ set PLACE_OPT_TRADEOFF_TIMING_FOR_POWER_AREA FALSE ;# TRUE|FALSE; set TRUE to enable timing, power and area tradeoff optimization for place_opt command.
#@ ;# It only works for medium effort place_opt with -power option
#@ set ROUTE_OPT_EFFORT 		  "medium"      ;# low|medium|high; choose effort level for route_opt command
#@ set PLACE_OPT_CONGESTION_DRIVEN	  TRUE          ;# TRUE|FALSE; set TRUE to enable congestion removal during place_opt command (place_opt_icc step) and 
#@ ;# clock_opt -only_psyn command (clock_opt_psyn_icc step) 
#@ 
#@ set PLACE_OPT_LAYER_OPTIMIZATION	"TRUE" ;# TRUE|FALSE: Set to TRUE by default to control whether layer optimization is performed during place_opt by set_place_opt_strategy -layer_optimization 
#@ 
#@ set PLACE_OPT_LAYER_OPTIMIZATION_EFFORT	"MEDIUM" ;# medium|high: Set to medium by default. Controls the layer optimization effort during place_opt
#@ 
#@ set PLACE_OPT_CONSIDER_ROUTING		"FALSE" ;# FALSE|TRUE: Default FALSE. Controls whether track RC based optimization is performed during place_opt
#@ ;# The RC models are generated from the current scenario so set the most critical scenario as the current scenario before running place_opt
#@ set ICC_TOTAL_POWER_STRATEGY_EFFORT	none	;# none|medium|high; set to medium or high to improve total power (leakage + dynamic)
#@ ;# A realistic SAIF will be needed to get accurate power savings
#@ ;# For MCMM design an active scenario with dynamic_power, leakage_power, and setup enabled is necessary for total power optimization
#@ ;# Applies to place_opt -power, psynopt -power, and psynopt -only_power
#@ 
#@ set ICC_HIGH_RESISTANCE_OPTIMIZATION	"FALSE" ;# FALSE|TRUE: Default FALSE. Setting to TRUE will enable the high resistance optimization for route_opt and focal_opt. This feature may see increased effect on 20nm and below designs. 
#@ 
#@ set ICC_TNS_EFFORT_PREROUTE		"MEDIUM" ;# MEDIUM|HIGH: Default MEDIUM. Controls the effort of preroute optimization to explore TNS improvements. When set to HIGH preroute optimzation will spend longer looking for TNS improvements. Affects place_opt, clock_opt -only_psyn, psynopt, and preroute_focal_opt.
#@ 
#@ set ICC_TNS_EFFORT_POSTROUTE		"MEDIUM" ;# MEDIUM|HIGH: Default MEDIUM. Controls the effort of postroute optimization to explore TNS improvements. When set to HIGH postroute optimzation will spend longer looking for TNS improvements. Affects route_opt and focal_opt.
#@ 
#@ set PLACE_OPT_PREROUTE_FOCALOPT_LAYER_OPTIMIZATION FALSE 
#@ ;# TRUE|FALSE; set TRUE to perform layer optimization (preroute_focal_opt -layer_optimization) 
#@ ;# on existing buffer trees after place_opt command (place_opt_icc step)
#@ set CLOCK_OPT_PSYN_PREROUTE_FOCALOPT_LAYER_OPTIMIZATION FALSE 
#@ ;# TRUE|FALSE; set TRUE to perform layer optimization (preroute_focal_opt -layer_optimization) 
#@ ;# on existing buffer trees after clock_opt -only_psyn command (clock_opt_psyn_icc step)
#@ set CLOCK_OPT_PSYN_PREROUTE_FOCALOPT_AUTO_NDR FALSE
#@ ;# TRUE|FALSE; set TRUE will perform optimization with automatic routing rules (preroute_focal_opt -auto_routing_rule) 
#@ ;# on existing buffer trees after clock_opt -only_psyn command (clock_opt_psyn_icc step)
#@ set ICC_CREATE_GR_PNG             FALSE  	;# TRUE|FALSE; set TRUE to create a global route congestion map snapshot in PNG format at the end of route_icc step
#@ set ICC_WRITE_FULL_CHIP_VERILOG   FALSE		;# TRUE|FALSE; set TRUE for write_verilog in outputs_icc.tcl to write out module definitions for soft macros 
#@ 
#@ if {![info exists MW_POWER_NET]} {
#@ set MW_POWER_NET 		  "VDD"
#@ }
#@ if {![info exists MW_POWER_PORT]} {
#@ set MW_POWER_PORT                 "VDD"
#@ }
#@ if {![info exists MW_GROUND_NET]} {
#@ set MW_GROUND_NET                 "VSS"
#@ }
#@ if {![info exists MW_GROUND_PORT]} { 
#@ set MW_GROUND_PORT                "VSS"
#@ }
#@ 
#@ set ICC_FLOORPLAN_CEL            ""	
#@ ############################################################
#@ ## Customized Constraint Script for Core Commands (Optional)
#@ ############################################################ 
#@ set CUSTOM_INIT_DESIGN_PRE_SCRIPT ""		;# An optional Tcl file; if specified, will be sourced before the read_def command;
#@ ;# review init_design_icc.tcl script for exact location where this is sourced to avoid overlap with existing constraints
#@ set CUSTOM_PLACE_OPT_PRE_SCRIPT ""		;# An optional Tcl file; if specified, will be sourced right before the place_opt core command;
#@ ;# review place_opt_icc.tcl script for exact location where this is sourced to avoid overlap with existing constraints
#@ set CUSTOM_PLACE_OPT_POST_SCRIPT ""		;# An optional Tcl file; if specified, will be sourced right after the place_opt core command;
#@ ;# review place_opt_icc.tcl script for exact location where this is sourced to avoid overlap with existing constraints
#@ set CUSTOM_CLOCK_OPT_CTS_PRE_SCRIPT ""		;# An optional Tcl file; if specified, will be sourced right before the clock_opt -only_cts core command;
#@ ;# review clock_opt_cts_icc.tcl script for exact location where this is sourced to avoid overlap with existing constraints
#@ set CUSTOM_CLOCK_OPT_CTS_POST_SCRIPT ""		;# An optional Tcl file; if specified, will be sourced right after the clock_opt -only_cts core command;
#@ ;# review clock_opt_cts_icc script for exact location where this is sourced to avoid overlap with existing constraints
#@ set CUSTOM_CLOCK_OPT_PSYN_PRE_SCRIPT ""		;# An optional Tcl file; if specified, will be sourced right before the clock_opt -only_psyn core command;
#@ ;# review clock_opt_psyn_icc.tcl script for exact location where this is sourced to avoid overlap with existing constraints
#@ set CUSTOM_CLOCK_OPT_PSYN_POST_SCRIPT ""	;# An optional Tcl file; if specified, will be sourced right after the clock_opt -only_psyn core command;
#@ ;# review clock_opt_psyn_icc.tcl script for exact location where this is sourced to avoid overlap with existing constraints
#@ set CUSTOM_CLOCK_OPT_ROUTE_PRE_SCRIPT ""	;# An optional Tcl file; if specified, will be sourced before the route_group -all_clock_nets command;
#@ ;# review clock_opt_route_icc.tcl script for exact location where this is sourced to avoid overlap with existing constraints
#@ set CUSTOM_CLOCK_OPT_ROUTE_PRE_CTO_SCRIPT ""	;# An optional Tcl file; if specified, will be sourced before the optimize_clock_tree command;
#@ ;# review clock_opt_route_icc.tcl script for exact location where this is sourced to avoid overlap with existing constraints
#@ set CUSTOM_CLOCK_OPT_ROUTE_POST_CTO_SCRIPT ""	;# An optional Tcl file; if specified, will be sourced after the optimize_clock_tree command;
#@ ;# review clock_opt_route_icc.tcl script for exact location where this is sourced to avoid overlap with existing constraints
#@ set CUSTOM_ROUTE_PRE_SCRIPT ""			;# An optional Tcl file; if specified, will be sourced before the route_opt -initial_route_only command;
#@ ;# review route_icc.tcl script for exact location where this is sourced to avoid overlap with existing constraints
#@ set CUSTOM_ROUTE_POST_SCRIPT ""			;# An optional Tcl file; if specified, will be sourced after the route_opt -initial_route_only command;
#@ ;# review route_icc.tcl script for exact location where this is sourced to avoid overlap with existing constraints
#@ set CUSTOM_ROUTE_OPT_PRE_SCRIPT ""		;# An optional Tcl file; if specified, will be sourced right before the route_opt core command;
#@ ;# review route_opt_icc.tcl script for exact location where this is sourced to avoid overlap with existing constraints
#@ set CUSTOM_ROUTE_OPT_POST_SCRIPT ""		;# An optional Tcl file; if specified, will be sourced right after the route_opt core command;
#@ ;# review route_opt_icc.tcl script for exact location where this is sourced to avoid overlap with existing constraints
#@ set CUSTOM_FOCAL_OPT_PRE_SCRIPT ""		;# An optional Tcl file; if specified, will be sourced before the focal_opt core commands;
#@ ;# review focal_opt_icc.tcl script for exact location where this is sourced to avoid overlap with existing constraints
#@ set CUSTOM_FOCAL_OPT_POST_SCRIPT ""		;# An optional Tcl file; if specified, will be sourced after the focal_opt core commands;
#@ ;# review focal_opt_icc.tcl script for exact location where this is sourced to avoid overlap with existing constraints
#@ set CUSTOM_CHIP_FINISH_POST_SCRIPT ""		;# An optional Tcl file; if specified, will be sourced before the route_opt -inc -size_only command;
#@ ;# review chip_finish_icc.tcl script for exact location where this is sourced to avoid overlap with existing constraints
#@ 
#@ ###############################
#@ ## Floorplan Input Variables          		    
#@ ###############################
#@ set ICC_FLOORPLAN_INPUT           	"DEF"   ;# DEF | FP_FILE | CREATE | USER_FILE | SKIP; "DEF" reads $ICC_IN_DEF_FILE; "FP_FILE" reads ICC_IN_FLOORPLAN_FILE;
#@ ;# "CREATE" uses create_floorplan command; "USER_FILE" sources $ICC_IN_FLOORPLAN_USER_FILE; 
#@ ;# "SKIP" skips floorplanning section
#@ set ICC_IN_DEF_FILE		  	""	;# Complete floorplan file in DEF format
#@ set ICC_IN_SPG_DEF_FILE		        ""	;# Standard cell placement in DEF format from DC for Physical Guidance flow.
#@ ;# The default naming convention for this file from DC-RM is ${DESIGN_NAME}.mapped.std_cell.def
#@ set ICC_IN_FLOORPLAN_FILE	  	""	;# Complete floorplan file generated by write_floorplan 
#@ set ICC_IN_FLOORPLAN_USER_FILE	  	""	;# Complete floorplan file generated by user; This file will simply be sourced.
#@ set ICC_IN_PIN_PAD_PHYSICAL_CONSTRAINTS_FILE ""	;# I/O constraint file generated by write_pin_pad_physical_constraints which contains pin or pad information
#@ ;# applied prior to create_floorplan command   
#@ set ICC_IN_PHYSICAL_ONLY_CELLS_CREATION_FILE "" ;# a file to include physical-only cell creation commands to be sourced
#@ ;# e.g. create_cell {vdd1left vdd1right vdd1top vdd1bottom} pvdi
#@ set ICC_IN_PHYSICAL_ONLY_CELLS_CONNECTION_FILE "" ;# a file to include physical-only cell connection commands to be sourced
#@ ;# e.g. derive_pg_connection -power_net $MW_POWER_NET -power_pin $MW_POWER_PORT -ground_net $MW_GROUND_NET -ground_pin $MW_GROUND_PORT -cells {vdd1left vdd1right vdd1top vdd1bottom}
#@ 
#@ set ICC_PHYSICAL_CONSTRAINTS_FILE 	""	;# script to add incremental floorplan constraints which will be sourced after read_def, read_floorplan, or floorplan creation
#@ set CUSTOM_CONNECT_PG_NETS_SCRIPT 	""      ;# script for customized derive_pg_connection commands which replaces the default derive_pg_connection commands in the scripts   
#@ 
#@ ###############################
#@ ## Timing Variables
#@ ###############################
#@ set ICC_APPLY_RM_DERATING               FALSE 	;# TRUE|FALSE; when set to FALSE, the derating is assumed to be set in the SDC
#@ set ICC_LATE_DERATING_FACTOR	        1.01 	;# Late derating factor, used for both data and clock 
#@ set ICC_EARLY_DERATING_FACTOR	        0.99 	;# Early derating factor, used for both data and clock 
#@ 
#@ set ICC_APPLY_RM_UNCERTAINTY_PRECTS     FALSE	;# TRUE|FALSE; when set to TRUE, user uncertainty will be replaced by $ICC_UNCERTAINTY_PRECTS
#@ set ICC_APPLY_RM_UNCERTAINTY_POSTCTS    FALSE	;# TRUE|FALSE; when set to TRUE, user uncertainty will be replaced by $ICC_UNCERTAINTY_POSTCTS
#@ set ICC_UNCERTAINTY_PRECTS_FILE         ""   	;# Pre-cts uncertainty file used during place_opt
#@ set ICC_UNCERTAINTY_POSTCTS_FILE        ""   	;# Post-cts uncertainty file used during post-CTS optimization and route_opt
#@ set ICC_MAX_TRANSITION                  ""   	;# max_transition value set on the design
#@ set ICC_CRITICAL_RANGE                  ""   	;# critical_range set on the design; default = 50% of each clock period
#@ set ICC_MAX_FANOUT                      ""   	;# max_fanout value set on the design
#@ set ICC_ARNOLDI_EFFORT			"MEDIUM"	;# HIGH|HYBRID|MEDIUM|LOW  Default is MEDIUM which runs a combination of Arnoldi and Elmore for postroute delay calculation. 
#@ ;# When set to HIGH, it will enable full Arnoldi postroute delay calculation. 
#@ ;# When set to HYBRID, it will enable a combination of AWE and Arnoldi postroute delay calculation for faster runtime with comparable accuracy to full Arnoldi.
#@ ;# When set to LOW, postroute delay calculation will only use AWE.
#@ set ICC_PREROUTE_AWE_EFFORT		"NONE"	;# HIGH|MEDIUM|LOW|NONE By default preroute delay calculation uses Elmore. Setting this variable to HIGH, MEDIUM, or LOW will enable AWE for preroute delay calculation at different effort levels.
#@ 
#@ set ICC_IN_AOCV_TABLE_FILE		""	;# A file containing advanced on-chip variation (OCV) derate factor tables written out by PrimeTime's write_binary_aocvm command 
#@ ;# If specified, it will be read right before clock_opt -only_psyn command at clock_opt_psyn_icc step and AOCV analysis will be enabled
#@ ;# In the Concurrent Clock and Data flow it will be read before any clock_opt command is called at the clock_opt_ccd step
#@ 
#@ set ICC_AOCV_SCENARIO_MAPPING           ""      ;# A list of scenarios and the AOCV table file for each specified scenario. e.g "{scenario_1 aocv_file_1} {scenario_2 aocv_file_2} ..."
#@ ;# If specifying scenario specific AOCV data, uncomment the timing_library_derate_is_scenario_specific application variable at the end of this script. 
#@ ;# If design level or hierarchical cell level AOCV data is to be applied, put this AOCV file as the final file to be read in. 
#@ ;# e.g. "{scenario_1 aocv_file_1} {scenario_2 aocv_file_} ... {scenario_n design_aocv_file}"
#@ 
#@ ###############################
#@ ## Multivoltage Variables                       
#@ ###############################
#@ set ICC_IN_RESOLVE_SUPPLY_SET_UPF_FILE  ""      ;# For UPF flow with VERILOG inputs, provide a secondary UPF file to resolve supply sets after reading in the UPF file.
#@ set CUSTOM_CREATE_VA_SCRIPT             "pll_logic.VA.tcl"     	;# For voltage area creation, provide a customized Tcl script. If not provided, you can use the $ICC_DP_AUTO_CREATE_VA
#@ ;# feature which automatically creates voltage area through rm_icc_dp_scripts/create_va_dp.tcl. Otherwise, voltage area
#@ ;# can be created by create_voltage_area commands in the init_design_icc.tcl. 
#@ set ICC_DP_AUTO_CREATE_VA               FALSE  	;# TRUE|FALSE; set TRUE to automatically create voltage area based on user specified utilization in 
#@ ;# rm_icc_dp_scripts/create_va_dp.tcl. 
#@ set CUSTOM_POWER_SWITCH_SCRIPT          ""     	;# A Tcl script to define commands for headers_footers and sleep pin connection
#@ set CUSTOM_SECONDARY_POWER_ROUTE_SCRIPT ""     	;# A Tcl script to define the pre_route_standard_cells command for always-on/retention register cells 
#@ set RR_CELLS                            ""     	;# Specify naming pattern for retention register library cells. Matched cells are set as don't toutch cells and fixed; 
#@ ;# For example, specify "RSD" if each retention register contains RSD in its library cell name
#@ set ICC_UPF_PM_CELL_EXISTING		FALSE	;# TRUE|FALSE; set TRUE to run associate_mv_cells command if design contains pre-existing power management cells.
#@ set ICC_UPF_PM_CELL_INSERTION		FALSE	;# TRUE|FALSE; set TRUE to run insert_mv_cells command.
#@ set ICC_AO_STRATEGY_SINGLE_POWER_POWER_DOMAIN_LIST ""		;# A list of power domains for a single power always-on strategy.
#@ set CUSTOM_AO_STRATEGY_SINGLE_POWER_CREATE_BOUND_SCRIPT ""	;# A Tcl script to create bound for single power always-on cells
#@ set CUSTOM_AO_STRATEGY_SINGLE_POWER_SET_POWER_GUIDE_SCRIPT ""	;# A Tcl script that associates power guides with bounds created by $CUSTOM_AO_STRATEGY_SINGLE_POWER_CREATE_BOUND_SCRIPT
#@ #################################################
#@ ## Multicorner-Multimode (MCMM) Input Variables                             
#@ #################################################
#@ set ICC_MCMM_SCENARIOS_FILE             "mcmm.scenarios.tcl"     	;# A file containing scenario definitions - examples in rm_icc_scripts/mcmm.scenarios.example
#@ set ICC_MCMM_PLACE_OPT_SCENARIOS        ""     	;# list of scenarios to be made active during place_opt; optional; by default all scenarios will be made active
#@ set ICC_MCMM_CLOCK_OPT_PSYN_SCENARIOS   ""     	;# list of scenarios to be made active during post-CTS optimization (pre-route); optional; by default all scenarios will be made active
#@ set ICC_MCMM_CLOCK_OPT_ROUTE_SCENARIOS  ""     	;# list of scenarios to be made active during clock routing; optional; by default all scenarios will be made active
#@ set ICC_MCMM_ROUTE_SCENARIOS            ""     	;# list of scenarios to be made active during signal routing; optional; by default all scenarios will be made active
#@ set ICC_MCMM_ROUTE_OPT_SCENARIOS        ""     	;# list of scenarios to be made active during route_opt; optional; by default all scenarios will be made active
#@ set ICC_MCMM_CHIP_FINISH_SCENARIOS      ""     	;# list of scenarios to be made active during route_opt post chipfinish; optional; by default all scenarios will be made active
#@ set ICC_MCMM_METAL_FILL_SCENARIOS       ""     	;# list of scenarios to be made active during metal filling; optional; by default all scenarios will be made active
#@ set ICC_MCMM_FOCAL_OPT_SCENARIOS       ""     	;# list of scenarios to be made active during focal_opt; optional; by default all scenarios will be made active
#@ 
#@ 
#@ #######################################
#@ ## Clock Tree Synthesis (CTS) Variables
#@ #######################################
#@ set ICC_CTS_RULE_NAME		"iccrm_clock_double_spacing" ;# specify the name of a clock nondefault routing rule that you have defined (for ex, in common_cts_settings_icc.tcl); 
#@ ;# it will be associated with set_clock_tree_options -routing_rule  
#@ ;# If ICC_CTS_RULE_NAME is set to iccrm_clock_double_spacing, double spacings will be applied to all layers
#@ set ICC_CTS_LAYER_LIST		""		;# clock tree layers, usually M3 and above; e.g. set ICC_CTS_LAYER_LIST "M3 M4 M5"
#@ set ICC_CTS_REF_LIST		""		;# cells for CTS; a space-deliminated list: cell1 cell2 
#@ set ICC_CTS_REF_DEL_INS_ONLY	""		;# cells for CTS delay insertion; a space-deliminated list: cell1 cell2
#@ set ICC_CTS_REF_SIZING_ONLY	""		;# cells for CTS sizing only; a space-deliminated list: cell1 cell2 
#@ set ICC_CTS_SHIELD_RULE_NAME	""		;# specify clock shielding rule name; requires $ICC_CTS_SHIELD_SPACINGS, $ICC_CTS_SHIELD_WIDTHS to be also specified    
#@ set ICC_CTS_SHIELD_SPACINGS	""		;# specify clock shielding spacing associated with shielding rule; a list of layer name and spacing pairs
#@ set ICC_CTS_SHIELD_WIDTHS	""		;# specify clock shielding width associated with shielding rule: a list of layer name and width pair
#@ set ICC_CTS_SHIELD_CLK_NAMES	""		;# optionally specify a subset of clock names to apply the clock shielding rule: $ICC_CTS_SHIELD_RULE_NAME;
#@ ;# if not specified, $ICC_CTS_SHIELD_RULE_NAME will be applied to all clock nets 
#@ 
#@ set ICC_CTS_INTERCLOCK_BALANCING	FALSE	;# TRUE|FALSE; set TRUE to enable -inter_clock_balance for "clock_opt -only_cts" at clock_opt_cts_icc task;
#@ ;# specify $ICC_CTS_INTERCLOCK_BALANCING_OPTIONS_FILE to set the options  
#@ set ICC_CTS_INTERCLOCK_BALANCING_OPTIONS_FILE	"" ;# an optional file which contains set_inter_clock_delay_options commands
#@ set ICC_CTS_UPDATE_LATENCY	FALSE		;# set TRUE to perform clock latency update post CTS
#@ set ICC_CTS_LATENCY_OPTIONS_FILE	""	;# an optional file which specifies the latency adjustment options
#@ 
#@ set ICC_CTS_SELF_GATING		FALSE		;# TRUE|FALSE; set TRUE to insert XOR self-gating logic during clock tree synthesis before clock tree construction
#@ ;# An optional gate-level SAIF file ($ICC_IN_SAIF_FILE) is recommended in order to provide clock activity information
#@ set ICC_IN_SAIF_FILE            "$DESIGN_NAME.saif" ;# An optional gate-level SAIF file for self-gating ($ICC_CTS_SELF_GATING)
#@ set ICC_SAIF_INSTANCE_NAME      $DESIGN_NAME	;# the instance in the SAIF file containing switching activity
#@ 
#@ set ICC_POST_CLOCK_ROUTE_CTO	FALSE  	       	;# set TRUE if to perform post route clock tree optimization after clock routing at clock_opt_route_icc step
#@ 
#@ #########################################
#@ ## Routing and Chipfinishing Variables
#@ #########################################
#@ ## end cap cells 
#@ set ICC_H_CAP_CEL                  ""           ;# defines the horizontal CAP CELL library cell 
#@ set ICC_V_CAP_CEL                  ""           ;# defines the vertical CAP CELL library cell (for the Well Proximity Effect)
#@ 
#@ ## redundant via insertion (ICC_DBL_VIA) options
#@ set ICC_DBL_VIA_FLOW_EFFORT      LOW            ;# LOW|MED|HIGH  - MED enables concurrent soft-rule redundant via insertion
#@ ;# HIGH runs another redundant via, timing driven, after chipfinishing
#@ set ICC_CUSTOM_DBL_VIA_DEFINE_SCRIPT ""         ;# script to define the redundant via definitions
#@ set ICC_DBL_VIA_DURING_INITIAL_ROUTING TRUE	;# TRUE|FALSE - TRUE enables automatic redundant via insertion after detail route change of "route_opt -initial"
#@ ;# FALSE runs insert_zrt_redundant_vias after "route_opt -initial"
#@ 
#@ ## antenna fixing (ICC_FIX_ANTENNA) options
#@ set ANTENNA_RULES_FILE           ""             ;# defines the antenna rules
#@ set ICC_USE_DIODES               FALSE          ;# TRUE|FALSE; control variable to allow diodes to be inserted both by the 
#@ ;# insert_port_protection_diodes command as well as the router
#@ set ICC_ROUTING_DIODES           ""             ;# space separated list of diode names
#@ set ICC_PORT_PROTECTION_DIODE    ""             ;# diode name for insert_port_protection_diodes
#@ ;# Format = library_name/diode_name
#@ set ICC_PORT_PROTECTION_DIODE_EXCLUDE_PORTS ""  ;# a list of ports to be excluded by insert_port_protection_diodes
#@ 
#@ ## filler cell insertion (ADD_FILLER_CELL) options
#@ set ICC_CUSTOM_MV_FILLER_CELL_INSERTION_SCRIPT "insert_mv_filler_cells.tcl" 
#@ ;# script for customized filler cell insertion commands for MV designs
#@ ;# use insert_mv_filler_cells.tcl as a template
#@ set FILLER_CELL_METAL            ""             ;# space separated list of filler cells with metals
#@ set FILLER_CELL                  ""             ;# space separated list of filler cells 
#@ 
#@ ## signal em
#@ #modyfied by mimg 21.05.09
#@ set ICC_FIX_SIGNAL_EM		 TRUE		;# TRUE|FALSE; set TRUE to enable signal em fixing; please uncomment the section and follow instruction in chip_finish_icc.tcl 
#@ set ICC_TLUPLUS_SIGNAL_EM_FILE	""		;# The TLU+ file with the advanced signal EM constraints in it to be read by read_signal_em_constraints. This may be the same as the standard TLU+ files. 
#@ set ICC_ITF_SIGNAL_EM_FILE      ""    ;# The ITF file with the advanced signal EM constraints to be read by the read_signal_em_constraints -itf_em command in chip_finish_icc.tcl
#@ 
#@ ###############################
#@ ## Emulation TLUplus Files
#@ ###############################
#@ ## Note : emulated metal fill may not correlate well with real metal fill, especially for advanced technology nodes.
#@ #  Use it for reference only.
#@ set TLUPLUS_MAX_EMULATION_FILE         ""  	;#  Max TLUplus file
#@ set TLUPLUS_MIN_EMULATION_FILE         ""  	;#  Min TLUplus file
#@ 
#@ ###############################
#@ ## check_signoff_correlation  Variables
#@ ###############################
#@ set PT_DIR ""                          		;# path to PrimeTime bin directory
#@ set PT_SDC_FILE ""                     		;# optional file in case PrimeTime has a different SDC that what is available in the IC Compiler database
#@ set STARRC_DIR ""                      		;# path to StarRC bin directory
#@ set STARRC_MAX_NXTGRD ""               		;# MAX NXTGRD file
#@ set STARRC_MIN_NXTGRD ""               		;# MIN NXTGRD file
#@ set STARRC_MAP_FILE "$MAP_FILE"        		;# NXTGRD mapping file, defaults to TLUPlus mapping file, but could be different
#@ 
#@ set ICC_SIGNOFF_OPT_CHECK_CORRELATION_POSTROUTE_SCRIPT "" ;# a file to be sourced to run at check_signoff_correlation end of route_opt_icc step; 
#@ ;# example - rm_icc_scripts/signoff_opt_check_correlation_postroute_icc.example.tcl
#@ 
#@ #######################################
#@ ## Metal fill and Signoff DRC Variables
#@ #######################################
#@ ## For IC Validator metal Fill - ensure environment variable PRIMEYIELD_HOME_DIR is set and that IC Validator is included in the same path where the IC Compiler shell is executed from
#@ ## For IC Validator DRC - ensure environment variable ICV_HOME_DIR is set and that IC Validator is included in the same path where the IC Compiler shell is executed from
#@ 
#@ set SIGNOFF_FILL_RUNSET ""             		;# IC Validator runset for signoff_metal_fill command
#@ set SIGNOFF_DRC_RUNSET  ""             		;# IC Validator runset for signoff_drc command
#@ set SIGNOFF_MAPFILE     ""             		;# IC Validator mapping file for signoff_metal_fill and signoff_drc commands
#@ set ICC_ECO_SIGNOFF_DRC_MODE	"NONE"		;# NONE|AUTO_ECO determines whether signoff_drc will run in the Auto ECO flow mode. 
#@ 
#@ ## Options for signoff_metal_fill command using ICV engine in metal_fill_icc.tcl
#@ set SIGNOFF_METAL_FILL_TIMING_DRIVEN FALSE  	;# TRUE|FALSE : set this to TRUE to enable timing driven for IC Validator metal fill 	
#@ set TIMING_PRESERVE_SLACK_SETUP	"0.1"  		;# float : setup slack threshold for timing driven ICV metal fill; default 0.1
#@ ;# also used by wire_spreading/widening in chip_finishi_icc.tcl
#@ set TIMING_PRESERVE_SLACK_HOLD "0"     		;# float : hold slack threshold for wire_spreading/widening in chip_finishi_icc.tcl; default 0
#@ ## Options for insert_metal_fill command using ICC engine in metal_fill_icc.tcl
#@ set ICC_METAL_FILL_SPACE           2            ;# space amount used during the IC Compiler insert_metal_fill command
#@ set ICC_METAL_FILL_TIMING_DRIVEN  TRUE          ;# enables timing driven metal fill for the IC Compiler insert_metal_fill command
#@ ###############################
#@ ## focal_opt Variables
#@ ###############################
#@ set ICC_FOCAL_OPT_HOLD_VIOLS     "all"          ;# filename|all - blank to skip; filename to fix violations from a file; specify "all" to fix all hold violations
#@ set ICC_FOCAL_OPT_SETUP_VIOLS    ""          	  ;# filename|all - blank to skip; filename to fix violations from a file; specify "all" to fix all setup violations
#@ set ICC_FOCAL_OPT_DRC_NET_VIOLS  "all"          ;# filename|all - blank to skip; filename to fix violations from a file; specify "all" to fix all DRC net violations
#@ set ICC_FOCAL_OPT_DRC_PIN_VIOLS  ""             ;# filename|all - blank to skip; filename to fix violations from a file; specify "all" to fix all DRC pin violations
#@ set ICC_FOCAL_OPT_XTALK_VIOLS    ""             ;# filename - blank to skip; filename to fix crosstalk violations from a file
#@ 
#@ ###############################
#@ ## ECO Flow Variables
#@ ###############################
#@ set ICC_ECO_FLOW		"NONE" 	;# NONE|UNCONSTRAINED|FREEZE_SILICON
#@ ;# UNCONSTRAINED : NO spare cell insertion ; cells can be added (pre tapeout)
#@ ;# FREEZE_SILICON : spare cell insertion/freeze silicon ECO
#@ set ICC_SPARE_CELL_FILE         ""     	;# Tcl script to insert the spare cells, e.g. :
#@ ;# insert_spare_cells -lib_cell {INV8 DFF1} -cell_name spares -num_instances 300
#@ set ICC_ECO_FILE                ""     	;# a verilog netlist or Tcl file containing ECO changes - specify the file name and type of file using ICC_ECO_FLOW_TYPE
#@ set ICC_ECO_FLOW_TYPE		"verilog" ;# verilog | pt_drc_setup_fixing_tcl | pt_hold_fixing_tcl | pt_minimum_physical_impact - specify type of ECO file for UNCONSTRAINED ICC_ECO_FLOW;
#@ ;# depending on the value specified, the commands used to read ECO file and place ECO cells vary;
#@ ;# specify verilog if you provide a functional eco file for ICC_ECO_FILE;
#@ ;# specify pt_drc_setup_fixing_tcl if you provide a change file generated by the PrimeTime fix_eco_drc or fix_eco_timing -setup commands;
#@ ;# specify pt_hold_fixing_tcl if you provide a change file generated by the PrimeTime fix_eco_timing -hold command
#@ ;# specify pt_minimum_physical_impact if you provide a change file generated by the PrimeTime fix_eco_timing  or fix_eco_leakage command 
#@ set ICC_ECO_METAL_FILL_MODE	"early_stage" ;# early_stage | signoff_stage; only ICV is supported;
#@ ;# specify early stage to use ICV DRC based metal fill trimming (faster);
#@ ;# specify signoff_stage to perform complete ICV metal fill purge, ADR and metal fill insertion  
#@ 
#@ 
#@ ########################################################################################################################
#@ ############                        IC COMPILER DESIGN PLANNING SPECIFIC                         #######################   
#@ ############(variables for IC Compiler Design Planning and IC Compiler Hierarchical Reference Methodologies)  ##########
#@ ########################################################################################################################
#@ 
#@ ########################################################################################################################
#@ ## Common variables (applied to both IC Compiler Design Planning and IC Compiler Hierarchical Reference Methodologies )
#@ ########################################################################################################################
#@ 
#@ set ICC_DP_VERBOSE_REPORTING		FALSE		;# TRUE|FALSE; generate additional reports before placement
#@ set ICC_DP_SET_HFNS_AS_IDEAL_THRESHOLD	""		;# integer; specify a threshold to set nets with fanout larger than it as ideal nets
#@ set ICC_DP_SET_MIXED_AS_IDEAL		TRUE		;# TRUE|FALSE; set mixed clock/signal paths as ideal nets
#@ 
#@ set ICC_DP_FIX_MACRO_LIST		""		;# ""|skip|"a_list_of_macros"; unfix all macros OR skip fix OR fix specified macros before placement
#@ set CUSTOM_ICC_DP_PLACE_CONSTRAINT_SCRIPT ""            ;# Put your set_keepout_margin and fp_set_macro_placement_constraint in this file 
#@ set CUSTOM_ICC_DP_PREROUTE_STD_CELL_SCRIPT ""		;# File to perform customized preroute_standard_cell commands
#@ 
#@ ## PNS and PNA control variables
#@ set CUSTOM_ICC_DP_PNS_CONSTRAINT_SCRIPT ""              ;# File to add PNS constraints which is loaded before running PNS
#@ set PNS_POWER_NETS         		"${MW_POWER_NET} ${MW_GROUND_NET}" ;# Target nets for PNS; syntax is "your_power_net your_ground_net" 
#@ set PNS_POWER_BUDGET       		1000          	;# Unit in milliWatts; default is 1000
#@ set PNS_VOLTAGE_SUPPLY     		1.5           	;# Unit in Volts; default is 1.5
#@ set PNS_VIRTUAL_RAIL_LAYER 		""              ;# Specify the metal layer you want to use as virtual rail
#@ set PNS_OUTPUT_DIR         		"./pna_output"  ;# Output directory for PNS and PNA output files
#@ set PNA_EXTRACTION_TEMPERATURE		""		;# Float; set the wire extraction temperature for PNA. Optional.
#@ set PNA_EXTRACTION_CORNER		""		;# min|max; set the parasitic corner for RC extraction for PNA. Optional.
#@ 
#@ ###############################################################
#@ ## IC Compiler Hierarchical Reference Methodology Variables
#@ ###############################################################
#@ 
#@ set ICC_DP_PLAN_GROUPS		"$HIERARCHICAL_CELLS"	;# full module names from which plan groups will be created
#@ ;#   space deliminated list: "top/A top/B top/C"
#@ ;# default to $HIERARCHICAL_CELLS from common_setup.tcl if using Design Compiler Topographical
#@ set ICC_DP_PLANGROUP_FILE               ""              ;# floorplan file containing plan group creation and location which should be the output of write_floorplan
#@ 
#@ set ICC_DP_ALLOW_FEEDTHROUGH	        FALSE		;# TRUE|FALSE; allow feedthrough creation during pin assignment 
#@ 
#@ set CUSTOM_ICC_DP_PNS_SCRIPT 		""              ;# customized PNS script; replacing PNS section in scripts; for template based PNS, this is required
#@ set CUSTOM_ICC_DP_PNA_SCRIPT 		""              ;# customized PNA script; replacing PNA section in scripts
#@ 
#@ ## DFT-aware hierarchical design planning variables 
#@ set ICC_DP_DFT_FLOW			FALSE		;# TRUE|FALSE; enable DFT-aware hierarchical design planning flow; requires ICC_IN_FULL_CHIP_SCANDEF_FILE
#@ set ICC_IN_FULL_CHIP_SCANDEF_FILE "$DESIGN_NAME.mapped.expanded.scandef"		
#@ ;# full-chip SCANDEF file for DFT-aware hierarchical design planning flow (see $ICC_DP_DFT_FLOW)
#@ ;# used only in hierarchical design planning phase; not used or needed for block level implementations and top level assembly 
#@ 
#@ 
#@ 
#@ set BUDGETING_SDC_OUTPUT_DIR            "./sdc"         ;# budgeting SDC output directory; default is "./sdc"
#@ 
#@ 
#@ ## TIO and block abstraction variables
#@ set ICC_BLOCK_ABSTRACTIONS_LIST		""		;# a list of all the block abstractions used in the design;
#@ ;# if left empty, the list will be auto set to include all soft macros in the design if you are following HRM step-by-step 
#@ 
#@ set ICC_TIO_BLOCK_LIST			$ICC_BLOCK_ABSTRACTIONS_LIST
#@ ;# a list of names of block abstractions that are to be optimized by transparent interface optimization (TIO) at route_opt_icc;
#@ ;# you can change it to a subset of block abstractions before route_opt_icc starts  
#@ 
#@ set ICC_TIO_OPTIMIZE_BLOCK_INTERFACE    TRUE            ;# TRUE|FALSE; set TRUE for TIO to optimize interface logic
#@ set ICC_TIO_OPTIMIZE_MIM_BLOCK_INTERFACE FALSE          ;# TRUE|FALSE; set TRUE for TIO to optimize inside MIM blocks; set true only when you are opening MIM blocks for TIO
#@ set ICC_TIO_OPTIMIZE_SHARED_LOGIC       FALSE           ;# TRUE|FALSE; set TRUE for TIO to optimize shared logic; requires $ICC_TIO_OPTIMIZE_BLOCK_INTERFACE to be also enabled
#@ set ICC_TIO_BLOCK_UPDATE_SETUP_SCRIPT	""		;# Script for block abstraction setup, useful for variable settings during block update. To be used during set_top_implementation_options -block_update_setup_script ICC_TIO_BLOCK_UPDATE_SETUP_SCRIPT.  The file name should not include relative paths
#@ 
#@ set ICC_TIO_HOST_OPTION 		""		;# lsf|grd|samehost|list_of_hosts; this controls the set_host_options value for TIO
#@ ;# if either lsf or grd is specified, you must also specify $ICC_TIO_HOST_OPTION_SUBMIT_OPTIONS 
#@ ;# if list_of_hosts is specified, you must also specify $ICC_TIO_HOST_OPTION_HOSTS_LIST
#@ ;# Please note that if $ICC_TIO_OPTIMIZE_BLOCK_INTERFACE is set to TRUE and $ICC_TIO_BLOCK_LIST is not empty,
#@ ;# which are both default for HRM, you should also specify a valid value for $ICC_TIO_HOST_OPTION
#@ 
#@ set ICC_TIO_HOST_OPTION_SUBMIT_OPTIONS {}		;# controls the value of -submit_option option for set_host_options for TIO 
#@ ;# If $ICC_TIO_HOST_OPTION is set to lsf, 
#@ ;# then lsf specific submit options should be specified and vice versa, for example, 
#@ ;# {-q bnormal -R "rusage\[mem=12000\]\cputype==emt64 cpuspeed==EMT3000 qsc==e"}
#@ 
#@ set ICC_TIO_HOST_OPTION_HOSTS_LIST	""              ;# a list of hosts on which to perform automatic block update during TIO
#@ 
#@ 
#@ set ICC_TIO_WRITE_ECO_FILE              FALSE		;# TRUE|FALSE; set TRUE for TIO to write out an ECO file to TIO_eco_changes directory
#@ 
#@ set ICC_IMPLEMENTATION_PHASE		default         ;# default|block|top; set it to block or top to disable tasks such as Milkyway design library creation,
#@ ;# importing of black boxes, scenario creation, voltage area creation, and power switch creation, etc 
#@ ;# in init_design_icc.tcl which should have been completed during design planning phase and should be skipped during 
#@ ;# block and top level implementation phases; also set it to top to enable TIO at route_opt_icc task;
#@ ;# if you are following IC Compiler Hierarchical RM step-by-step, please do not change this;
#@ ;# it will be automatically set to block or top for block or top level designs, respectively
#@ 
#@ set MW_SOFT_MACRO_LIBS                  ""       	;# a list containing paths to all block libraries; they will be added as reference libraries of the top level library
#@ ;# if you are following IC Compiler Hierarchical RM step-by-step, please do not change this;
#@ ;# it will be automatically set to include all block libraries in the design for top level implementation
#@ 
#@ 
#@ ###############################################################################
#@ ## IC Compiler Design Planning Reference Methodology (Flat) Variables
#@ ###############################################################################
#@ 
#@ ## explore mode: flow control variables
#@ set ICC_DP_EXPLORE_MODE			TRUE		;# TRUE|FALSE; turn on exploration mode
#@ set ICC_DP_EXPLORE_STYLE		default		;# valid options are: default | placement_only | no_pns_pna | no_ipo
#@ ;# default: place -> PNS/PNA -> in-place optimization -> final groute, snapshot, QoR, timing, and outputs 
#@ ;# placement_only: skips pns/pna and in-place optimization from default | no_pns_pna: skips pna/pns from default 
#@ ;# | no_ipo: skips in-place optimization from default 
#@ set ICC_DP_EXPLORE_SAVE_CEL_EACH_STEP 	FALSE		;# TRUE|FALSE; save 3 additional CEL after placement, in-place optimization, and PNS in explore mode (requires more disk space)
#@ set ICC_DP_EXPLORE_REPORTING_EACH_STEP	FALSE		;# TRUE|FALSE; generate QoR snapshot and timing report after each step (longer run time)
#@ set ICC_DP_EXPLORE_USE_GLOBAL_ROUTE 	FALSE		
#@ set ICC_DP_EXPLORE_SAVE_CEL_AFTER_GROUTE TRUE		;# TRUE|FALSE; save 2 additional CEL after global route: one after placement and one at the end
#@ set ICC_DP_EXPLORE_CUSTOM_PG_SCRIPT	""		;# string; script to be loaded to create customized PG straps after placement in explore mode; 
#@ ;# valid only if ICC_DP_EXPLORE_STYLE is placement_only or no_pns_pna
#@ 
#@ ## explore mode: additional PNS control variables
#@ set PNS_TARGET_VOLTAGE_DROP     	250	        ;# Unit in milliVolts. Tool default is 10% of PNS_POWER_BUDGET
#@ set PNS_BLOCK_MODE         		FALSE           ;# TRUE|FALSE; specify if the design is block or top level; It turns on correspondant options in PNS and PNA
#@ set PNS_PAD_MASTERS        		""		;# Only for top level design with power pads. Specify cell masters for power pads, e.g. "pv0i.FRAM pv0a.FRAM"
#@ set PNS_PAD_INSTANCE_FILE  		""              ;# Only for top level design with power pads. Specify the file with a list of power pad instances
#@ set PNS_PAD_MASTER_FILE    		""		;# Only for top level design with power pads. Specify the file with a list of power pad masters
#@ ## Please provide only one of PNS_PAD_MASTERS, OR PNS_PAD_INSTANCE_FILE, OR PNS_PAD_MASTER_FILE 
#@ 
#@ #####################################################################################################################################
#@ ## NO NEED TO CHANGE THE FOLLOWING IF Design Compiler Reference Metholodgy IS USED PRIOR TO IC Compiler Reference Methodology
#@ #####################################################################################################################################
#@ set ICC_IN_VERILOG_NETLIST_FILE "$DESIGN_NAME.mapped.v" ;#1 to n verilog input files, spaced by blanks
#@ set ICC_IN_SDC_FILE             "$DESIGN_NAME.mapped.sdc"
#@ set ICC_IN_DDC_FILE             "$DESIGN_NAME.mapped.ddc"
#@ set ICC_IN_UPF_FILE             "$DESIGN_NAME.mapped.upf"
#@ set ICC_IN_SCAN_DEF_FILE        "" 			;# default from Design Compiler Reference Metholodgy is $DESIGN_NAME.mapped.scandef
#@ 
#@ ###################################################################################################################
#@ if {$upf_create_implicit_supply_sets} {
#@ 	# Starting G-2012.06 release, the variable upf_create_implicit_supply_sets enables creation of supply set handles
#@ 	# while creating power domains. Default is true.
#@ 	# The if clause is added to ensure it's changed only once per session. Refer to man page for details.
#@ 	# To change the value to false, please uncomment the following line :
#@ 
#@ 	set_app_var upf_create_implicit_supply_sets false
#@ }
#@ ###################################################################################################################
#@ 
#@ if {[info exists SEV(rpt_dir)]} {
#@ 	set REPORTS_DIR $SEV(rpt_dir)				;# Directory to write reports.
#@ } else {
#@ 	set REPORTS_DIR "../rpts/null"			;# Directory to write reports.
#@ }
#@ if {[info exists SEV(dst_dir)]} {
#@ 	set RESULTS_DIR $SEV(dst_dir)				;# Directory to write output data files
#@ } else {
#@ 	set RESULTS_DIR "../work/null"			;# Directory to write output data files
#@ }
#@ set SOURCE_DIR $RESULTS_DIR				;# Source directory for analysis tasks such as FM and MVRC
#@ 
#@ set MW_DESIGN_LIBRARY           "../work/${DESIGN_NAME}_LIB"    ;# milkyway design library
#@ set COPY_FROM_MW_DESIGN_LIBRARY "../run/${DESIGN_NAME}_LIB" ;# specify a milkyway design library if you want reference methodology to copy it as MW_DESIGN_LIBRARY
#@ ;# only applies if ICC_INIT_DESIGN_INPUT is set to Milkyway
#@ 
#@ set REPORTS_DIR_INIT_DESIGN                     $REPORTS_DIR
#@ set REPORTS_DIR_PLACE_OPT                       $REPORTS_DIR
#@ set REPORTS_DIR_CLOCK_OPT_CTS                   $REPORTS_DIR
#@ set REPORTS_DIR_CLOCK_OPT_PSYN                  $REPORTS_DIR
#@ set REPORTS_DIR_CLOCK_OPT_ROUTE                 $REPORTS_DIR
#@ set REPORTS_DIR_ROUTE                           $REPORTS_DIR
#@ set REPORTS_DIR_ROUTE_OPT                       $REPORTS_DIR
#@ set REPORTS_DIR_CHIP_FINISH                     $REPORTS_DIR
#@ set REPORTS_DIR_ECO                        	$REPORTS_DIR
#@ set REPORTS_DIR_FOCAL_OPT                       $REPORTS_DIR
#@ set REPORTS_DIR_SIGNOFF_OPT                     $REPORTS_DIR
#@ set REPORTS_DIR_METAL_FILL                      $REPORTS_DIR
#@ set REPORTS_DIR_DP            			$REPORTS_DIR
#@ set REPORTS_DIR_DP_CREATE_PLANGROUPS		$REPORTS_DIR
#@ set REPORTS_DIR_DP_ROUTEABILITY_ON_PLANGROUPS   $REPORTS_DIR
#@ set REPORTS_DIR_DP_PIN_ASSIGNMENT_BUDGETING     $REPORTS_DIR
#@ set REPORTS_DIR_DP_COMMIT                       $REPORTS_DIR
#@ set REPORTS_DIR_DP_PREPARE_BLOCK                $REPORTS_DIR
#@ set REPORTS_DIR_FORMALITY			$REPORTS_DIR
#@ 
#@ if { ! [file exists $REPORTS_DIR_INIT_DESIGN] } { file mkdir $REPORTS_DIR_INIT_DESIGN }
#@ if { ! [file exists $REPORTS_DIR_PLACE_OPT] } { file mkdir $REPORTS_DIR_PLACE_OPT }
#@ if { ! [file exists $REPORTS_DIR_CLOCK_OPT_CTS] } { file mkdir $REPORTS_DIR_CLOCK_OPT_CTS }
#@ if { ! [file exists $REPORTS_DIR_CLOCK_OPT_PSYN] } { file mkdir $REPORTS_DIR_CLOCK_OPT_PSYN }
#@ if { ! [file exists $REPORTS_DIR_CLOCK_OPT_ROUTE] } { file mkdir $REPORTS_DIR_CLOCK_OPT_ROUTE }
#@ if { ! [file exists $REPORTS_DIR_ROUTE] } { file mkdir $REPORTS_DIR_ROUTE }
#@ if { ! [file exists $REPORTS_DIR_ROUTE_OPT] } { file mkdir $REPORTS_DIR_ROUTE_OPT }
#@ if { ! [file exists $REPORTS_DIR_CHIP_FINISH] } { file mkdir $REPORTS_DIR_CHIP_FINISH }
#@ if { ! [file exists $REPORTS_DIR_ECO] } { file mkdir $REPORTS_DIR_ECO }
#@ if { ! [file exists $REPORTS_DIR_FOCAL_OPT] } { file mkdir $REPORTS_DIR_FOCAL_OPT }
#@ if { ! [file exists $REPORTS_DIR_SIGNOFF_OPT] } { file mkdir $REPORTS_DIR_SIGNOFF_OPT }
#@ if { ! [file exists $REPORTS_DIR_METAL_FILL] } { file mkdir $REPORTS_DIR_METAL_FILL }
#@ if { ! [file exists $REPORTS_DIR_DP] } { file mkdir $REPORTS_DIR_DP }
#@ if { ! [file exists $REPORTS_DIR_DP_CREATE_PLANGROUPS] } { file mkdir $REPORTS_DIR_DP_CREATE_PLANGROUPS }
#@ if { ! [file exists $REPORTS_DIR_DP_ROUTEABILITY_ON_PLANGROUPS] } { file mkdir $REPORTS_DIR_DP_ROUTEABILITY_ON_PLANGROUPS }
#@ if { ! [file exists $REPORTS_DIR_DP_PIN_ASSIGNMENT_BUDGETING] } { file mkdir $REPORTS_DIR_DP_PIN_ASSIGNMENT_BUDGETING }
#@ if { ! [file exists $REPORTS_DIR_DP_COMMIT] } { file mkdir $REPORTS_DIR_DP_COMMIT }
#@ if { ! [file exists $REPORTS_DIR_DP_PREPARE_BLOCK] } { file mkdir $REPORTS_DIR_DP_PREPARE_BLOCK }
#@ if { ! [file exists $REPORTS_DIR_FORMALITY] } { file mkdir $REPORTS_DIR_FORMALITY }
#@ 
#@ 
#@ ## Logical libraries
#@ set_app_var search_path	". ../scr $ADDITIONAL_SEARCH_PATH $search_path" 
#@ if {$synopsys_program_name != "mvrc" || $synopsys_program_name != "vsi" || $synopsys_program_name != "vcst"} {
#@ 	set_app_var target_library	"$TARGET_LIBRARY_FILES"
#@ 	set_app_var link_library	"* $TARGET_LIBRARY_FILES $ADDITIONAL_LINK_LIB_FILES"
#@ } else {
#@ 	set_app_var link_library	"$TARGET_LIBRARY_FILES $ADDITIONAL_LINK_LIB_FILES"
#@ }
#@ 
#@ 
#@ if { ! [file exists $RESULTS_DIR] } {
#@ 	file mkdir $RESULTS_DIR
#@ }
#@ if { ! [file exists $REPORTS_DIR] } {
#@ 	file mkdir $REPORTS_DIR
#@ }
#@ 
#@ if {$synopsys_program_name == "icc_shell"} {
#@ 
#@ ## Min/Max library relationships
#@ #  For "set_operating_conditions -analysis_type on_chip_variation", it is not recommended if only -max is specified.
#@ #  (such as in rm_icc_scripts/mcmm.scenarios.example) 
#@ #  Only use it if both -max and -min of set_operating_conditions are specified and point to two different libraries
#@ #  and are characterized to model OCV effects of the same corner.
#@ if {$MIN_LIBRARY_FILES != "" } {
#@ 	foreach {max_library min_library} $MIN_LIBRARY_FILES {
#@ 	set_min_library $max_library -min_version $min_library
#@ 	}
#@ }
#@ 
#@ ## Reference libraries
#@ if { ![file exists [which $MW_REFERENCE_CONTROL_FILE]]} {
#@ 	if {[file exists $MW_DESIGN_LIBRARY/lib]} {
#@ 	set_mw_lib_reference $MW_DESIGN_LIBRARY -mw_reference_library "$MW_REFERENCE_LIB_DIRS $MW_SOFT_MACRO_LIBS"
#@ 	}
#@ }
#@ 
#@ ## PD4 is not always used
#@ if {![info exists PD4]} {set PD4 ""}
#@ 
#@ ## Avoiding too many messages
#@ set_message_info -id PSYN-040 -limit 10 ;# Dont_touch for fixed cells
#@ set_message_info -id PSYN-087 -limit 10 ;# Port inherits its location from pad pin
#@ set_message_info -id LINT-8   -limit 10 ;# input port is unloaded
#@ 
#@ set_message_info -id PWR-536  -limit 5  ;# The library cell ... is not characterized for internal power.
#@ set_message_info -id UID-401  -limit 5  ;# Design rule attributes from the driving cell will be set on the port.
#@ suppress_message PWR-824                ;# The default value of the -leakage_power and -dynamic_power options of the set_scenario_options command changed from true to false in the F-2011.09 release.
#@ 
#@ set_app_var check_error_list "$check_error_list LINK-5 PSYN-375"
#@ 
#@ }
#@ 
#@ 
#@ if {$synopsys_program_name == "fm_shell"} {
#@ set_app_var sh_new_variable_message false
#@ } 
#@ 
#@ 
#@ ## Uncomment this variable if you wish for specified library cell derates set 
#@ # with the set_timing_derate command or AOCV data for library cells to be saved
#@ # in the Milkyway database.
#@ # When true, this variable will enable any derates specified on library cells to
#@ # be saved to the Milkyway database:
#@ #
#@ # set_app_var timing_save_library_derate true
#@ 
#@ ## Uncomment this variable to make set_timing_derate and read_aocvm only applied
#@ # to the current scenario for settings related to library cell objects :
#@ #  set_app_var timing_library_derate_is_scenario_specific true
#@ 
#@ #################################################################################
#@ 
#@ source ../rm_setup/procs.tcl
#@ # -- Starting source ../rm_setup/procs.tcl

#@ # Synopsys Customer Education Services
#@ # IC Compiler Workshop series
#@ #
#@ # Tcl procedures to simplify life...
#@ 
#@ puts "\#\#\# Processing procs.tcl..."
#@ 
#@ create_command_group CES_procs
#@ set TOOLS_VIEW_PATH "../rm_setup"
#@ 
#@ # Get command results/reports in separate graphical tk window
#@ # This expects view.tk to be in the path, which is the other half
#@ # of this procedure!
#@ # Examples: view man compile,  view report_timing -max_paths 20
#@ #======================================================
#@ #Compatibility with VCS/DVE:
#@ if {[info exists uclidir]} {
#@         set view_proc_name tview
#@         alias v tview
#@ } else {
#@         set view_proc_name view
#@         alias v view
#@ }
#@ proc $view_proc_name {args} {
#@         global TOOLS_VIEW_PATH
#@         set VIEW_COMMAND $TOOLS_VIEW_PATH/view.tk
#@         if {$args == ""} {
#@                 puts "Please provide a command."
#@                 return
#@         }
#@ 
#@         if { [catch {open "| $VIEW_COMMAND \"$args\"" w} PIPE] } {
#@                 return "Can't open pipe for '$VIEW_COMMAND'"
#@         }
#@         redirect -channel $PIPE {uplevel $args}
#@         flush $PIPE
#@ }
#@ if {$view_proc_name == "view"} {
#@         define_proc_attributes $view_proc_name         -info "Display output of any command in a separate Tk window."         -command_group CES_procs         -define_args { {args "Command with arguments" args} }
#@ }
#@ 
#@ proc qor {name} {
#@         file mkdir reports
#@         create_qor_snapshot -name $name
#@         redirect -file reports/$name.qor_snapshot.rpt {report_qor_snapshot -no_display}
#@ }
#@ 
#@ # Generates statistics on the current session:
#@ # Rev 1.0
#@ # amins@synopsys.com
#@ proc host_stats {} {
#@         redirect -variable cated {exec cat /proc/cpuinfo}
#@         set cated [split $cated "\n"]
#@         foreach l $cated {
#@                 regexp {^model name\s*\:\s+(.+)$} $l m cpu_model
#@                 regexp {^cpu MHz\s*\:\s+(.+)$} $l m cpu_mhz
#@                 regexp {^cache size\s*\:\s+(\d+)} $l m cache_size
#@                 regexp {^processor\s*\:\s+(\d+)} $l m num_cores
#@         }
#@         incr num_cores
#@ 
#@         redirect -variable cated {exec cat /proc/meminfo}
#@         set cated [split $cated "\n"]
#@         foreach l $cated {
#@                 regexp {^MemTotal\s*\:\s+(\d+)} $l m mem_total
#@                 regexp {^MemFree\s*\:\s+(\d+)} $l m mem_free
#@         }
#@         set mem_total [format "%-6.2f" [expr $mem_total / 1024.0 / 1024.0]]
#@         set mem_free  [format "%-6.2f" [expr $mem_free  / 1024.0 / 1024.0]]
#@ 
#@         puts "####################################################"
#@         puts "##### Session information:"
#@         puts ""
#@         puts "    Date:              [date]"
#@         puts "    hostname:          [exec hostname]"
#@         puts "    uname -a:          [exec uname -a]"
#@         puts "    CPU model:         $cpu_model"
#@         puts "    CPU MHz:           $cpu_mhz"
#@         puts "    CPU cache:         $cache_size"
#@         puts "    Number of cores:   $num_cores"
#@         puts "    Total memory:      $mem_total GB"
#@         puts "    Free memory:       $mem_free GB"
#@         puts "    bin path:          $::bin_path"
#@         puts ""
#@         puts "####################################################"
#@ }
#@ define_proc_attributes host_stats         -info "Display statistics of the current host (server)"         -command_group CES_procs
#@ 
#@ 
#@ proc gui {} {
#@         uplevel {
#@                 if {$in_gui_session == false} {
#@                         gui_start
#@                 } else {
#@                         gui_stop
#@                         echo "... or just 'gui'"
#@                 }
#@         }
#@ }
#@ define_proc_attributes gui         -info "Start or stop the GUI"         -command_group CES_procs
#@ 
#@ alias vman "view man"
#@ 
#@ 
#@ #
#@ # Always Ask
#@ # This useful procedure is on solvnet, Doc Id  012959
#@ #
#@ proc aa {args} {
#@ 
#@         parse_proc_arguments -args $args results
#@ 
#@         echo "*********  Commands **********"
#@         help *$results(pattern)*
#@ 
#@         echo "********* Variables **********"
#@         uplevel "printvar *$results(pattern)*"
#@ 
#@         if {[info exists results(-verbose)]} {
#@                 echo "********* -help *************"
#@                 apropos *$results(pattern)*
#@         }
#@ }; # end proc
#@ 
#@ define_proc_attributes aa -info "always ask - Searches Synopsys help for both commands and variables"         -command_group CES_procs         -define_args {
#@                 {pattern "Pattern to search for" pattern string required}
#@                 {-verbose "Search -help as well" "" boolean optional}
#@         }
#@ 
#@ 
#@ #echo "The following procedures are defined for use in this workshop."
#@ #echo "They are NOT standard IC Compiler commands."
#@ help CES_procs
#@ 
#@ 
#@ # Define a few useful aliases for the class
#@ alias cs change_selection
#@ alias csa "change_selection -add"
#@ alias rt "report_timing -capacitance -transition_time -significant_digits 3"
#@ alias rts {report_timing -capacitance -transition_time -significant_digits 3 -scenarios [all_active_scenarios]}
#@ alias rc "report_constraint -all"
#@ alias rcs {report_constraint -all -scenarios [all_active_scenarios]}
#@ alias h history
#@ alias ac all_connected
#@ alias fo "all_fanout -from"
#@ alias fi "all_fanin -to"
#@ 
#@ history keep 100
#@ 
#@ set gui_online_browser "firefox"
#@ # -- End source ../rm_setup/procs.tcl

#@ 
#@ puts "RM-Info: Completed script [info script]\n"
#@ # -- End source ../rm_setup/icc_setup.tcl

#@ 
#@ #open_mw_lib ${DESIGN_NAME}_LIB
#@ copy_mw_cel -from data_setup -to floorplan
#@ open_mw_cel floorplan
#@ ########################################################################################
#@ #Create a Rectangular Block
#@ ########################################################################################
#@ set_fp_pin_constraints 			-block_level             -use_physical_constraints on 			-hard_constraints {layer location}
#@ #source ../scr/aestop_pad1021.tcl
#@ source ../scr/pin.tcl
#@ # -- Starting source ../scr/pin.tcl

#@ #for {set i 0} {$i<9} {incr i} { #    set_pin_physical_constraints -pin_name "din[[expr $i]]"  -side 1 -order [expr $i+1] }
#@ #
#@ #for {set i 10} {$i<16} {incr i} { #    for {set j 1} {$j<7} {incr j} { #        set_pin_physical_constraints -pin_name "din[[expr $i]]" -side 2 -order [expr $j] } #}
#@ #
#@ #set_pin_physical_constraints -pin_name clk -side 2 -order 7
#@ #set_pin_physical_constraints -pin_name rst -side 2 -order 8
#@ #set_pin_physical_constraints -pin_name staenc -side 2 -order 9 
#@ #set_pin_physical_constraints -pin_name stadec -side 3 -order 7
#@ #set_pin_physical_constraints -pin_name load_shift -side 3 -order 8
#@ #set_pin_physical_constraints -pin_name loadkey -side 3 -order 9
#@ #
#@ #for {set i 0} {$i<9} {incr i} { #    set_pin_physical_constraints -pin_name "dout[[expr $i]]"  -side 4 -order [expr $i+1] }
#@ #for {set i 10} {$i<16} {incr i} { #    for {set j 1} {$j<7} {incr j} { #        set_pin_physical_constraints -pin_name "dout[[expr $i]]" -side 3 -order [expr $j] } #}
#@ #side 1
#@ set_pin_physical_constraints -pin_name "din[0]" -side 1 -order 1
#@ set_pin_physical_constraints -pin_name "din[1]" -side 1 -order 2
#@ set_pin_physical_constraints -pin_name "din[2]" -side 1 -order 3
#@ set_pin_physical_constraints -pin_name "din[3]" -side 1 -order 4
#@ set_pin_physical_constraints -pin_name "din[4]" -side 1 -order 5
#@ set_pin_physical_constraints -pin_name "din[5]" -side 1 -order 6
#@ set_pin_physical_constraints -pin_name "din[6]" -side 1 -order 7
#@ set_pin_physical_constraints -pin_name "din[7]" -side 1 -order 8
#@ set_pin_physical_constraints -pin_name "dout[7]" -side 1 -order 9
#@ #set_pin_physical_constraints -pin_name "din[8]" -side 1 -order 9
#@ 
#@ #side2
#@ #
#@ set_pin_physical_constraints -pin_name "VDD" -side 2 -order 1
#@ set_pin_physical_constraints -pin_name "VSS" -side 2 -order 2
#@ #set_pin_physical_constraints -pin_name "din[9]" -side 2 -order 2
#@ #set_pin_physical_constraints -pin_name "din[10]" -side 2 -order 3
#@ #set_pin_physical_constraints -pin_name "din[11]" -side 2 -order 4
#@ #set_pin_physical_constraints -pin_name "din[12]" -side 2 -order 5
#@ #set_pin_physical_constraints -pin_name "din[13]" -side 2 -order 6
#@ #set_pin_physical_constraints -pin_name "din[14]" -side 2 -order 7
#@ #set_pin_physical_constraints -pin_name "din[15]" -side 2 -order 8
#@ set_pin_physical_constraints -pin_name "clk" -side 2 -order 3
#@ set_pin_physical_constraints -pin_name "rst" -side 2 -order 4
#@ set_pin_physical_constraints -pin_name "staenc" -side 2 -order 5
#@ 
#@ 
#@ #side3
#@ set_pin_physical_constraints -pin_name "stadec" -side 3 -order 1
#@ set_pin_physical_constraints -pin_name "load_shift" -side 3 -order 2
#@ set_pin_physical_constraints -pin_name "loadkey" -side 3 -order 3
#@ set_pin_physical_constraints -pin_name "dout[0]" -side 3 -order 4
#@ set_pin_physical_constraints -pin_name "dout[1]" -side 3 -order 5
#@ set_pin_physical_constraints -pin_name "dout[2]" -side 3 -order 6
#@ set_pin_physical_constraints -pin_name "dout[3]" -side 3 -order 7
#@ set_pin_physical_constraints -pin_name "dout[4]" -side 3 -order 8
#@ set_pin_physical_constraints -pin_name "dout[5]" -side 3 -order 9
#@ set_pin_physical_constraints -pin_name "dout[6]" -side 3 -order 10
#@ 
#@ 
#@ #side4
#@ 
#@ #set_pin_physical_constraints -pin_name "dout[8]" -side 4 -order 4
#@ #set_pin_physical_constraints -pin_name "dout[9]" -side 4 -order 5
#@ #set_pin_physical_constraints -pin_name "dout[10]" -side 4 -order 6
#@ #set_pin_physical_constraints -pin_name "dout[11]" -side 4 -order 7
#@ #set_pin_physical_constraints -pin_name "dout[12]" -side 4 -order 8
#@ #set_pin_physical_constraints -pin_name "dout[13]" -side 4 -order 9
#@ #set_pin_physical_constraints -pin_name "dout[14]" -side 4 -order 10
#@ #set_pin_physical_constraints -pin_name "dout[15]" -side 4 -order 11
#@ # -- End source ../scr/pin.tcl

#@ 
#@ #Create_floorplan
#@ initialize_rectilinear_block 			-shape L 			-control_type length 			-core_side_dim {212 0 0 212} 			-core_utilization 0.7 			-row_core_ratio 1.0 			-left_io2core 20 			-right_io2core 20 			-top_io2core 20 			-bottom_io2core 20
#@ #create_floorplan 		-control_type aspect_ratio 		-core_utilization 0.7 		-core_aspect_ratio 1.3 		-bottom_io2core 100 		-left_io2core 100 		-top_io2core 100 		-right_io2core 100
#@ #create_floorplan 		-control_type width_and_height 		-core_width  796 		-core_height 568 		-bottom_io2core 20 		-left_io2core 20 		-top_io2core 20 		-right_io2core 20 
#@ 
#@ #insert_pad_filler -cell "PFILL50W PFILL22W PFILL10W PFILL5W PFILL2W PFILL1W PFILL01W PFILL001W "
#@ 
#@ save_mw_cel -as floorplan
#@ 
#@ 
#@ ########################################################################################
#@ #Specify Unrouting Layers
#@ ########################################################################################
#@ set_ignored_layer -max_routing_layer M6
#@ report_ignored_layers 
#@ #save_mw_cel -as ${DESIGN_NAME}_prepns
#@ 
#@ ########################################################################################
#@ #Add EndCAP TapCell
#@ ########################################################################################
#@ #add_end_cap -respect_keepout -fill_corner -lib_cell FDCAPHD4 SEN_CAPL8 SEN_CAPR8
#@ add_end_cap -fill_corner -mode bottom_left -lib_cell SEN_CAPL8
#@ add_end_cap -fill_corner -mode upper_right -lib_cell SEN_CAPR8
#@ 
#@ add_tap_cell_array 			-master_cell_name {SEN_TAPDS1T5} 			-distance 40 			-pattern stagger_every_other_row 			-respect_keepout
#@ 
#@ ########################################################################################
#@ #Create the Power Network
#@ ########################################################################################
#@ ########################################################################################
#@ #Preforming Power Planning
#@ ########################################################################################
#@ 
#@ #create_power_ring strategy
#@ #create_power_plan_regions core -core
#@ #set_power_ring_strategy strategy_core -nets {VDD VSS} #	-core -template ../scr/ring.tpl:ring_around_va
#@ #remove_power_plan_strategy -all
#@ #set_power_plan_strategy power_plan 		-nets {VDD VSS} -core 		-extension {{{nets:VDD}{stop:outermost_ring}}{{nets:VSS}{stop:outermost_ring}}} 		-template ../scr/pg_mesh.tpl:pg_mesh_top
#@ 
#@ 
#@ #compile_power_plan -ring
#@ #compile_power_plan
#@ create_rectilinear_rings  -nets  {VDD VSS}  -offset {1 1} -width {0.2 0.2} -space {1 1} -layers {M5 M6}
#@ derive_pg_connection -power_net VDD -power_pin VDD  		     -ground_net VSS -ground_pin VSS
#@ derive_pg_connection -power_net {VDD} -ground_net {VSS} -tie
#@ create_power_straps  -direction horizontal  -start_at 73 -num_placement_strap 3 -increment_x_or_y 53 -nets  {VDD VSS}  -layer M5 -width 0.1
#@ create_power_straps  -direction vertical  -start_at 73 -num_placement_strap 3 -increment_x_or_y 53 -nets  {VDD VSS}  -layer M6 -width 0.1
#@ #create_power_straps 		 -direction vertical 		 -nets  {VDD VSS} 		 -layer M6  		 -width 1 		 -configure rows 		 -step 40 		 -pitch_within_group 2 		 -extend_low_ends to_first_target                  -extend_high_ends to_first_target 		 -keep_floating_wire_pieces
#@ #create_power_straps 		 -direction horizontal 		 -nets  {VDD VSS} 		 -layer METAL5  		 -width 1 		 -configure rows 		 -step 187 		 -pitch_within_group 2 		 -extend_low_ends to_first_target                  -extend_high_ends to_first_target 		 -keep_floating_wire_pieces
#@ 
#@ derive_pg_connection -power_net VDD -power_pin VDD  		     -ground_net VSS -ground_pin VSS
#@ derive_pg_connection -power_net {VDD} -ground_net {VSS} -tie
#@ 
#@ 
#@ save_mw_cel -as  afterpns
#@ #create_power_straps -undo
#@ preroute_standard_cells -nets "VDD VSS" 		-connect horizontal 		-fill_empty_rows 		-port_filter_mode off 		-cell_master_filter_mode off 		-cell_instance_filter_mode off 		-voltage_area_filter_mode off
#@ 
#@ create_fp_placement -congestion -timing -no_hierarchy_gravity
#@ route_zrt_global -congestion_map_only true -exploration true
#@ save_mw_cel -as floorplan_finish
#@ preroute_instances
#@ 
#@ #Coarse Placement
#@ create_placement -effort high -timing_driven
#@ #legalize Placement
#@ legalize_placement -effort high
#@ report_congestion
#@ 
#@ 
#@ ########################################################################################
#@ #Placement
#@ ########################################################################################
#@ #Placement Optimization
#@ set_pnet_options -partial {M6 M5}
#@ set_pnet_options -complete {M6 M5}
#@ 
#@ place_opt -effort high -congestion
#@ 
#@ report_congestion
#@ report_timing
#@ report_constraint -all_violators
#@ save_mw_cel -as ${DESIGN_NAME}_placement
#@ ########################################################################################
#@ #CTS
#@ ########################################################################################
#@ check_physical_design -stage pre_clock_opt
#@ check_clock_tree
#@ 
#@ remove_ideal_network [get_ports clk]
#@ remove_clock_uncertainty [all_clocks]
#@ 
#@ #set_clock_tree_option -target_early_delay 0.9
#@ #set_clock_tree_options -target_skew 0.2
#@ #report_clock_tree -settings
#@ 
#@ remove_routing_rules -all
#@ 
#@ define_routing_rule clk_dsdw 	-default_reference_rule 	-multiplier_spacing 2 	-multiplier_width 2
#@ 
#@ set_clock_tree_options -routing_rule clk_dsdw 	-layer_list {METAL1 METAL2 METAL3 METAL4 METAL5 METAL6} 	-use_default_routing_for_sinks 1
#@ 
#@ set_clock_tree_references -references {SEN_BUF_S_1 SEN_BUF_S_2 SEN_BUF_S_3}
#@ clock_opt -only_cts -no_clock_route
#@ 
#@ update_clock_latency
#@ report_clock_tree
#@ report_clock_tree -summary
#@ report_clock_timing -type skew
#@ 
#@ ########################################################################################
#@ #POST CTS
#@ ########################################################################################
#@ #foreach_in_collection clk [get_clocks] {
#@ #	remove_clock_latency $clk
#@ #	remove_ideal_network [all_fanout -flat -clock_tree]
#@ #	set_propagated_clock [get_attr $clk sources]
#@ #	set_clock_uncertainty -setup 1 $clk
#@ #	set_clock_uncertainty -hold 0.1 $clk
#@ #}
#@ 
#@ set_fix_hold [all_clocks]
#@ 
#@ clock_opt -no_clock_route -fix_hold_all_clock
#@ 
#@ 
#@ ########################################################################################
#@ #Route
#@ ########################################################################################
#@ derive_pg_connection -power_net VDD -power_net VDD 						-ground_net VSS -ground_pin VSS
#@ derive_pg_connection -power_net {VDD} -ground_net {VSS} -tie
#@ source $ANTENNAFILE
#@ # -- Starting source ../../../../hu40nmlib/1.02a/milkyway/antenna/antenna_rule_db_update_m07f0f1f0_RDL.tcl

#@ #;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#@ #                     HUALI N40 Antenna Rule for Astro/ICC Router
#@ #;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#@ #--------------------------------------------------------------------------------
#@ 
#@ set_parameter -name doAntennaConx -value 4
#@ set lib [current_mw_lib];
#@ remove_antenna_rules $lib
#@ 
#@ set topMetalLayer 7;
#@ set topViaLayer 6;
#@ set RDLMetal RDL;
#@ set RDLVia RV;
#@ 
#@ ##### Single metal layer sidewall area rule #####
#@ define_antenna_rule $lib   -mode 4   -diode_mode 4   -metal_ratio 0   -cut_ratio 0
#@ 
#@ define_antenna_layer_rule $lib   -mode 4   -layer "$RDLMetal"   -ratio 2000   -diode_ratio {0.06 0 8000 30000}
#@ 
#@ ##### Single metal/via layer area rule #####
#@ define_antenna_rule $lib   -mode 1   -diode_mode 4   -metal_ratio 0   -cut_ratio 20
#@ 
#@ 
#@ define_antenna_layer_rule $lib             -mode 1             -layer T4M2             -ratio 5000             -diode_ratio {0.06 0 8000 50000}
#@ 
#@ define_antenna_layer_rule $lib             -mode 1             -layer "$RDLVia"             -ratio 200             -diode_ratio {0.06 0 83 410}
#@ 
#@ for {set i 1} {$i < $topViaLayer} {incr i} {
#@   define_antenna_layer_rule $lib     -mode 1     -layer "V$i"     -ratio 20     -diode_ratio {0.06 0 210 910}
#@ }
#@ 
#@ ##### Cumulative metal/via layer area rule #####
#@ define_antenna_rule $lib   -mode 2   -diode_mode 4   -metal_ratio 0   -cut_ratio 0
#@ 
#@ for {set i 1} {$i < $topMetalLayer} {incr i} {
#@   define_antenna_layer_rule $lib     -mode 2     -layer "M$i"     -ratio 5000     -diode_ratio {0.06 0 457 43000}
#@ }
#@ 
#@ 
#@ define_antenna_layer_rule $lib     -mode 2     -layer T4M2     -ratio 5000     -diode_ratio {0.06 0 8000 50000}
#@ 
#@ 
#@ for {set i 1} {$i < $topViaLayer} {incr i} {
#@   define_antenna_layer_rule $lib     -mode 2     -layer "V$i"     -ratio 910     -diode_ratio {0.06 0 210 910}
#@ }
#@ 
#@ define_antenna_layer_rule $lib     -mode 2     -layer T4V2     -ratio 910     -diode_ratio {0.06 0 210 910}
#@ 
#@ 
#@ ##### Routing Option Related to Antenna Fixing #####
#@ set_parameter -name doAntennaConx -value 4 -module droute
#@ 
#@ report_antenna_rules -output antenna.rule
#@ # -- End source ../../../../hu40nmlib/1.02a/milkyway/antenna/antenna_rule_db_update_m07f0f1f0_RDL.tcl

#@ route_zrt_group -all_clock_nets
#@ route_zrt_auto
#@ 
#@ report_timing
#@ report_constraint -all_violators
#@ 
#@ focal_opt -drc_nets all -effort high
#@ focal_opt -hold_endpoints all -effort high
#@ 
#@ verify_zrt_route 		-antenna true 		-check_from_user_shapes true 		-check_from_frozen_shapes true 		-report_all_open_nets true
#@ #route_zrt_detail -incremental true -initial_drc_from_input true
#@ insert_stdcell_filler -cell_with_metal {SEN_DCAP64 SEN_DCAP32 SEN_DCAP16 SEN_DCAP8 SEN_DCAP4} -connect_to_power VDD -connect_to_ground VSS -metal_filler_coverage_area 1000
#@ insert_stdcell_filler 		-cell_without_metal {SEN_FILL64 SEN_FILL32 SEN_FILL16 SEN_FILL12 SEN_FILL8 SEN_FILL6 SEN_FILL5 SEN_FILL4 SEN_FILL3 SEN_FILL2 SEN_FILL1}
#@ 
#@ #
#@ insert_ng_filler
#@ 
#@ verify_lvs -max_error 2000 > ../rpts/lvs.rpt
#@ report_design -physical > ../rpts/pr_summary.rpt
#@ 
#@ #source ../scr/create_text.tcl
#@ save_mw_cel -as finish
#@ save_mw_cel -as ${DESIGN_NAME}_allfinish
#@ save_mw_cel
#@ set_write_stream_options -map_layer ${hu40}/lef/streamout.map 					     -output_pin {text geometry} 						 -flatten_via 
#@ write_stream -format gds 		-lib_name ${DESIGN_NAME}_LIB 		-cell_file  ${hu40}/gds/hu40npksdst.gds 		-cells "${DESIGN_NAME}_allfinish" 		../out/${DESIGN_NAME}.gds
#@ write_verilog ../out/${DESIGN_NAME}_pred.v
#@ #output withouit fillcells
#@ #write_verilog -pg -unconnected_ports -no_cover_cells -no_io_pad_cells -no_unconnected_cells -no_flip_chip_bump_cells -no_physical_only_cells -supply_statement none -force_output_references  {SEN_DCAP64 SEN_DCAP32 SEN_DCAP16 SEN_DCAP8 SEN_DCAP4} ../out/${DESIGN_NAME}_pg.v
#@ 
#@ set write_sdc_output_lumped_net_capacitance false
#@ set write_sdc_output_net_resistance false
#@ write_sdc ../out/${DESIGN_NAME}.out.sdc
#@ 
#@ extract_rc -coupling_cap
#@ write_parasitics -output ../out//${DESIGN_NAME}.spef 	-format SPEF 	-no_name_mapping
#@ # -- End source ../scr/design_run.tcl

exit
